
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module InjectNeutral</title>
<meta name="description" content="Documentation of Coq module InjectNeutral" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module InjectNeutral</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="compcert.cklr.CKLR.html">CKLR</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="compcert.lib.Axioms.html">Axioms</a></span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="compcert.cklr.Inject.html">Inject</a></span>.<br/>
<br/>
<h1> Self-injection as a CKLR </h1>
<br/>
<span class="kwd">Global</span> <span class="kwd">Instance</span> <span class="id"><a name="block_le_preo">block_le_preo</a></span>:<br/>
&nbsp;&nbsp;<span class="id"><a href="http://coq.inria.fr/library/Coq.Classes.RelationClasses.html#PreOrder">PreOrder</a></span> <span class="id">Block.le</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2418')">Proof.</div>
<div class="proofscript" id="proof2418">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">exact</span> <span class="id">Block.le_refl</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">exact</span> <span class="id">Block.le_trans</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Global</span> <span class="kwd">Instance</span> <span class="id">mem_flat_inj_incr</span>:<br/>
&nbsp;&nbsp;<span class="id">Monotonic</span> (@<span class="id">Mem.flat_inj</span>) (<span class="id">Block.le</span> ++&gt; <span class="id">inject_incr</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2419')">Proof.</div>
<div class="proofscript" id="proof2419">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span>. <span class="tactic">repeat</span> <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span> <span class="id">Hb</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Block.lt_dec</span> <span class="id">b</span> <span class="id">x</span>); <span class="id">inv</span> <span class="id">Hb</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Block.lt_dec</span> <span class="id">b</span>' <span class="id">y</span>); <span class="tactic">try</span> <span class="id">blomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>. <span class="id">blomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">injn</span>: <span class="id">cklr</span> :=<br/>
&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">world</span> := <span class="id">block</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wacc</span> := <span class="id">Block.le</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mi</span> := <span class="id">Mem.flat_inj</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_mem</span> <span class="id">w</span> := (<span class="id">match_mem</span> <span class="id">inj</span> (<span class="id">Mem.flat_inj</span> <span class="id">w</span>) /\ <span class="id">req</span> <span class="id">w</span> @@ <span class="id">Mem.nextblock</span>)%<span class="id">rel</span>;<br/>
&nbsp;&nbsp;|}.<br/>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2420')">Next Obligation.</div>
<div class="proofscript" id="proof2420">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">H</span> <span class="id">_</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">cklr_wf</span> <span class="id">inj</span> (<span class="id">Mem.flat_inj</span> <span class="id">w</span>) <span class="id">m1</span> <span class="id">m2</span>); <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2421')">Next Obligation.</div>
<div class="proofscript" id="proof2421">
 <span class="comment">(*&nbsp;Mem.alloc&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] <span class="id">lo</span> <span class="id">hi</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m1</span> <span class="id">lo</span> <span class="id">hi</span>) <span class="kwd">as</span> [<span class="id">m1</span>' <span class="id">b1</span>] <span class="id">eqn</span>:<span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.alloc_parallel_inject</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">as</span> (<span class="id">f</span>' &amp; <span class="id">m2</span>' &amp; <span class="id">b2</span> &amp; <span class="id">Hm2</span>' &amp; <span class="id">Hm</span>' &amp; <span class="id">Hf</span>'' &amp; <span class="id">Hb2</span> &amp; <span class="id">Hf</span>');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Block.succ</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>)); <span class="tactic">split</span>; <span class="tactic">repeat</span> <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="tactic">simpl</span>. <span class="id">blomega</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">replace</span> (<span class="id">Mem.flat_inj</span> (<span class="id">Block.succ</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>))) <span class="kwd">with</span> <span class="id">f</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">transitivity</span> (<span class="id">Mem.flat_inj</span> <span class="id">nb</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">meminj_wf_incr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">x</span> <span class="id">y</span> [<span class="id">d</span> <span class="id">Hxy</span>] <span class="id">Hy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Block.eq</span> <span class="id">x</span> <span class="id">b1</span>); <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">assert</span> (<span class="id">y</span> = <span class="id">b2</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">Hm2</span>'; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">Block.lt_strict</span> <span class="id">Block.init</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Block.le_lt_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.init_nextblock</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">Hf</span>' <span class="kwd">in</span> <span class="id">Hxy</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">meminj_wf_img</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functional_extensionality</span>; <span class="tactic">intros</span> <span class="id">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">Hf</span>' <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span> <span class="kwd">in</span> <span class="id">Hf</span>' |- *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Block.lt_dec</span> <span class="id">b</span> <span class="id">nb</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> (<span class="id">Block.lt_dec</span> <span class="id">b</span> (<span class="id">Block.succ</span> <span class="id">nb</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Hf</span>'; <span class="id">solve</span> [<span class="id">blomega</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>; <span class="id">blomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> (<span class="id">Block.lt_dec</span> <span class="id">b</span> (<span class="id">Block.succ</span> <span class="id">nb</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Block.lt_succ_inv</span> <span class="kwd">in</span> <span class="id">l</span>. <span class="tactic">destruct</span> <span class="id">l</span>; [<span class="id">contradiction</span> | <span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Block.nlt_le</span> <span class="kwd">in</span> <span class="id">n0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Block.lt</span> <span class="id">nb</span> <span class="id">b</span>) <span class="tactic">by</span> <span class="id">blomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Blt_ne</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">Mem.nextblock_alloc</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_alloc</span> <span class="kwd">in</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">rewrite</span> <span class="id">Hm1</span>', <span class="id">Hm2</span>'. <span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Hm1</span>'. <span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Block.lt_dec</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>; <span class="id">blomega</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2422')">Next Obligation.</div>
<div class="proofscript" id="proof2422">
 <span class="comment">(*&nbsp;Mem.free&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] [[<span class="id">b1</span> <span class="id">lo1</span>] <span class="id">hi1</span>] [[<span class="id">b2</span> <span class="id">lo2</span>] <span class="id">hi2</span>] <span class="id">Hr</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.free</span> <span class="id">m1</span> <span class="id">b1</span> <span class="id">lo1</span> <span class="id">hi1</span>) <span class="kwd">as</span> [<span class="id">m1</span>'|] <span class="id">eqn</span>:<span class="id">Hm1</span>'; [|<span class="id">rauto</span>].<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">Hr</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_inject</span> <span class="kwd">as</span> (<span class="id">m2</span>' &amp; <span class="id">Hm2</span>' &amp; <span class="id">Hm</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">lo1</span> + <span class="id">delta</span> + <span class="id">sz</span>) <span class="kwd">with</span> (<span class="id">lo1</span> + <span class="id">sz</span> + <span class="id">delta</span>) <span class="tactic">by</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hm2</span>'. <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nb</span>; <span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_free</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_free</span> <span class="kwd">in</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="tactic">red</span>. <span class="tactic">rewrite</span> <span class="id">Hm1</span>', <span class="id">Hm2</span>'. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2423')">Next Obligation.</div>
<div class="proofscript" id="proof2423">
 <span class="comment">(*&nbsp;Mem.load&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">pose</span> <span class="id">proof</span> (<span class="id">cklr_load</span> <span class="id">inj</span>). <span class="tactic">repeat</span> <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [[? ?] ?]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [[? ?] ?]; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2424')">Next Obligation.</div>
<div class="proofscript" id="proof2424">
 <span class="comment">(*&nbsp;Mem.store&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">chunk</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] <span class="id">_</span> <span class="id">_</span> [<span class="id">b1</span> <span class="id">ofs1</span> <span class="id">b2</span> <span class="id">delta</span> <span class="id">Hptr</span>] <span class="id">v1</span> <span class="id">v2</span> <span class="id">Hv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.store</span> <span class="id">chunk</span> <span class="id">m1</span> <span class="id">b1</span> <span class="id">ofs1</span> <span class="id">v1</span>) <span class="kwd">as</span> [<span class="id">m1</span>'|] <span class="id">eqn</span>:<span class="id">Hm1</span>'; [|<span class="id">rauto</span>].<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.store_mapped_inject</span> <span class="kwd">as</span> (<span class="id">m2</span>' &amp; <span class="id">Hm2</span>' &amp; <span class="id">Hm</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hm2</span>'. <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nb</span>; <span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_store</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_store</span> <span class="kwd">in</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hnb</span>. <span class="tactic">red</span>. <span class="tactic">rewrite</span> <span class="id">Hm1</span>', <span class="id">Hm2</span>'. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2425')">Next Obligation.</div>
<div class="proofscript" id="proof2425">
 <span class="comment">(*&nbsp;Mem.loadbytes&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] <span class="id">_</span> <span class="id">_</span> [<span class="id">b1</span> <span class="id">ofs1</span> <span class="id">b2</span> <span class="id">delta</span> <span class="id">Hptr</span>] <span class="id">sz</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.loadbytes</span> <span class="id">m1</span> <span class="id">b1</span> <span class="id">ofs1</span> <span class="id">sz</span>) <span class="kwd">as</span> [<span class="id">vs1</span>|] <span class="id">eqn</span>:<span class="id">Hvs1</span>; [|<span class="id">rauto</span>].<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.loadbytes_inject</span> <span class="kwd">as</span> (<span class="id">vs2</span> &amp; <span class="id">Hvs2</span> &amp; <span class="id">Hvs</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hvs2</span>. <span class="id">rauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2426')">Next Obligation.</div>
<div class="proofscript" id="proof2426">
 <span class="comment">(*&nbsp;Mem.storebytes&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] [<span class="id">b1</span> <span class="id">ofs1</span>] [<span class="id">b2</span> <span class="id">ofs2</span>] <span class="id">Hptr</span> <span class="id">vs1</span> <span class="id">vs2</span> <span class="id">Hvs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.storebytes</span> <span class="id">m1</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>) <span class="kwd">as</span> [<span class="id">m1</span>'|] <span class="id">eqn</span>:<span class="id">Hm1</span>'; [|<span class="id">constructor</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">vs1</span> = <span class="id">nil</span> \/ <span class="id">vs1</span> &lt;&gt; <span class="id">nil</span>) <span class="kwd">as</span> [<span class="id">Hvs1</span>|<span class="id">Hvs1</span>].<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">vs1</span>; <span class="id">constructor</span>; <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;- <span class="tactic">subst</span>. <span class="id">inv</span> <span class="id">Hvs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">edestruct</span> (<span class="id">Mem.range_perm_storebytes</span> <span class="id">m2</span> <span class="id">b2</span> <span class="id">ofs2</span> <span class="id">nil</span>) <span class="kwd">as</span> [<span class="id">m2</span>' <span class="id">Hm2</span>'].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">ofs</span>. <span class="tactic">simpl</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nb</span>; <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">rauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.storebytes_empty_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_storebytes</span> <span class="kwd">in</span> <span class="id">Hm1</span>'. <span class="tactic">rewrite</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_storebytes</span> <span class="kwd">in</span> <span class="id">Hm2</span>'. <span class="tactic">rewrite</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">ptr_inject</span> (<span class="id">Mem.flat_inj</span> <span class="id">nb</span>) (<span class="id">b1</span>, <span class="id">ofs1</span>) (<span class="id">b2</span>, <span class="id">ofs2</span>)) <span class="kwd">as</span> <span class="id">Hptr</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hptr</span> <span class="kwd">as</span> [<span class="id">Hptr</span>|<span class="id">Hptr</span>]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hptr</span> <span class="kwd">as</span> [<span class="id">_</span> <span class="id">_</span> [<span class="id">xb1</span> <span class="id">xofs1</span> <span class="id">xb2</span> <span class="id">delta</span> <span class="id">Hb</span>]]; <span class="tactic">clear</span> <span class="id">Hptr</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ptrbits_unsigned</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.address_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.storebytes_range_perm</span> <span class="kwd">in</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vs1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">Hptr</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.storebytes_mapped_inject</span> <span class="kwd">as</span> (<span class="id">m2</span>' &amp; <span class="id">Hm2</span>' &amp; <span class="id">Hm</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hm2</span>'. <span class="tactic">repeat</span> <span class="id">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nb</span>; <span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; [<span class="id">rauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_storebytes</span> <span class="kwd">in</span> <span class="id">Hm1</span>'. <span class="tactic">rewrite</span> <span class="id">Hm1</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.nextblock_storebytes</span> <span class="kwd">in</span> <span class="id">Hm2</span>'. <span class="tactic">rewrite</span> <span class="id">Hm2</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2427')">Next Obligation.</div>
<div class="proofscript" id="proof2427">
 <span class="comment">(*&nbsp;Mem.perm&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] <span class="id">_</span> <span class="id">_</span> [<span class="id">b1</span> <span class="id">ofs1</span> <span class="id">b2</span> <span class="id">delta</span> <span class="id">Hb</span>] <span class="id">p</span> <span class="id">k</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_inject</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2428')">Next Obligation.</div>
<div class="proofscript" id="proof2428">
 <span class="comment">(*&nbsp;Mem.valid_block&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">nb</span> <span class="id">m1</span> <span class="id">m2</span> [[<span class="id">Hm</span> <span class="id">Hwf</span>] <span class="id">Hnb</span>] <span class="id">b1</span> <span class="id">b2</span> [<span class="id">delta</span> <span class="id">Hb</span>].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2429')">Next Obligation.</div>
<div class="proofscript" id="proof2429">
 <span class="comment">(*&nbsp;Mem.meminj_no_overlap&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[? ?] ?].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.mi_no_overlap</span>; <span class="id">rauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2430')">Next Obligation.</div>
<div class="proofscript" id="proof2430">
 <span class="comment">(*&nbsp;representable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[? ?] ?].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">Ptrofs.unsigned_repr</span> <span class="id">ofs1</span>) <span class="tactic">by</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.mi_representable</span>; <span class="tactic">try</span> <span class="id">rauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span> <span class="tactic">by</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2431')">Next Obligation.</div>
<div class="proofscript" id="proof2431">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[? ?] ?].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.aligned_area_inject</span>; <span class="id">rauto</span>.<br/>
Qed.</div>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2432')">Next Obligation.</div>
<div class="proofscript" id="proof2432">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[? ?] ?].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.disjoint_or_equal_inject</span>; <span class="id">rauto</span>.<br/>
Qed.</div>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</a></div>
</body>
</html>
