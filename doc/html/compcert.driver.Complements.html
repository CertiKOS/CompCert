
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Complements</title>
<meta name="description" content="Documentation of Coq module Complements" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Complements</h1>
<div class="coq">
<br/>
<div class="doc">Corollaries of the main semantic preservation theorem. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Classical</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span> <span class="id">Events</span> <span class="id">Smallstep</span> <span class="id">Behaviors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Csyntax</span> <span class="id">Csem</span> <span class="id">Cstrategy</span> <span class="id">Asm</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Compiler</span>.<br/>
<br/>
<h1> Preservation of whole-program behaviors </h1>
<br/>
<div class="doc">From the simulation diagrams proved in file <span class="bracket"><span class="id">Compiler</span></span>. it follows that
  whole-program observable behaviors are preserved in the following sense.
  First, every behavior of the generated assembly code is matched by
  a behavior of the source C code.  The behavior <span class="bracket"><span class="id">beh</span></span> of the assembly
  code is either identical to the behavior <span class="bracket"><span class="id">beh</span>'</span> of the source C code
  or ``improves upon'' <span class="bracket"><span class="id">beh</span>'</span>  by replacing a ``going wrong'' behavior
  with a more defined behavior. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_c_program_preservation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">beh</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">beh</span>', <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">p</span>) <span class="id">beh</span>' /\ <span class="id">behavior_improves</span> <span class="id">beh</span>' <span class="id">beh</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5302')">Proof.</div>
<div class="proofscript" id="proof5302">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">backward_simulation_behavior_improves</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transf_c_program_correct</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">As a corollary, if the source C code cannot go wrong, i.e. is free of
  undefined behaviors, the behavior of the generated assembly code is
  one of the possible behaviors of the source C code. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_c_program_is_refinement</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">not_wrong</span> <span class="id">beh</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span> -&gt; <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">p</span>) <span class="id">beh</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5303')">Proof.</div>
<div class="proofscript" id="proof5303">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">backward_simulation_same_safe_behavior</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transf_c_program_correct</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">If we consider the C evaluation strategy implemented by the compiler,
  we get stronger preservation results. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_cstrategy_program_preservation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">beh</span>', <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span>' /\ <span class="id">behavior_improves</span> <span class="id">beh</span> <span class="id">beh</span>')<br/>
/\(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">beh</span>', <span class="id">program_behaves</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>) <span class="id">beh</span>' /\ <span class="id">behavior_improves</span> <span class="id">beh</span>' <span class="id">beh</span>)<br/>
/\(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">not_wrong</span> <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span>)<br/>
/\(<span class="kwd">forall</span> <span class="id">beh</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>', <span class="id">program_behaves</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>) <span class="id">beh</span>' -&gt; <span class="id">not_wrong</span> <span class="id">beh</span>') -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>) <span class="id">beh</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5304')">Proof.</div>
<div class="proofscript" id="proof5304">
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">WBT</span>: <span class="kwd">forall</span> <span class="id">p</span>, <span class="id">well_behaved_traces</span> (<span class="id">Cstrategy.semantics</span> <span class="id">p</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">ssr_well_behaved</span>. <span class="tactic">apply</span> <span class="id">Cstrategy.semantics_strongly_receptive</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MATCH</span>: <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">transf_c_program_match</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_behavior_improves</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">proj1</span> (<span class="id">cstrategy_semantic_preservation</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MATCH</span>)).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">backward_simulation_behavior_improves</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">proj2</span> (<span class="id">cstrategy_semantic_preservation</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MATCH</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">beh1</span> [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">beh1</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">atomic_behaviors</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_same_safe_behavior</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">proj1</span> (<span class="id">cstrategy_semantic_preservation</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MATCH</span>)).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">backward_simulation_same_safe_behavior</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">proj2</span> (<span class="id">cstrategy_semantic_preservation</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MATCH</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">atomic_behaviors</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">atomic_behaviors</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">We can also use the alternate big-step semantics for <span class="bracket"><span class="id">Cstrategy</span></span>
  to establish behaviors of the generated assembly code. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">bigstep_cstrategy_preservation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">t</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Cstrategy.bigstep_program_terminates</span> <span class="id">p</span> <span class="id">t</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) (<span class="id">Terminates</span> <span class="id">t</span> <span class="id">r</span>))<br/>
/\(<span class="kwd">forall</span> <span class="id">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Cstrategy.bigstep_program_diverges</span> <span class="id">p</span> <span class="id">T</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) (<span class="id">Reacts</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;\/ <span class="id">exists</span> <span class="id">t</span>, <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">tp</span>) (<span class="id">Diverges</span> <span class="id">t</span>) /\ <span class="id">traceinf_prefix</span> <span class="id">t</span> <span class="id">T</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5305')">Proof.</div>
<div class="proofscript" id="proof5305">
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transf_cstrategy_program_preservation</span> <span class="kwd">with</span> <span class="id">p</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">behavior_bigstep_terminates</span> <span class="kwd">with</span> (<span class="id">Cstrategy.bigstep_semantics</span> <span class="id">p</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Cstrategy.bigstep_semantics_sound</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">behavior_bigstep_diverges</span> (<span class="id">Cstrategy.bigstep_semantics_sound</span> <span class="id">p</span>)). <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">A</span> | [<span class="id">t</span> [<span class="id">A</span> <span class="id">B</span>]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">apply</span> <span class="id">transf_cstrategy_program_preservation</span> <span class="kwd">with</span> <span class="id">p</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="id">exists</span> <span class="id">t</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">transf_cstrategy_program_preservation</span> <span class="kwd">with</span> <span class="id">p</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Satisfaction of specifications </h1>
<br/>
<div class="doc">The second additional results shows that if all executions
  of the source C program satisfies a given specification,
  then all executions of the produced Asm program satisfy
  this specification as well.  </div>
<br/>
<div class="doc">The specifications we consider here are sets of observable
  behaviors, representing the good behaviors a program is expected
  to have.  A specification can be as simple as
  ``the program does not go wrong'' or as precise as
  ``the program prints a prime number then terminates with code 0''.
  As usual in Coq, sets of behaviors are represented as predicates
  <span class="bracket"><span class="id">program_behavior</span> -&gt; <span class="kwd">Prop</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">specification</span> := <span class="id">program_behavior</span> -&gt; <span class="kwd">Prop</span>.<br/>
<br/>
<div class="doc">A program satisfies a specification if all its observable behaviors
  are in the specification. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">c_program_satisfies_spec</span> (<span class="id">p</span>: <span class="id">Csyntax.program</span>) (<span class="id">spec</span>: <span class="id">specification</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>,  <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">spec</span> <span class="id">beh</span>.<br/>
<span class="kwd">Definition</span> <span class="id">asm_program_satisfies_spec</span> (<span class="id">p</span>: <span class="id">Asm.program</span>) (<span class="id">spec</span>: <span class="id">specification</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>,  <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">spec</span> <span class="id">beh</span>.<br/>
&nbsp;&nbsp;<br/>
<div class="doc">It is not always the case that if the source program satisfies a
  specification, then the generated assembly code satisfies it as
  well.  For example, if the specification is ``the program goes wrong
  on an undefined behavior'', a C source that goes wrong satisfies
  this specification but can be compiled into Asm code that does not
  go wrong and therefore does not satisfy the specification.
  For this reason, we restrict ourselves to safety-enforcing specifications:
  specifications that exclude ``going wrong'' behaviors and are satisfied
  only by programs that execute safely. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">safety_enforcing_specification</span> (<span class="id">spec</span>: <span class="id">specification</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">spec</span> <span class="id">beh</span> -&gt; <span class="id">not_wrong</span> <span class="id">beh</span>.<br/>
<br/>
<div class="doc">As the main result of this section, we show that CompCert
  compilation preserves safety-enforcing specifications: 
  any such specification that is satisfied by the source C program is
  always satisfied by the generated assembly code. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_c_program_preserves_spec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">spec</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">safety_enforcing_specification</span> <span class="id">spec</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">c_program_satisfies_spec</span> <span class="id">p</span> <span class="id">spec</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">asm_program_satisfies_spec</span> <span class="id">tp</span> <span class="id">spec</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5306')">Proof.</div>
<div class="proofscript" id="proof5306">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">spec</span> <span class="id">TRANSF</span> <span class="id">SES</span> <span class="id">CSAT</span>; <span class="tactic">red</span>; <span class="tactic">intros</span> <span class="id">beh</span> <span class="id">AEXEC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transf_c_program_preservation</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">beh</span>' &amp; <span class="id">CEXEC</span> &amp; <span class="id">IMPR</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">CSAT</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="tactic">destruct</span> <span class="id">IMPR</span> <span class="kwd">as</span> [<span class="id">EQ</span> | [<span class="id">t</span> [<span class="id">A</span> <span class="id">B</span>]]].<br/>
- <span class="tactic">congruence</span>.<br/>
- <span class="tactic">subst</span> <span class="id">beh</span>'. <span class="tactic">apply</span> <span class="id">SES</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="id">contradiction</span>. <br/>
Qed.</div>
<br/>
<div class="doc">Safety-enforcing specifications are not the only good properties
  of source programs that are preserved by compilation.  Another example
  of a property that is preserved is the ``initial trace'' property:
  all executions of the program start by producing an expected trace
  of I/O actions, representing the good behavior expected from the program.
  After that, the program may terminate, or continue running, or go wrong
  on an undefined behavior.  What matters is that the program produced
  the expected trace at the beginning of its execution.  This is a typical
  liveness property, and it is preserved by compilation. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">c_program_has_initial_trace</span> (<span class="id">p</span>: <span class="id">Csyntax.program</span>) (<span class="id">t</span>: <span class="id">trace</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">behavior_prefix</span> <span class="id">t</span> <span class="id">beh</span>.<br/>
<span class="kwd">Definition</span> <span class="id">asm_program_has_initial_trace</span> (<span class="id">p</span>: <span class="id">Asm.program</span>) (<span class="id">t</span>: <span class="id">trace</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">p</span>) <span class="id">beh</span> -&gt; <span class="id">behavior_prefix</span> <span class="id">t</span> <span class="id">beh</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_c_program_preserves_initial_trace</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">t</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_c_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">c_program_has_initial_trace</span> <span class="id">p</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">asm_program_has_initial_trace</span> <span class="id">tp</span> <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5307')">Proof.</div>
<div class="proofscript" id="proof5307">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">t</span> <span class="id">TRANSF</span> <span class="id">CTRACE</span>; <span class="tactic">red</span>; <span class="tactic">intros</span> <span class="id">beh</span> <span class="id">AEXEC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transf_c_program_preservation</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">beh</span>' &amp; <span class="id">CEXEC</span> &amp; <span class="id">IMPR</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">CTRACE</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="tactic">destruct</span> <span class="id">IMPR</span> <span class="kwd">as</span> [<span class="id">EQ</span> | [<span class="id">t</span>' [<span class="id">A</span> <span class="id">B</span>]]].<br/>
- <span class="tactic">congruence</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">CEXEC</span> <span class="kwd">as</span> (<span class="id">beh1</span>' &amp; <span class="id">EQ</span>').<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">B</span> <span class="kwd">as</span> (<span class="id">beh1</span> &amp; <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">beh</span>'. <span class="tactic">destruct</span> <span class="id">beh1</span>'; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="id">inv</span> <span class="id">A</span>. <br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">behavior_app</span> <span class="id">t0</span> <span class="id">beh1</span>). <span class="tactic">apply</span> <span class="id">behavior_app_assoc</span>.<br/>
Qed.</div>
<br/>
<h1> Extension to separate compilation </h1>
<br/>
<div class="doc">The results above were given in terms of whole-program compilation.
    They also extend to separate compilation followed by linking. </div>
<br/>
<span class="kwd">Section</span> <span class="id">SEPARATE_COMPILATION</span>.<br/>
<br/>
<div class="doc">The source: a list of C compilation units </div>
<span class="kwd">Variable</span> <span class="id">c_units</span>: <span class="id">nlist</span> <span class="id">Csyntax.program</span>.<br/>
<br/>
<div class="doc">The compiled code: a list of Asm compilation units, obtained by separate compilation </div>
<span class="kwd">Variable</span> <span class="id">asm_units</span>: <span class="id">nlist</span> <span class="id">Asm.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">separate_compilation_succeeds</span>: <br/>
&nbsp;&nbsp;<span class="id">nlist_forall2</span> (<span class="kwd">fun</span> <span class="id">cu</span> <span class="id">tcu</span> =&gt; <span class="id">transf_c_program</span> <span class="id">cu</span> = <span class="id">OK</span> <span class="id">tcu</span>) <span class="id">c_units</span> <span class="id">asm_units</span>.<br/>
<br/>
<div class="doc">We assume that the source C compilation units can be linked together
    to obtain a monolithic C program <span class="bracket"><span class="id">c_program</span></span>. </div>
<span class="kwd">Variable</span> <span class="id">c_program</span>: <span class="id">Csyntax.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">source_linking</span>: <span class="id">link_list</span> <span class="id">c_units</span> = <span class="id">Some</span> <span class="id">c_program</span>.<br/>
<br/>
<div class="doc">Then, linking the Asm units obtained by separate compilation succeeds. </div>
<span class="kwd">Lemma</span> <span class="id">compiled_linking_succeeds</span>:<br/>
&nbsp;&nbsp;{ <span class="id">asm_program</span> | <span class="id">link_list</span> <span class="id">asm_units</span> = <span class="id">Some</span> <span class="id">asm_program</span> }.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5308')">Proof.</div>
<div class="proofscript" id="proof5308">
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link_list</span> <span class="id">asm_units</span>) <span class="id">eqn</span>:<span class="id">E</span>. <br/>
- <span class="id">exists</span> <span class="id">p</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">exfalso</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">separate_transf_c_program_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">a</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Let asm_program be the result of linking the Asm units. </div>
<span class="kwd">Let</span> <span class="id">asm_program</span>: <span class="id">Asm.program</span> := <span class="id">proj1_sig</span> <span class="id">compiled_linking_succeeds</span>.<br/>
<span class="kwd">Let</span> <span class="id">compiled_linking</span>: <span class="id">link_list</span> <span class="id">asm_units</span> = <span class="id">Some</span> <span class="id">asm_program</span> := <span class="id">proj2_sig</span> <span class="id">compiled_linking_succeeds</span>.<br/>
<br/>
<div class="doc">Then, <span class="bracket"><span class="id">asm_program</span></span> preserves the semantics and the specifications of
  <span class="bracket"><span class="id">c_program</span></span>, in the following sense.
  First, every behavior of <span class="bracket"><span class="id">asm_program</span></span> improves upon one of the possible
  behaviors of <span class="bracket"><span class="id">c_program</span></span>. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">separate_transf_c_program_preservation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">beh</span>,<br/>
&nbsp;&nbsp;<span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">asm_program</span>) <span class="id">beh</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">beh</span>', <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">c_program</span>) <span class="id">beh</span>' /\ <span class="id">behavior_improves</span> <span class="id">beh</span>' <span class="id">beh</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5309')">Proof.</div>
<div class="proofscript" id="proof5309">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">separate_transf_c_program_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">a</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">a</span> = <span class="id">asm_program</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">a</span>. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">backward_simulation_behavior_improves</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">As a corollary, if <span class="bracket"><span class="id">c_program</span></span> is free of undefined behaviors, 
  the behavior of <span class="bracket"><span class="id">asm_program</span></span> is one of the possible behaviors of <span class="bracket"><span class="id">c_program</span></span>. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">separate_transf_c_program_is_refinement</span>:<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">c_program</span>) <span class="id">beh</span> -&gt; <span class="id">not_wrong</span> <span class="id">beh</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">beh</span>, <span class="id">program_behaves</span> (<span class="id">Asm.semantics</span> <span class="id">asm_program</span>) <span class="id">beh</span> -&gt; <span class="id">program_behaves</span> (<span class="id">Csem.semantics</span> <span class="id">c_program</span>) <span class="id">beh</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5310')">Proof.</div>
<div class="proofscript" id="proof5310">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">separate_transf_c_program_preservation</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">beh</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">not_wrong</span> <span class="id">beh</span>') <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">Q</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> (<span class="id">t</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>). <span class="tactic">subst</span> <span class="id">beh</span>'. <span class="tactic">elim</span> <span class="id">H1</span>. <br/>
Qed.</div>
<br/>
<div class="doc">We now show that if all executions of <span class="bracket"><span class="id">c_program</span></span> satisfy a specification,
  then all executions of <span class="bracket"><span class="id">asm_program</span></span> also satisfy the specification, provided
  the specification is of the safety-enforcing kind. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">separate_transf_c_program_preserves_spec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">spec</span>,<br/>
&nbsp;&nbsp;<span class="id">safety_enforcing_specification</span> <span class="id">spec</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">c_program_satisfies_spec</span> <span class="id">c_program</span> <span class="id">spec</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">asm_program_satisfies_spec</span> <span class="id">asm_program</span> <span class="id">spec</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5311')">Proof.</div>
<div class="proofscript" id="proof5311">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">spec</span> <span class="id">SES</span> <span class="id">CSAT</span>; <span class="tactic">red</span>; <span class="tactic">intros</span> <span class="id">beh</span> <span class="id">AEXEC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">separate_transf_c_program_preservation</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">beh</span>' &amp; <span class="id">CEXEC</span> &amp; <span class="id">IMPR</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">CSAT</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="tactic">destruct</span> <span class="id">IMPR</span> <span class="kwd">as</span> [<span class="id">EQ</span> | [<span class="id">t</span> [<span class="id">A</span> <span class="id">B</span>]]].<br/>
- <span class="tactic">congruence</span>.<br/>
- <span class="tactic">subst</span> <span class="id">beh</span>'. <span class="tactic">apply</span> <span class="id">SES</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="id">contradiction</span>. <br/>
Qed.</div>
<br/>
<div class="doc">As another corollary of <span class="bracket"><span class="id">separate_transf_c_program_preservation</span></span>,
  if all executions of <span class="bracket"><span class="id">c_program</span></span> have a trace <span class="bracket"><span class="id">t</span></span> as initial trace,
  so do all executions of <span class="bracket"><span class="id">asm_program</span></span>. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">separate_transf_c_program_preserves_initial_trace</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>,<br/>
&nbsp;&nbsp;<span class="id">c_program_has_initial_trace</span> <span class="id">c_program</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">asm_program_has_initial_trace</span> <span class="id">asm_program</span> <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5312')">Proof.</div>
<div class="proofscript" id="proof5312">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t</span> <span class="id">CTRACE</span>; <span class="tactic">red</span>; <span class="tactic">intros</span> <span class="id">beh</span> <span class="id">AEXEC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">separate_transf_c_program_preservation</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">beh</span>' &amp; <span class="id">CEXEC</span> &amp; <span class="id">IMPR</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">CTRACE</span> <span class="kwd">in</span> <span class="id">CEXEC</span>. <span class="tactic">destruct</span> <span class="id">IMPR</span> <span class="kwd">as</span> [<span class="id">EQ</span> | [<span class="id">t</span>' [<span class="id">A</span> <span class="id">B</span>]]].<br/>
- <span class="tactic">congruence</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">CEXEC</span> <span class="kwd">as</span> (<span class="id">beh1</span>' &amp; <span class="id">EQ</span>').<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">B</span> <span class="kwd">as</span> (<span class="id">beh1</span> &amp; <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">beh</span>'. <span class="tactic">destruct</span> <span class="id">beh1</span>'; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="id">inv</span> <span class="id">A</span>. <br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">behavior_app</span> <span class="id">t0</span> <span class="id">beh1</span>). <span class="tactic">apply</span> <span class="id">behavior_app_assoc</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SEPARATE_COMPILATION</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</a></div>
</body>
</html>
