39d38
< Context `{external_calls_prf: ExternalCalls}.
==========================================================================================
41,42d39
< Variable fn_stack_requirements: ident -> Z.
< Hypothesis fn_stack_requirements_pos: forall i, 0 <= fn_stack_requirements i.
==========================================================================================
177,201d173
< Lemma volatile_store_push:
<   forall ge chunk m b o v t m',
<       forall (STACK_TOP_NO_INFO: forall b,
<              is_stack_top (Mem.stack m) b ->
<              forall fi,
<                get_frame_info (Mem.stack m) b = Some fi ->
<                forall o, frame_perm fi o = Public),
<     volatile_store ge chunk m b o v t m' ->
<     exists m1,
<       volatile_store ge chunk (Mem.push_new_stage m) b o v t m1 /\ Mem.unrecord_stack_block m1 = Some m'.
< Proof.
<   intros ge0 chunk m b o v t m' STACK_TOP_NO_INFO VS; inv VS.
<   eexists; split. econstructor; eauto. apply Mem.unrecord_push.
<   edestruct (Mem.valid_access_store' (Mem.push_new_stage m) chunk b (Ptrofs.unsigned o) v).
<   exploit Mem.store_valid_access_3. eauto. intros (V1 & V2 & V3).
<   split. red; intros. rewrite Mem.push_new_stage_perm. auto. split; auto.
<   rewrite_stack_blocks. intros. trim V3. auto. red. right.
<   red; simpl. red in V3. destruct V3; simpl in *; eauto.
<   destr. red; intros. eapply STACK_TOP_NO_INFO; eauto.
<   eexists; split.
<   econstructor. auto.
<   eauto.
<   eapply Mem.push_store_unrecord; eauto.
< Qed.
< 
==========================================================================================
761,763c733
<   forall {T1 valid_pointer1} {sem_cast_prf1: SemCast (T := T1) valid_pointer1},
<   forall {T2 valid_pointer2} {sem_cast_prf2: SemCast (T := T2) valid_pointer2},
<   forall v ty ty' (m1: T1) v1 (m2: T2) v2,
---
>   forall v ty ty' m1 v1 m2 v2,
==========================================================================================
771,772c741,742
<   destruct (weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
<   destruct (weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
---
>   destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
>   destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
==========================================================================================
776,777c746,747
<   destruct (weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
<   destruct (weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
---
>   destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
>   destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
==========================================================================================
787,788c757,758
<   destruct (sem_cast v1 (typeof a) ty tt) as [v'|] eqn:C; auto.
<   eapply sem_cast_deterministic with (m1 := tt); eauto.
---
>   destruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto.
>   eapply sem_cast_deterministic; eauto.
==========================================================================================
793c763
<   forall v t m b, bool_val v t tt = Some b -> bool_val v t m = Some b.
---
>   forall v t m b, bool_val v t Mem.empty = Some b -> bool_val v t m = Some b.
==========================================================================================
795c765,771
<   intros; eapply bool_val_unit_to_mem; eauto.
---
>   assert (A: forall b ofs, Mem.weak_valid_pointer Mem.empty b ofs = false).
>   { unfold Mem.weak_valid_pointer, Mem.valid_pointer, proj_sumbool; intros.
>     rewrite ! pred_dec_false by (apply Mem.perm_empty). auto. }  
>   intros until b; unfold bool_val.
>   destruct (classify_bool t); destruct v; destruct Archi.ptr64 eqn:SF; auto.
> - rewrite A; congruence.
> - simpl; rewrite A; congruence.
==========================================================================================
802c778
<   star (step1 fn_stack_requirements) tge (State f (makeif a s1 s2) k e le m)
---
>   star step1 tge (State f (makeif a s1 s2) k e le m)
==========================================================================================
821c797
<   (step1 fn_stack_requirements) tge (State f (make_set id a) k e le m)
---
>   step1 tge (State f (make_set id a) k e le m)
==========================================================================================
830,832c806
<   simpl. econstructor; eauto. inv H2; constructor; auto.
<   rewrite Mem.push_new_stage_load. auto. apply Mem.unrecord_push.
<   auto.
---
>   simpl. econstructor; eauto.
==========================================================================================
839,843d812
<       forall (STACK_TOP_NO_INFO: forall b,
<              is_stack_top (Mem.stack m) b ->
<              forall fi,
<                get_frame_info (Mem.stack m) b = Some fi ->
<                forall o, frame_perm fi o = Public),
==========================================================================================
849c818
<   (step1 fn_stack_requirements) tge (State f (make_assign a1 a2) k e le m)
---
>   step1 tge (State f (make_assign a1 a2) k e le m)
==========================================================================================
855,857c824
<   intros. change le with (set_opttemp None Vundef le) at 2.
<   edestruct volatile_store_push as (m1 & VS & USB). eauto. eauto.
<   econstructor.
---
>   intros. change le with (set_opttemp None Vundef le) at 2. econstructor.
==========================================================================================
861c828
<   simpl. econstructor; eauto. eauto. auto.
---
>   simpl. econstructor; eauto.
==========================================================================================
881c848
<   star (step1 fn_stack_requirements) tge (State f (makeseq sl) k e le m)
---
>   star step1 tge (State f (makeseq sl) k e le m)
==========================================================================================
897c864
<     star (step1 fn_stack_requirements) tge (State f Sskip (Kseqlist sl k) e le m)
---
>     star step1 tge (State f Sskip (Kseqlist sl k) e le m)
==========================================================================================
s1023,1038d989
< Fixpoint nostackinfo (adt: stack) (k: cont) : Prop :=
<   match k with
<     Kstop => True
<   | Kseq _ k
<   | Kloop1 _ _ k | Kloop2 _ _ k
<   | Kswitch k => nostackinfo adt k
<   | Kcall oi f e te k =>
<     match adt with
<     | (f,_)::r => nostackinfo r k /\
<                  forall a,
<                    f = Some a ->
<                    Forall (fun bfi => forall o, frame_perm (snd bfi) o = Public) (frame_adt_blocks a)
<     | _ => False
<     end
<   end.
< 
==========================================================================================
1044d994
<       nostackinfo (Mem.stack m) (Kcall None tf e le tk) ->
==========================================================================================
1051d1000
<       nostackinfo (Mem.stack m) (Kcall None tf e le tk) ->
==========================================================================================
1054c1003
<   | match_callstates: forall fd args k m tfd tk sz (SZpos: 0 <= sz),
---
>   | match_callstates: forall fd args k m tfd tk,
==========================================================================================
1057,1060c1006,1007
<       top_tframe_tc (Mem.stack m) ->
<       nostackinfo (tl (Mem.stack m)) tk ->
<       match_states (Csem.Callstate fd args k m sz)
<                    (Callstate tfd args tk m sz)
---
>       match_states (Csem.Callstate fd args k m)
>                    (Callstate tfd args tk m)
==========================================================================================
1063d1009
<       nostackinfo (tl (Mem.stack m)) tk ->
==========================================================================================
1429,1434c1375,1379
<     typeof a = ty ->
<     (forall `{memory_model_ops: Mem.MemoryModelOps},
<         forall tge e le' m,
<           (forall id, In id tmp -> le'!id = le!id) ->
<           eval_expr tge e le' m a v) ->
<     tr_expr le dst (Csyntax.Eval v ty) (final dst a) a tmp.
---
>   typeof a = ty ->
>   (forall tge e le' m,
>       (forall id, In id tmp -> le'!id = le!id) ->
>       eval_expr tge e le' m a v) ->
>   tr_expr le dst (Csyntax.Eval v ty) (final dst a) a tmp.
==========================================================================================
1439,1490d1383
< Lemma nostackinfo_public:
<   forall m oi tf e le tk,
<     nostackinfo (Mem.stack m) (Kcall oi tf e le tk) ->
<     forall b,
<       is_stack_top (Mem.stack m) b ->
<       forall fi : frame_info, get_frame_info (Mem.stack m) b = Some fi -> forall o : Z, frame_perm fi o = Public.
< Proof.
<   intros m oi tf e le tk NSI b IST fi GFI o.
<   simpl in NSI. destr_in NSI. unfold is_stack_top, get_frames_blocks in IST.
<   simpl in *. intros.
<   destruct t; simpl in *.
<   destruct NSI as [_ F].
<   unfold get_frames_blocks in IST. simpl in IST.
<   destruct o0; try easy. simpl in *.
<   specialize (F _ eq_refl).
<   destr_in GFI. edestruct get_assoc_tframes_in as (ff & INFl & INblocks); eauto.
<   rewrite Forall_forall in F. simpl in INFl. inv INFl.
<   specialize (F _ INblocks).
<   eapply F; eauto.
<   exfalso; apply n. apply IST.
< Qed.
< 
< Lemma assign_loc_nostackinfo:
<   forall ge t m b o v t' m',
<     Csem.assign_loc ge t m b o v t' m' ->
<     forall tk oi tf e le oi' tf' e' le',
<       nostackinfo (Mem.stack m) (Kcall oi tf e le tk) ->
<       nostackinfo (Mem.stack m' ) (Kcall oi' tf' e' le' tk).
< Proof.
<   intros ge0 t m b o v t' m' AL tk oi tf e le oi' tf' e' le' NSI.
<   inv AL. rewrite_stack_blocks. simpl in *; auto.
<   inv H1. simpl in *; auto.
<   rewrite_stack_blocks; auto.
<   rewrite_stack_blocks; auto.
< Qed.
< 
< Lemma nostackinfo_kseqlist:
<   forall s ts tk,
<     nostackinfo s tk ->
<     nostackinfo s (Kseqlist ts tk).
< Proof.
<   induction ts; simpl; intros; eauto.
< Qed.
< 
< Lemma nostackinfo_kseqlist' :
<   forall s ts tk,
<     nostackinfo s (Kseqlist ts tk) ->
<     nostackinfo s tk.
< Proof.
<   induction ts; simpl; intros; eauto.
< Qed.
< 
==========================================================================================
1492c1385
<   forall S1 t S2, Cstrategy.estep fn_stack_requirements ge S1 t S2 ->
---
>   forall S1 t S2, Cstrategy.estep ge S1 t S2 ->
==========================================================================================
1495,1496c1388,1389
<      (plus (step1 fn_stack_requirements) tge S1' t S2' \/
<        (star (step1 fn_stack_requirements) tge S1' t S2' /\ measure S2 < measure S1)%nat)
---
>      (plus step1 tge S1' t S2' \/
>        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
==========================================================================================
1710c1603
<   auto. auto. auto.
---
>   auto. auto.
==========================================================================================
1720c1613
<   auto. auto. auto.
---
>   auto. auto.
==========================================================================================
1733c1626
<   auto. auto. auto.
---
>   auto. auto.
==========================================================================================
1743c1636
<   auto. auto. auto.
---
>   auto. auto.
==========================================================================================
1755d1647
<   eapply nostackinfo_public; eauto.
==========================================================================================
1759d1650
<   eapply assign_loc_nostackinfo; eauto.
==========================================================================================
1772d1662
<   eapply nostackinfo_public; eauto.
==========================================================================================
1780d1669
<   eapply assign_loc_nostackinfo; eauto.
==========================================================================================
1796d1684
<   eapply nostackinfo_public; eauto.
==========================================================================================
1802d1689
<   eapply assign_loc_nostackinfo; eauto.
==========================================================================================
1822c1709
<   econstructor. eapply step_make_assign; eauto using nostackinfo_public.
---
>   econstructor. eapply step_make_assign; eauto.
==========================================================================================
1831c1718
<   auto. auto. eapply assign_loc_nostackinfo; eauto.
---
>   auto. auto.
==========================================================================================
1868c1755
<   eapply step_make_assign; eauto using nostackinfo_public.
---
>   eapply step_make_assign; eauto.
==========================================================================================
1875c1762
<   constructor. auto. auto. auto. eapply assign_loc_nostackinfo; eauto.
---
>   constructor. auto. auto. auto.
==========================================================================================
1887c1774
<   eapply step_make_assign; eauto using nostackinfo_public.
---
>   eapply step_make_assign; eauto.
==========================================================================================
1899c1786
<   auto. auto. eapply assign_loc_nostackinfo; eauto.
---
>   auto. auto.
==========================================================================================
1976,1982c1863
<   econstructor; eauto.
<   {
<     destruct IFI as (bb & oo & IFI & IFI'); subst.
<     eexists; eexists; split; eauto.
<     rewrite symbols_preserved; eauto.
<   }
<   rewrite <- TY1; eauto.
---
>   econstructor; eauto. rewrite <- TY1; eauto.
==========================================================================================
1987,1989c1868
<   constructor. auto. auto. rewrite_stack_blocks. constructor; reflexivity.
<   rewrite_stack_blocks. simpl tl. simpl in *; auto. destr_in H14. destruct t; simpl in *. destruct H14; split; auto.
<   apply nostackinfo_kseqlist; auto.
---
>   constructor. auto. auto.
==========================================================================================
1997,2003c1876
<   econstructor; eauto.
<   {
<     destruct IFI as (bb & oo & IFI & IFI'); subst.
<     eexists; eexists; split; eauto.
<     rewrite symbols_preserved; eauto.
<   }
<   rewrite <- TY1; eauto.
---
>   econstructor; eauto. rewrite <- TY1; eauto.
==========================================================================================
2013,2015d1885
<   rewrite_stack_blocks; auto. constructor; reflexivity.
<   rewrite_stack_blocks; simpl in *; auto. repeat destr_in H14. split; auto.
<   apply nostackinfo_kseqlist. auto.
==========================================================================================
2018c1888
<   exploit tr_top_leftcontext; eauto. clear H10.
---
>   exploit tr_top_leftcontext; eauto. clear H9.
==========================================================================================
2020c1890
<   inv P. inv H3.
---
>   inv P. inv H2.
==========================================================================================
2031d1900
<   repeat rewrite_stack_blocks. simpl tl. simpl in *; auto.
==========================================================================================
2042c1911
<   apply tr_val_gen. auto. intros. constructor. rewrite H3; auto. simpl. apply PTree.gss.
---
>   apply tr_val_gen. auto. intros. constructor. rewrite H2; auto. simpl. apply PTree.gss.
==========================================================================================
2044c1913
<   auto. repeat rewrite_stack_blocks. simpl in *; auto.
---
>   auto.
==========================================================================================
2084,2138d1952
< Lemma nostackinfo_callcont:
<   forall s k,
<     nostackinfo s k ->
<     nostackinfo s (call_cont k).
< Proof.
<   induction k; simpl; intros; auto.
< Qed.
< 
< 
< Lemma nostackinfo_find_label:
<   forall lbl ss s tk ts' tk'
<     (FL: find_label lbl ss tk = Some (ts', tk'))
<     (NSI : nostackinfo s tk),
<     nostackinfo s tk'
< with nostackinfo_find_label_ls:
<        forall lbl ss s tk ts' tk'
<          (FL: find_label_ls lbl ss tk = Some (ts', tk'))
<          (NSI : nostackinfo s tk),
<          nostackinfo s tk'
< .
< Proof.
<   - destruct ss; simpl; intros; eauto; try congruence;
<       repeat destr_in FL; eauto.
<   - destruct ss; simpl; intros; eauto; try congruence;
<       repeat destr_in FL; eauto.
< Qed.
< 
< Lemma assign_loc_stack:
<   forall ge t m b o v t' m',
<     Csem.assign_loc ge t m b o v t' m' ->
<     Mem.stack m' = Mem.stack m.
< Proof.
<   intros ge0 t m b o v t' m' AL.
<   inv AL; repeat rewrite_stack_blocks; auto.
<   inv H1; repeat rewrite_stack_blocks; auto.
< Qed.
< 
< Lemma bind_parameters_stack:
<   forall ge e m1 pars vargs m2,
<     Csem.bind_parameters ge e m1 pars vargs m2 ->
<     Mem.stack m2 = Mem.stack m1.
< Proof.
<   induction 1; simpl; intros; eauto.
<   eapply assign_loc_stack in H0; eauto. congruence.
< Qed.
< 
< Lemma alloc_variables_stack:
<   forall ge e m1 vars e2 m2,
<     Csem.alloc_variables ge e m1 vars e2 m2 ->
<     Mem.stack m2 = Mem.stack m1.
< Proof.
<   induction 1; simpl; intros; eauto.
<   rewrite IHalloc_variables. rewrite_stack_blocks. auto.
< Qed.
< 
==========================================================================================
2143,2144c1957,1958
<      (plus (step1 fn_stack_requirements) tge S1' t S2' \/
<        (star (step1 fn_stack_requirements) tge S1' t S2' /\ measure S2 < measure S1)%nat)
---
>      (plus step1 tge S1' t S2' \/
>        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
==========================================================================================
2187c2001
<   apply step_ifthenelse with (v1 := v) (b0 := b); auto. traceEq.
---
>   apply step_ifthenelse with (v1 := v) (b := b); auto. traceEq.
==========================================================================================
2316d2129
<   rewrite_stack_blocks. simpl in H9; repeat destr_in H9. simpl. eauto using nostackinfo_callcont.
==========================================================================================
2328d2140
<   rewrite_stack_blocks. simpl in H10; repeat destr_in H10. simpl. eauto using nostackinfo_callcont.
==========================================================================================
2333c2145
<   left. apply plus_one. eapply step_skip_call; eauto. rewrite blocks_of_env_preserved; eauto.
---
>   left. apply plus_one. apply step_skip_call; eauto. rewrite blocks_of_env_preserved; eauto.
==========================================================================================
2335d2146
<   rewrite_stack_blocks. simpl in H10; repeat destr_in H10. simpl. eauto using nostackinfo_callcont.
==========================================================================================
2377,2379d2187
<   simpl in *. repeat destr_in H9. split; auto.
<   eapply nostackinfo_find_label; eauto using nostackinfo_callcont.
< 
==========================================================================================
2382c2190
<   inv H11. inversion H6; subst.
---
>   inv H7. inversion H3; subst.
==========================================================================================
2385,2390c2193,2195
<   rewrite H9, H10; auto.
<   rewrite H9, H10. eapply alloc_variables_preserved; eauto.
<   unfold blocks_with_info. rewrite blocks_of_env_preserved. eauto.
<   rewrite H2. apply Z.max_r. auto.
<   eauto.
<   rewrite H9. eapply bind_parameters_preserved; eauto.
---
>   rewrite H6; rewrite H7; auto.
>   rewrite H6; rewrite H7. eapply alloc_variables_preserved; eauto.
>   rewrite H6. eapply bind_parameters_preserved; eauto.
==========================================================================================
2393,2399d2197
<   erewrite bind_parameters_stack; eauto. rewrite_stack_blocks.
<   erewrite alloc_variables_stack; eauto. intro EQ1.
<   rewrite EQ1 in H14. simpl in H14.
<   simpl. split; auto.
<   rewrite EQ1 in H13; inv H13. intros a A; inv A. rewrite H1.
<   rewrite Forall_forall; setoid_rewrite in_map_iff.
<   intros (b & fi) (blohi & EQ & IN). repeat destr_in EQ. reflexivity.
==========================================================================================
2402c2200
<   inv H6.
---
>   inv H5.
==========================================================================================
2407d2204
<   rewrite_stack_blocks. auto.
==========================================================================================
2410c2207
<   inv H4.
---
>   inv H3.
==========================================================================================
2412c2209
<   left; apply plus_one. constructor. eauto.
---
>   left; apply plus_one. constructor.
==========================================================================================
2414,2416d2210
<   rewrite_stack_blocks. simpl in *; auto.
<   destr_in H5; auto. destr. destruct H5; split; auto.
<   eapply nostackinfo_kseqlist'; eauto.
==========================================================================================
2422c2216
<   forall S1 t S2, Cstrategy.step fn_stack_requirements ge S1 t S2 ->
---
>   forall S1 t S2, Cstrategy.step ge S1 t S2 ->
==========================================================================================
2425,2426c2219,2220
<      (plus (step1 fn_stack_requirements) tge S1' t S2' \/
<        (star (step1 fn_stack_requirements) tge S1' t S2' /\ measure S2 < measure S1)%nat)
---
>      (plus step1 tge S1' t S2' \/
>        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
==========================================================================================
2436,2437c2230,2231
<   Csem.initial_state fn_stack_requirements prog S ->
<   exists S', Clight.initial_state fn_stack_requirements tprog S' /\ match_states S S'.
---
>   Csem.initial_state prog S ->
>   exists S', Clight.initial_state tprog S' /\ match_states S S'.
==========================================================================================
2449,2453c2243
<   eauto. eauto.
<   destruct TRANSL as ((_ & MAIN & _) & _).
<   setoid_rewrite MAIN. constructor. auto. auto. constructor.
<   rewrite_stack_blocks. constructor; reflexivity.
<   constructor.
---
>   constructor. auto. constructor.
==========================================================================================
2464c2254
<   forward_simulation (Cstrategy.semantics fn_stack_requirements prog) (Clight.semantics1 fn_stack_requirements tprog).
---
>   forward_simulation (Cstrategy.semantics prog) (Clight.semantics1 tprog).
