24,58d23
< 
< (** The following property is needed by Unusedglobproof, to prove
<     injection between the initial memory states. *)
< Module Mem.
< Export Memtype.Mem.
< 
< Class MemoryModelX (mem: Type) `{memory_model_prf: MemoryModel mem}: Prop :=
< {
<  zero_delta_inject f g m1 m2 {injperm: InjectPerm}:
<   (forall b1 b2 delta, f b1 = Some (b2, delta) -> delta = 0) ->
<   (forall b1 b2, f b1 = Some (b2, 0) -> valid_block m1 b1 /\ valid_block m2 b2) ->
<   (forall b1 p, f b1 = Some p -> forall b2, f b2 = Some p -> b1 = b2) ->
<   (forall b1 b2,
<      f b1 = Some (b2, 0) ->
<      forall o k p,
<        perm m1 b1 o k p ->
<        perm m2 b2 o k p) ->
<   (forall b1 b2,
<      f b1 = Some (b2, 0) ->
<      forall o k p,
<        perm m2 b2 o k p ->
<        perm m1 b1 o k p \/ ~ perm m1 b1 o Max Nonempty) ->
<   (forall b1 b2,
<      f b1 = Some (b2, 0) ->
<      forall o v1,
<        loadbytes m1 b1 o 1 = Some (v1 :: nil) ->
<        exists v2,
<          loadbytes m2 b2 o 1 = Some (v2 :: nil) /\
<          memval_inject f v1 v2) ->
<   stack_inject f g (perm m1) (stack m1) (stack m2) ->
<   inject f g m1 m2
< }.
< 
< End Mem.
< 
==========================================================================================
70c35
<   match_prog_option_def:
---
>   match_prog_def:
==========================================================================================
72c37
<        (prog_option_defmap tp)!id = if IS.mem id u then (prog_option_defmap p)!id else None;
---
>        (prog_defmap tp)!id = if IS.mem id u then (prog_defmap p)!id else None;
==========================================================================================
77,100d41
< Lemma match_prog_def u p tp:
<   match_prog_1 u p tp ->
<   forall id,
<     (prog_defmap tp)!id = if IS.mem id u then (prog_defmap p)!id else None.
< Proof.
<   intros.
<   destruct ((prog_defmap tp) ! id) eqn:TP.
<   {
<     apply prog_defmap_option_defmap in TP.
<     erewrite match_prog_option_def in TP by eassumption.
<     destruct (IS.mem id u); try discriminate.
<     apply prog_defmap_option_defmap in TP.
<     auto.
<   }
<   destruct (IS.mem id u) eqn:MEM; auto.
<   destruct ((prog_defmap p) ! id) eqn:P; auto.
<   apply prog_defmap_option_defmap in P.
<   generalize (match_prog_option_def _ _ _ H id).
<   rewrite MEM.
<   rewrite P.
<   rewrite prog_defmap_option_defmap.
<   congruence.
< Qed.
< 
==========================================================================================
127,128c68,69
<   used_defined_strong: forall id,
<     IS.In id u -> (prog_defmap p)!id <> None \/ id = p.(prog_main)
---
>   used_defined: forall id,
>     IS.In id u -> In id (prog_defs_names p) \/ id = p.(prog_main)
==========================================================================================
131,144d71
< Lemma used_defined p u (VALID: valid_used_set p u):
<   forall id,
<     IS.In id u -> In id (prog_defs_names p) \/ id = p.(prog_main).
< Proof.
<   intros id H.
<   eapply used_defined_strong in H; eauto.
<   destruct H; auto.
<   destruct ((prog_defmap p) ! id) eqn:EQ; try congruence.
<   apply prog_defmap_option_defmap in EQ.
<   apply in_prog_option_defmap in EQ.
<   apply (in_map fst) in EQ.
<   auto.
< Qed.
< 
==========================================================================================
224c151
<   destruct (pm!id) as [ [[[] | ? ] | ] | ] .
---
>   destruct (pm!id) as [[[] | ? ] | ].
==========================================================================================
229d155
<   apply workset_incl_refl.
==========================================================================================
279c205
<   pm!id = Some (Some gd) -> ref_def gd id' -> IS.In id' (add_ref_definition pm id w).
---
>   pm!id = Some gd -> ref_def gd id' -> IS.In id' (add_ref_definition pm id w).
==========================================================================================
328c254
< Let pm := prog_option_defmap p.
---
> Let pm := prog_defmap p.
==========================================================================================
332c258
<   IS.In id w -> ~List.In id (w_todo w) -> pm!id = Some (Some gd) -> ref_def gd id' ->
---
>   IS.In id w -> ~List.In id (w_todo w) -> pm!id = Some gd -> ref_def gd id' ->
==========================================================================================
337c263
<   IS.In id u -> pm!id = Some (Some gd) -> ref_def gd id' -> IS.In id' u.
---
>   IS.In id u -> pm!id = Some gd -> ref_def gd id' -> IS.In id' u.
==========================================================================================
392,393c318
< - intros. eapply used_globals_sound; eauto.
<   apply prog_defmap_option_defmap. assumption.
---
> - intros. eapply used_globals_sound; eauto. 
==========================================================================================
398,400c323,324
<   destruct pm!id as [[g|]|] eqn:E.
< * apply prog_defmap_option_defmap in E. intuition congruence.
< * InvBooleans; auto.
---
>   destruct pm!id as [g|] eqn:E.
> * left. change id with (fst (id,g)). apply in_map. apply in_prog_defmap; auto.
==========================================================================================
443,444c367
<   unfold add_def at 1. simpl.
<   rewrite PTree.gso by congruence. eapply IHl; eauto.
---
>   unfold add_def at 1. simpl. rewrite PTree.gso by congruence. eapply IHl; eauto.
==========================================================================================
464,465c387
< + unfold add_def at 2. simpl.
<   rewrite PTree.gso by congruence. apply IHl; auto.
---
> + unfold add_def at 2. simpl. rewrite PTree.gso by congruence. apply IHl; auto.
==========================================================================================
511c433
<   unfold transform_program; intros p tp TR. set (pm := prog_option_defmap p) in *.
---
>   unfold transform_program; intros p tp TR. set (pm := prog_defmap p) in *.
==========================================================================================
517c439
<   intros. unfold prog_option_defmap; simpl. apply filter_globdefs_map.
---
>   intros. unfold prog_defmap; simpl. apply filter_globdefs_map.
==========================================================================================
523,530d444
< Section WITHEXTERNALCALLS.
< Local Existing Instance symbols_inject_instance.
< Existing Instance inject_perm_all.
< Context `{external_calls_prf: ExternalCalls (symbols_inject_instance := symbols_inject_instance)}.
< Context `{memory_model_x_prf: !Mem.MemoryModelX mem}.
< 
< Variable fn_stack_requirements: ident -> Z.
< 
==========================================================================================
570,571c484,485
<   assert (A: exists g, (prog_option_defmap p)!id = Some g).
<   { apply prog_option_defmap_dom. eapply Genv.find_symbol_inversion; eauto. }
---
>   assert (A: exists g, (prog_defmap p)!id = Some g).
>   { apply prog_defmap_dom. eapply Genv.find_symbol_inversion; eauto. }
==========================================================================================
574,575c488,489
<   apply in_prog_option_defmap.
<   erewrite match_prog_option_def by eauto. rewrite IS.mem_1 by auto. auto.
---
>   apply in_prog_defmap.
>   erewrite match_prog_def by eauto. rewrite IS.mem_1 by auto. auto.
==========================================================================================
583,584c497,498
<   assert (A: exists g, (prog_option_defmap tp)!id = Some g).
<   { apply prog_option_defmap_dom. eapply Genv.find_symbol_inversion; eauto. }
---
>   assert (A: exists g, (prog_defmap tp)!id = Some g).
>   { apply prog_defmap_dom. eapply Genv.find_symbol_inversion; eauto. }
==========================================================================================
586c500
<   erewrite match_prog_option_def in P by eauto.
---
>   erewrite match_prog_def in P by eauto. 
==========================================================================================
590c504
<   apply in_prog_option_defmap. auto.
---
>   apply in_prog_defmap. auto.
==========================================================================================
842c756
<   | match_states_regular: forall s f sp pc rs m ts tsp trs tm j 
---
>   | match_states_regular: forall s f sp pc rs m ts tsp trs tm j
==========================================================================================
847c761
<          (MEMINJ: Mem.inject j (flat_frameinj (length (Mem.stack m))) m tm),
---
>          (MEMINJ: Mem.inject j m tm),
==========================================================================================
850c764
<   | match_states_call: forall s fd args m ts targs tm j sz
---
>   | match_states_call: forall s fd args m ts targs tm j
==========================================================================================
854,857c768,771
<          (MEMINJ: Mem.inject j (flat_frameinj (length (Mem.stack m))) m tm),
<       match_states (Callstate s fd args m sz)
<                    (Callstate ts fd targs tm sz)
<   | match_states_return: forall s res m ts tres tm j 
---
>          (MEMINJ: Mem.inject j m tm),
>       match_states (Callstate s fd args m)
>                    (Callstate ts fd targs tm)
>   | match_states_return: forall s res m ts tres tm j
==========================================================================================
860c774
<          (MEMINJ: Mem.inject j (flat_frameinj (length (Mem.stack m))) m tm),
---
>          (MEMINJ: Mem.inject j m tm),
==========================================================================================
863a778,796
> Lemma external_call_inject:
>   forall ef vargs m1 t vres m2 f m1' vargs',
>   meminj_preserves_globals f ->
>   external_call ef ge vargs m1 t vres m2 ->
>   Mem.inject f m1 m1' ->
>   Val.inject_list f vargs vargs' ->
>   exists f', exists vres', exists m2',
>     external_call ef tge vargs' m1' t vres' m2'
>     /\ Val.inject f' vres vres'
>     /\ Mem.inject f' m2 m2'
>     /\ Mem.unchanged_on (loc_unmapped f) m1 m2
>     /\ Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'
>     /\ inject_incr f f'
>     /\ inject_separated f f' m1 m1'.
> Proof.
>   intros. eapply external_call_mem_inject_gen; eauto.
>   apply globals_symbols_inject; auto.
> Qed.
> 
==========================================================================================
887,932d819
< Lemma stack_equiv_inv_step:
<   forall S1 t S2
<     (STEP: step fn_stack_requirements ge S1 t S2)
<     S1' (MS: match_states S1 S1')
<     S2' (STEP': step fn_stack_requirements tge S1' t S2')
<     (SEI: stack_equiv_inv S1 S1'),
<     stack_equiv_inv S2 S2'.
< Proof.
<   intros.
<   inv STEP; inv MS; inv STEP'; try congruence;
<     unfold stack_equiv_inv in *; simpl in *; repeat rewrite_stack_blocks; eauto using stack_equiv_tail.
<   - rewrite H in H8; inv H8.
<     edestruct find_function_inject as (FFT & KEPT').
<     eapply match_stacks_preserves_globals; eauto.
<     eauto. destr. eapply REGINJ.
<     apply KEPT. red. exists pc. setoid_rewrite H. eexists; split; eauto. simpl. auto.
<     rewrite FFT in H9; inv H9.
<     repeat constructor; auto.
<   - rewrite <- EQ0, <- EQ2.
<     intros; eapply Mem.tailcall_stage_stack_equiv; eauto.
<     repeat rewrite_stack_blocks. eauto.
<   - intros A B; rewrite A , B in SEI. 
<     inv SEI; constructor; auto.
<     constructor; auto.
<     simpl. reflexivity. simpl. destruct LF2. auto.
< Qed.
< 
< Lemma external_call_inject:
<   forall ef vargs m1 t vres m2 f g m1' vargs',
<   meminj_preserves_globals f ->
<   external_call ef ge vargs m1 t vres m2 ->
<   Mem.inject f g m1 m1' ->
<   Val.inject_list f vargs vargs' ->
<   exists f', exists vres', exists m2',
<     external_call ef tge vargs' m1' t vres' m2'
<     /\ Val.inject f' vres vres'
<     /\ Mem.inject f' g m2 m2'
<     /\ Mem.unchanged_on (loc_unmapped f) m1 m2
<     /\ Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'
<     /\ inject_incr f f'
<     /\ inject_separated f f' m1 m1'.
< Proof.
<   intros. eapply external_call_mem_inject_gen; eauto.
<   apply globals_symbols_inject; auto.
< Qed.
< 
==========================================================================================
934c821
<   forall rs sp m j g rs' sp' m' a v,
---
>   forall rs sp m j rs' sp' m' a v,
==========================================================================================
939c826
<   Mem.inject j g m m' ->
---
>   Mem.inject j m m' ->
==========================================================================================
972c859
<   forall rs sp m j g rs' sp' m' al vl,
---
>   forall rs sp m j rs' sp' m' al vl,
==========================================================================================
977c864
<   Mem.inject j g m m' ->
---
>   Mem.inject j m m' ->
==========================================================================================
991,1004d877
< Lemma ros_is_function_translated:
<   forall j ros rs trs i s cs b1 b2,
<     ros_is_function ge ros rs i ->
<     match_stacks j s cs b1 b2 ->
<     regset_inject j rs trs ->
<     ros_is_function tge ros trs i.
< Proof.
<   destruct ros; simpl; intros; auto.
<   destruct H as (b & o & PTR & FS).
<   exploit H1. rewrite PTR. intro A; inv A. eexists; eexists; split; eauto.
<   exploit symbols_inject_1.
<   eapply match_stacks_preserves_globals; eauto. eauto. eauto. intuition.
< Qed.
< 
==========================================================================================
1006,1012c879,881
<   forall S1 t S2, step fn_stack_requirements ge S1 t S2 ->
<              forall S1' (MS: match_states S1 S1')
<                (* (SI1: stack_inv S1) *)
<                (SI2: stack_inv S1')
<                (STRUCT: stack_equiv_inv S1 S1')
<              ,
<   exists S2', step fn_stack_requirements tge S1' t S2' /\ match_states S2 S2'.
---
>   forall S1 t S2, step ge S1 t S2 ->
>   forall S1' (MS: match_states S1 S1'),
>   exists S2', step tge S1' t S2' /\ match_states S2 S2'.
==========================================================================================
1014c883
<   induction 1; intros; inv MS; (* inv SI1; *) inv SI2; red in STRUCT; simpl in STRUCT.
---
>   induction 1; intros; inv MS.
==========================================================================================
1068,1069c937
<   erewrite Mem.storev_stack; eauto.
<     
---
> 
==========================================================================================
1073c941
<   destruct ros as [r|id0]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
---
>   destruct ros as [r|id]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
==========================================================================================
1076d943
<   eapply ros_is_function_translated; eauto.
==========================================================================================
1078d944
<   rewrite ! Mem.push_new_stage_nextblock.
==========================================================================================
1080c946
<   change (Mem.valid_block m sp0); eapply Mem.valid_block_inject_1; eauto.
---
>   change (Mem.valid_block m sp0). eapply Mem.valid_block_inject_1; eauto.
==========================================================================================
1083,1084c949
<   apply Mem.push_new_stage_inject_flat. eauto.
<   
---
> 
==========================================================================================
1088c953
<   destruct ros as [r|id0]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
---
>   destruct ros as [r|id]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
==========================================================================================
1090,1098c955
<   exploit Mem.free_parallel_inject; eauto. constructor. rewrite ! Zplus_0_r. intros (tm' & C & D).
<   erewrite <- Mem.free_stack_blocks in D by eauto.
<   destruct (Mem.tailcall_stage_inject_flat _ _ _ _ D H3) as (tm'' & E & F).
<   {
<     red. rewrite_stack_blocks. inv MSA1. constructor.
<     unfold in_frames; simpl. unfold get_frame_blocks; rewrite BLOCKS. simpl.
<     intros b [[]|[]].
<     eapply Mem.free_no_perm_stack'; eauto.
<   }
---
>   exploit Mem.free_parallel_inject; eauto. rewrite ! Zplus_0_r. intros (tm' & C & D).
==========================================================================================
1101d957
<   eapply ros_is_function_translated; eauto.
1103,1109c959,965
<   + apply match_stacks_bound with stk tsp; eauto.
<     * erewrite Mem.tailcall_stage_nextblock; eauto.
<       apply Plt_Ple. change (Mem.valid_block m' stk). eapply Mem.valid_block_inject_1; eauto.
<     * erewrite Mem.tailcall_stage_nextblock; eauto.
<       apply Plt_Ple. change (Mem.valid_block tm' tsp). eapply Mem.valid_block_inject_2; eauto.
<   + apply regs_inject; auto.
<   
---
>   apply match_stacks_bound with stk tsp; auto.
>   apply Plt_Ple.
>   change (Mem.valid_block m' stk). eapply Mem.valid_block_inject_1; eauto.
>   apply Plt_Ple.
>   change (Mem.valid_block tm' tsp). eapply Mem.valid_block_inject_2; eauto.
>   apply regs_inject; auto.
> 
==========================================================================================
1117d972
<   apply Mem.push_new_stage_inject_flat. eauto.
==========================================================================================
1119,1121d973
<   erewrite external_call_stack_blocks in C. 2: eauto.
<   edestruct Mem.unrecord_stack_block_inject_parallel_flat as (m2' & USB & INJ').
<   apply C. eauto.
==========================================================================================
1129c981
<   unfold Mem.valid_block in *. rewrite Mem.push_new_stage_nextblock in U, V. xomega.
---
>   unfold Mem.valid_block in *; xomega.
==========================================================================================
1131c983
<     
---
> 
==========================================================================================
1146c998
<   exploit Mem.free_parallel_inject; eauto. constructor. rewrite ! Zplus_0_r. intros (tm' & C & D).
---
>   exploit Mem.free_parallel_inject; eauto. rewrite ! Zplus_0_r. intros (tm' & C & D).
==========================================================================================
1150c1002
<   apply match_stacks_bound with stk tsp; eauto.
---
>   apply match_stacks_bound with stk tsp; auto.
==========================================================================================
1156d1007
<   rewrite_stack_blocks; auto.
==========================================================================================
1167,1171c1018,1019
<     subst b1. rewrite F in H2; inv H2. split; apply Ple_refl.
<     rewrite G in H2 by auto. congruence. }
<   
<   edestruct (Mem.record_push_inject_flat_alloc m tm m' tm') as (m2' & RSB & INJ'); eauto.
<   simpl. repeat rewrite_stack_blocks. apply Z.eq_le_incl. eauto using stack_equiv_fsize, stack_equiv_tail.
---
>     subst b1. rewrite F in H1; inv H1. split; apply Ple_refl.
>     rewrite G in H1 by auto. congruence. }
==========================================================================================
1176c1024
<     
---
> 
==========================================================================================
1188,1190c1036,1037
<   eapply Ple_trans. eapply external_call_nextblock; eauto. xomega.
<   eapply Ple_trans. eapply external_call_nextblock; eauto. xomega.
<   rewrite_stack_blocks; auto.
---
>   eapply external_call_nextblock; eauto.
>   eapply external_call_nextblock; eauto.
==========================================================================================
1193,1197c1040,1041
<   inv STACKS.
<   exploit Mem.unrecord_stack_block_inject_parallel_flat. 2: eauto. eauto.
<   intros (m2' & USB & INJ).
<   econstructor; split.
<   eapply exec_return. eauto.
---
>   inv STACKS. econstructor; split.
>   eapply exec_return.
==========================================================================================
1226c1070
<   exists id,
---
>   exists id gd,
???????===================================================================================
1229,1232c1073,1075
<   /\ forall gd,
<        Genv.find_def ge b = Some gd ->
<        Genv.find_def tge b' = Some gd /\
<        forall i, ref_def gd i -> kept i.
---
>   /\ Genv.find_def ge b = Some gd
>   /\ Genv.find_def tge b' = Some gd
>   /\ (forall i, ref_def gd i -> kept i).
==========================================================================================
1235,1240c1078,1082
<   split; auto.
<   esplit.
<   split; eauto.
<   split; eauto.
<   intros gd Hgd.
<   exploit defs_inject. apply init_meminj_preserves_globals.
---
>   assert (exists gd, (prog_defmap p)!id = Some gd).
>   { apply prog_defmap_dom. eapply Genv.find_symbol_inversion; eauto. }
>   destruct H0 as [gd DM]. rewrite Genv.find_def_symbol in DM.
>   destruct DM as (b'' & P & Q). fold ge in P. rewrite P in B; inv B.
>   fold ge in Q. exploit defs_inject. apply init_meminj_preserves_globals.
==========================================================================================
1242c1084
<   eauto.
---
>   split. auto. exists id, gd; auto. 
==========================================================================================
1273,1288c1115,1126
< Lemma list_forall2_same_prefix_length {A B: Type} (P: A -> B -> Prop) l1:
<   forall l2 r1 r2,
<     list_forall2 P (l1 ++ r1) (l2 ++ r2) ->
<     length l1 = length l2 ->
<     list_forall2 P l1 l2 /\ list_forall2 P r1 r2.
< Proof.
<   induction l1; destruct l2; simpl; try congruence.
<   + split; auto.
<     constructor.
<   + inversion 1; subst.
<     inversion 1; subst.
<     exploit IHl1; eauto.
<     destruct 1.
<     split; auto.
<     constructor; auto.
< Qed.
---
> Lemma Mem_getN_forall2:
>   forall (P: memval -> memval -> Prop) c1 c2 i n p,
>   list_forall2 P (Mem.getN n p c1) (Mem.getN n p c2) ->
>   p <= i -> i < p + Z.of_nat n ->
>   P (ZMap.get i c1) (ZMap.get i c2).
> Proof.
>   induction n; simpl Mem.getN; intros.
> - simpl in H1. omegaContradiction.
> - inv H. rewrite inj_S in H1. destruct (zeq i p0).
> + congruence.
> + apply IHn with (p0 + 1); auto. omega. omega.
> Qed. 
1290,1291c1128,1129
< Lemma init_mem_inj_2:
<   Mem.inject init_meminj (flat_frameinj (length (Mem.stack m))) m tm.
---
> Lemma init_mem_inj_1:
>   Mem.mem_inj init_meminj m tm.
1293,1341c1131,1132
<   apply Mem.zero_delta_inject.
< - intros b1 b2 delta H.
<   apply init_meminj_invert in H.
<   destruct H; auto.
< - intros b1 b2 H.
<   apply init_meminj_invert in H.
<   destruct H as (_ & id & Hsymb & Htsymb).
<   split; eapply Genv.find_symbol_not_fresh; eauto.
< - intros b1 [] H.
<   apply init_meminj_invert in H.
<   destruct H as (_ & id1 & Hid1 & Htid1).
<   intros b2 H.
<   apply init_meminj_invert in H.
<   destruct H as (_ & id2 & Hid2 & Htid2).
<   cut (id1 = id2); [ congruence | ].
<   eapply Senv.find_symbol_injective with (t := Genv.to_senv tge); eauto.
< - intros b1 b2 H o k p0 H0.
<   apply init_meminj_invert_strong in H.
<   destruct H as (_ & id & Hid & Htid & Htdef).
<   destruct (Genv.find_def ge b1) as [ def | ] eqn:DEF.
<   *
<   specialize (Htdef _ (eq_refl _)).
<   destruct Htdef as (Htdef & _).
<   exploit (Genv.init_mem_characterization_gen p); eauto.
<   exploit (Genv.init_mem_characterization_gen tp); eauto.
<   destruct def as [f|v].
<   + destruct 1 as (Htperm & Htperm_impl) .
<     destruct 1 as (Hperm & Hperm_impl).
<     apply Hperm_impl in H0.
<     destruct H0; subst.
<     apply Mem.perm_cur; auto.
<   + destruct 1 as (Htperm & Htperm_impl & _).
<     destruct 1 as (Hperm & Hperm_impl & _).
<     apply Hperm_impl in H0.
<     destruct H0 as (LE & ORD).
<     eapply Htperm in LE.
<     apply Mem.perm_cur; auto.
<     eapply Mem.perm_implies; eauto.
<   *
<   exploit (Genv.init_mem_characterization_gen_strong p); eauto.
<   intros [GINIT _].
<   edestruct GINIT; eauto.
< - intros b1 b2 H o k p0 H0.
<   apply init_meminj_invert_strong in H.
<   destruct H as (_ & id & Hid & Htid & Htdef).
<   destruct (Genv.find_def ge b1) as [ def | ] eqn:DEF.
<   *
<   specialize (Htdef _ (eq_refl _)).
<   destruct Htdef as (Htdef & _).
---
>   intros; constructor; intros.
> - exploit init_meminj_invert_strong; eauto. intros (A & id & gd & B & C & D & E & F).
1344,1369c1135,1145
<   destruct def as [f|v].
<   + destruct 1 as (Htperm & Htperm_impl).
<     destruct 1 as (Hperm & Hperm_impl).
<     apply Htperm_impl in H0.
<     destruct H0; subst.
<     left.
<     apply Mem.perm_cur; auto.
<   + destruct 1 as (Htperm & Htperm_impl & _).
<     destruct 1 as (Hperm & Hperm_impl & _).
<     apply Htperm_impl in H0.
<     destruct H0 as (LE & ORD).
<     eapply Hperm in LE.
<     left.
<     apply Mem.perm_cur; auto.
<     eapply Mem.perm_implies; eauto.
<   *
<   exploit (Genv.init_mem_characterization_gen_strong p); eauto.
<   intros [GINIT _].
<   right; eauto.
< - intros b1 b2 H o v1 H0.
<   apply init_meminj_invert_strong in H.
<   destruct H as (_ & id & Hid & Htid & Htdef).
<   destruct (Genv.find_def ge b1) as [ def | ] eqn:DEF.
<   *
<   specialize (Htdef _ (eq_refl _)).
<   destruct Htdef as (Htdef & Hkept).
---
>   destruct gd as [f|v].
> + intros (P2 & Q2) (P1 & Q1).
>   apply Q1 in H0. destruct H0. subst.
>   apply Mem.perm_cur. auto.
> + intros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).
>   apply Q1 in H0. destruct H0. subst.
>   apply Mem.perm_cur. eapply Mem.perm_implies; eauto. 
>   apply P2. omega.
> - exploit init_meminj_invert; eauto. intros (A & id & B & C). 
>   subst delta. apply Zdivide_0.
> - exploit init_meminj_invert_strong; eauto. intros (A & id & gd & B & C & D & E & F).
1372,1437d1147
<   destruct def as [f|v].
<   + intros _.
<     destruct 1 as (_ & Hperm).
<     exfalso.
<     apply Mem.loadbytes_range_perm in H0.
<     assert (o <= o < o + 1) as Hrange by omega.
<     apply H0 in Hrange.
<     apply Hperm in Hrange.
<     destruct Hrange; discriminate.
<   + destruct 1 as (_ & _& _ & TREAD).
<     destruct 1 as (_ & Hperm & _ & READ).
<     generalize H0. intro H0_.
<     apply Mem.loadbytes_range_perm in H0.
<     assert (o <= o < o + 1) as Hrange by omega.
<     apply H0 in Hrange.
<     apply Hperm in Hrange.
<     destruct Hrange as (LE & Hrange).
<     assert (NO: gvar_volatile v = false).
<     { unfold Genv.perm_globvar in Hrange. destruct (gvar_volatile v); auto. inv Hrange. }
<     specialize (READ NO).
<     specialize (TREAD NO).
<     apply bytes_of_init_inject in Hkept.
<     replace (init_data_list_size (gvar_init v))
<     with
<     (o + (init_data_list_size (gvar_init v) - o))
<       in READ, TREAD
<       by omega.
<     apply Mem.loadbytes_split in READ; try omega.
<     destruct READ as (b1l & b1r & Hb1l & Hb1r & EQ1).
<     apply Mem.loadbytes_split in TREAD; try omega.
<     destruct TREAD as (b2l & b2r & Hb2l & Hb2r & EQ2).
<     apply Mem.loadbytes_length in Hb1l.
<     apply Mem.loadbytes_length in Hb2l.
<     fold ge in EQ1.
<     rewrite EQ1 in Hkept.
<     fold tge in EQ2.
<     rewrite EQ2 in Hkept.
<     apply list_forall2_same_prefix_length in Hkept; try congruence.
<     destruct Hkept as (_ & Hkept).
<     rewrite Z.add_0_l in Hb1r, Hb2r.
<     replace (init_data_list_size (gvar_init v) - o)
<     with (1 + (init_data_list_size (gvar_init v) - 1 - o))
<       in Hb1r, Hb2r
<       by omega.
<     apply Mem.loadbytes_split in Hb1r; try omega.
<     destruct Hb1r as (h1 & t1 & LOAD1 & _ & ?); subst.
<     apply Mem.loadbytes_split in Hb2r; try omega.
<     destruct Hb2r as (h2 & t2 & LOAD2 & _ & ?); subst.
<     rewrite H0_ in LOAD1.
<     inversion LOAD1; clear LOAD1; subst.
<     generalize LOAD2. intro LOAD2_.
<     apply Mem.loadbytes_length in LOAD2_.
<     destruct h2 as [ | ? [ | ] ] ; try discriminate.
<     inversion Hkept; subst.
<     eauto.
<   *
<   apply Mem.loadbytes_range_perm in H0.
<   exploit (Genv.init_mem_characterization_gen_strong p); eauto.
<   intros [GINIT _].
<   edestruct GINIT; eauto.
<   eapply H0.
<   instantiate (1 := o); omega.
< - repeat rewrite_stack_blocks.
<   unfold flat_frameinj; simpl.
<   apply stack_inject_nil.
< (*
1482d1191
< *)
1507c1216
<   exists f tm, Genv.init_mem tp = Some tm /\ Mem.inject f (flat_frameinj (length (Mem.stack m))) m tm /\ meminj_preserves_globals f.
---
>   exists f tm, Genv.init_mem tp = Some tm /\ Mem.inject f m tm /\ meminj_preserves_globals f.
1518c1227
<   forall S1, initial_state fn_stack_requirements p S1 -> exists S2, initial_state fn_stack_requirements tp S2 /\ match_states S1 S2.
---
>   forall S1, initial_state p S1 -> exists S2, initial_state tp S2 /\ match_states S1 S2.
1526,1577c1235,1241
<   edestruct Mem.record_init_sp_inject as (m1' & RIS & INJ'); eauto. 
<   repeat rewrite_stack_blocks. omega.
<   - exists (Callstate nil f nil (Mem.push_new_stage m1') (fn_stack_requirements (prog_main tp))); split.
<     econstructor; eauto.
<     + fold tge. erewrite match_prog_main by eauto. auto.
<     + destruct TRANSF. rewrite match_prog_main0.
<       econstructor; eauto.
<       2: apply Mem.push_new_stage_inject_flat.
<       2: rewrite_stack_blocks; simpl.
<       2: rewrite frameinj_push_flat; eauto.
<       constructor.
<       * inv C; constructor; simpl.
<         ++ intros id b0 b' delta JB FS.
<            repeat destr_in JB; eauto.
<            eapply Genv.find_symbol_not_fresh in FS; eauto.
<            contradict FS; unfold Mem.valid_block. rewnb; xomega.
<         ++ intros id b0 KEPT FS.
<            destr; eauto. subst. 
<            eapply Genv.find_symbol_not_fresh in FS; eauto.
<            contradict FS; unfold Mem.valid_block. rewnb; xomega.
<         ++ intros id b' FS. edestruct symbols_inject_6 as (b0 & FS' & FF); eauto.
<            eexists; split; eauto. destr. subst.
<            eapply Genv.find_symbol_not_fresh in FS'; eauto.
<            contradict FS'; unfold Mem.valid_block. rewnb; xomega.
<         ++ intros b0 b' delta gd JB FD.
<            repeat destr_in JB; eauto.
<            eapply Genv.find_def_not_fresh in FD; eauto.
<            contradict FD; unfold Mem.valid_block. rewnb; xomega.
<         ++ intros b0 b' delta gd JB FD.
<            repeat destr_in JB; eauto.
<            eapply Genv.find_def_not_fresh in FD; eauto.
<            contradict FD; unfold Mem.valid_block. rewnb; xomega.
<       * unfold ge.
<         unfold Mem.record_init_sp in H4; destr_in H4.
<         rewnb. xomega.
<       * unfold tge.
<         unfold Mem.record_init_sp in RIS; destr_in RIS.
<         rewnb. xomega.
< Qed.
< 
< Lemma stack_equiv_inv_initial:
<   forall S1 S2,
<     initial_state fn_stack_requirements p S1 ->
<     initial_state fn_stack_requirements tp S2 ->
<     match_states S1 S2 ->
<     stack_equiv_inv S1 S2.
< Proof.
<   intros S1 S2 IS1 IS2 MS.
<   inv IS1; inv IS2; inv MS.
<   red. simpl.
<   repeat rewrite_stack_blocks.
<   repeat constructor.
---
>   exists (Callstate nil f nil tm); split.
>   econstructor; eauto.
>   fold tge. erewrite match_prog_main by eauto. auto.
>   econstructor; eauto.
>   constructor. auto.
>   erewrite <- Genv.init_mem_genv_next by eauto. apply Ple_refl.
>   erewrite <- Genv.init_mem_genv_next by eauto. apply Ple_refl.
1588c1252
<   forward_simulation (semantics fn_stack_requirements p) (semantics fn_stack_requirements tp).
---
>   forward_simulation (semantics p) (semantics tp).
1591,1604c1255,1259
<   eapply forward_simulation_step with (match_states := fun s1 s2 => match_states s1 s2 /\ stack_equiv_inv s1 s2 /\ stack_inv s2).
<   - exploit globals_symbols_inject. apply init_meminj_preserves_globals. intros [A B]. exact A.
<   - simpl; intros s1 IS. edestruct transf_initial_states as (s2 & IS2 & MS); eauto.
<     exploit stack_equiv_inv_initial; eauto. intro SEI.
<     eexists; split; eauto. split; auto. split; auto.
<     eapply stack_inv_initial; eauto.
<   - intros s1 s2 r (MS & _) FS.
<     eapply transf_final_states; eauto.
<   - simpl. intros s1 t s1' STEP s2 (MS & SEI & SI2).
<     edestruct step_simulation as (s2' & STEP' & MS'); eauto.
<     eexists; split; eauto.
<     split. auto.
<     split. eapply stack_equiv_inv_step; eauto.
<     eapply stack_inv_inv; eauto.
---
>   eapply forward_simulation_step.
>   exploit globals_symbols_inject. apply init_meminj_preserves_globals. intros [A B]. exact A.
>   eexact transf_initial_states.
>   eexact transf_final_states.
>   eexact step_simulation.
1610c1265
<   forall p tp, match_prog p tp -> forward_simulation (semantics fn_stack_requirements p) (semantics fn_stack_requirements  tp).
---
>   forall p tp, match_prog p tp -> forward_simulation (semantics p) (semantics tp).
1615,1616d1269
< End WITHEXTERNALCALLS.
< 
1651c1304
<   (prog_option_defmap p)!id = None ->
---
>   (prog_defmap p)!id = None ->
1656c1309
<   apply prog_option_defmap_dom in A. destruct A as [g E]; congruence.
---
>   apply prog_defmap_dom in A. destruct A as [g E]; congruence.
1663c1316
<   (prog_option_defmap p)!id = None ->
---
>   (prog_defmap p)!id = None ->
1679c1332
<   destruct (link_prog_inv_strong _ _ _ L) as (X & NORPT1 & NORPT2 & Y & Z).
---
>   destruct (link_prog_inv _ _ _ L) as (X & Y & Z).
1682,1685c1335,1337
<   apply prog_defmap_option_defmap in H0.
<   rewrite prog_option_defmap_elements, PTree.gcombine in H0.
<   destruct (prog_option_defmap p1)!id as [[gd1|]|] eqn:GD1;
<   destruct (prog_option_defmap p2)!id as [[gd2|]|] eqn:GD2;
---
>   rewrite prog_defmap_elements, PTree.gcombine in H0.
>   destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;
>   destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;
1688,1689d1339
<   apply prog_defmap_option_defmap in GD1.
<   apply prog_defmap_option_defmap in GD2.
1691,1692d1340
<   destruct (link_def gd1 gd2) eqn:LINK; try discriminate.
<   inv H0.
1697,1706d1344
<   apply prog_defmap_option_defmap in GD1.
<   inv H0. destruct (ISP.In_dec id used1).
< * left; eapply used_closed; eauto.
< * assert (IS.In id used2) by tauto.
<   exploit used_defined_strong. eexact V2. eauto. intros [A|A].
<   destruct ((prog_defmap p2) ! id) eqn:DEF2 ; try congruence.
<   apply prog_defmap_option_defmap in DEF2. congruence.
<   elim n. rewrite A, <- X. eapply used_main; eauto.
< + (* left definition, reloaded *)
<   apply prog_defmap_option_defmap in GD1.
1710,1712c1348,1349
<   exploit used_defined_strong. eexact V2. eauto. intros [A|A].
<   destruct ((prog_defmap p2) ! id) eqn:DEF2 ; try congruence.
<   apply prog_defmap_option_defmap in DEF2. congruence.
---
>   exploit used_defined. eexact V2. eauto. intros [A|A].
>   exploit prog_defmap_dom; eauto. intros [g E]; congruence.
1715d1351
<   apply prog_defmap_option_defmap in GD2.
1719,1730c1355,1356
<   exploit used_defined_strong. eexact V1. eauto. intros [A|A].
<   destruct ((prog_defmap p1) ! id) eqn:DEF1 ; try congruence.
<   apply prog_defmap_option_defmap in DEF1. congruence.
<   elim n. rewrite A, X. eapply used_main; eauto.
< + (* right definition, reloaded *)
<   apply prog_defmap_option_defmap in GD2.
<   inv H0. destruct (ISP.In_dec id used2).
< * right; eapply used_closed; eauto.
< * assert (IS.In id used1) by tauto.
<   exploit used_defined_strong. eexact V1. eauto. intros [A|A].
<   destruct ((prog_defmap p1) ! id) eqn:DEF1 ; try congruence.
<   apply prog_defmap_option_defmap in DEF1. congruence.
---
>   exploit used_defined. eexact V1. eauto. intros [A|A].
>   exploit prog_defmap_dom; eauto. intros [g E]; congruence.
1740,1749c1366,1371
< + assert (E: exists g, link_prog_merge (prog_option_defmap p1)!id (prog_option_defmap p2)!id = Some g).
<   { destruct (prog_option_defmap p1)!id as [[gd1|]|] eqn:GD1;
<     destruct (prog_option_defmap p2)!id as [[gd2|]|] eqn:GD2; simpl; eauto.
<   * apply prog_defmap_option_defmap in GD1.
<     apply prog_defmap_option_defmap in GD2.
<     exploit Y; eauto.
<     destruct 1 as (_ & _ & gd & Hgd).
<     simpl in Hgd.
<     rewrite Hgd.
<     eauto.
---
> + assert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).
>   { destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;
>     destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.
>   * apply Y with id; auto.
>   * exists gd1; auto.
>   * exists gd2; auto.
1755,1764c1377,1378
<   simpl.
<   left.
<   match goal with
<     |- (prog_defmap ?q) ! id <> None =>
<     cut (exists g, (prog_option_defmap q) ! id = Some (Some g))
<   end.
<   { destruct 1 as (g_ & Hg_).
<     apply prog_defmap_option_defmap in Hg_.
<     congruence. }
<   rewrite prog_option_defmap_elements.
---
>   left. unfold prog_defs_names; simpl.
>   change id with (fst (id, g)). apply in_map. apply PTree.elements_correct.
1766,1783d1379
<   destruct g; eauto.
<   exfalso.
<   destruct H.
<   { exploit used_defined_strong; (try eexact H); eauto.
<     destruct 1; try contradiction.
<     destruct ((prog_defmap p1) ! id) eqn:EQ; try congruence.
<     apply prog_defmap_option_defmap in EQ.
<     rewrite EQ in LD.
<     destruct ((prog_option_defmap p2) ! id) as [ [ | ] | ] ; try discriminate.
<     simpl in LD. destruct (link_def _ _); discriminate.
<   }
<   exploit used_defined_strong; (try eexact H); eauto.
<   destruct 1; try congruence.
<   destruct ((prog_defmap p2) ! id) eqn:EQ; try congruence.
<   apply prog_defmap_option_defmap in EQ.
<   rewrite EQ in LD.
<   destruct ((prog_option_defmap p1) ! id) as [ [ | ] | ] ; try discriminate.
<   simpl in LD. destruct (link_def _ _); discriminate.
1793c1389
<   destruct (link_prog_inv _ _ _ H) as (U & NORPT1 & NORPT2 & V & W).
---
>   destruct (link_prog_inv _ _ _ H) as (U & V & W).
1797,1798d1392
< + inv B1. auto.
< + inv B2. auto.
1800,1801c1394,1395
<   rewrite (match_prog_option_def _ _ _ B1) in H0.
<   rewrite (match_prog_option_def _ _ _ B2) in H1.
---
>   rewrite (match_prog_def _ _ _ B1) in H0.
>   rewrite (match_prog_def _ _ _ B2) in H1.
1813,1814c1407,1408
< * rewrite ! prog_option_defmap_elements, !PTree.gcombine by auto.
<   rewrite (match_prog_option_def _ _ _ B1 id), (match_prog_option_def _ _ _ B2 id).
---
> * rewrite ! prog_defmap_elements, !PTree.gcombine by auto.
>   rewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).
1817,1818c1411,1412
<   destruct (prog_option_defmap p1)!id as [gd1|] eqn:GD1;
<   destruct (prog_option_defmap p2)!id as [gd2|] eqn:GD2.
---
>   destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;
>   destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.
1840c1434
< Instance TransfSelectionLink : TransfLink match_prog := link_match_program.
\ No newline at end of file
---
> Instance TransfSelectionLink : TransfLink match_prog := link_match_program.
