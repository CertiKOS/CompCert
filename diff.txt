13c13
< (** Correctness proof for the translation from Linear to Mach_old. *)
---
> (** Correctness proof for the translation from Linear to Mach. *)
==========================================================================================
18,23c18,22
< Require Import Integers AST_old Linking_old.
< Require Import Setoid.
< Require Import Values_old Memory_old Separation_old Events_old Globalenvs_old Smallstep_old.
< Require Import LTL_old Op_old Locations_old Linear_old Mach_old.
< Require Import Bounds_old Conventions_old Stacklayout_old Lineartyping_old.
< Require Import Stacking_old.
---
> Require Import Integers AST Linking.
> Require Import Values Memory Separation Events Globalenvs Smallstep.
> Require Import LTL Op Locations Linear Mach.
> Require Import Bounds Conventions Stacklayout Lineartyping.
> Require Import Stacking.
==========================================================================================
27c26
< Definition match_prog (p: Linear_old.program) (tp: Mach_old.program) :=
---
> Definition match_prog (p: Linear.program) (tp: Mach.program) :=
==========================================================================================
39c38
<   forall ty, AST_old.typesize ty = 4 * Locations_old.typesize ty.
---
>   forall ty, AST.typesize ty = 4 * Locations.typesize ty.
==========================================================================================
45c44
<   forall ty, size_chunk (chunk_of_type ty) = AST_old.typesize ty.
---
>   forall ty, size_chunk (chunk_of_type ty) = AST.typesize ty.
==========================================================================================
51c50
<   forall ty, align_chunk (chunk_of_type ty) = 4 * Locations_old.typealign ty.
---
>   forall ty, align_chunk (chunk_of_type ty) = 4 * Locations.typealign ty.
==========================================================================================
76d74
< 
==========================================================================================
78,79d75
<   Existing Instance inject_perm_all.
< Context `{external_calls_prf: ExternalCalls}.
==========================================================================================
81c77
< Variable return_address_offset: Mach_old.function -> Mach_old.code -> ptrofs -> Prop.
---
> Variable return_address_offset: Mach.function -> Mach.code -> ptrofs -> Prop.
==========================================================================================
88,89c84,87
< Variable prog: Linear_old.program.
< Variable tprog: Mach_old.program.
---
> Let step := Mach.step return_address_offset.
> 
> Variable prog: Linear.program.
> Variable tprog: Mach.program.
==========================================================================================
94,103d91
< Section WITHINITSP.
< 
< Variables init_ra: val.
< Let step := Mach_old.step init_ra return_address_offset invalidate_frame1.
< 
< Opaque bound_outgoing bound_local bound_stack_data Z.mul Z.add.
< 
< 
< Transparent bound_outgoing bound_local bound_stack_data Z.mul Z.add.
< 
==========================================================================================
106c94
< Variable f: Linear_old.function.
---
> Variable f: Linear.function.
==========================================================================================
109c97
< Variable tf: Mach_old.function.
---
> Variable tf: Mach.function.
==========================================================================================
113,114c101,102
<   tf = Mach_old.mkfunction
<          f.(Linear_old.fn_sig)
---
>   tf = Mach.mkfunction
>          f.(Linear.fn_sig)
==========================================================================================
117,119c105,106
<          (* (Ptrofs.repr fe.(fe_ofs_link)) *)
<          (Ptrofs.repr fe.(fe_ofs_retaddr))
<          (fe_stack_data fe, fe_stack_data fe + bound_stack_data b).
---
>          (Ptrofs.repr fe.(fe_ofs_link))
>          (Ptrofs.repr fe.(fe_ofs_retaddr)).
==========================================================================================
147c134
<   f.(Linear_old.fn_stacksize) <= b.(bound_stack_data).
---
>   f.(Linear.fn_stacksize) <= b.(bound_stack_data).
==========================================================================================
180d166
<   stack_access (Mem.stack m) sp ofs (ofs + size_chunk (chunk_of_type ty)) ->
==========================================================================================
192,299d177
< 
< Lemma wt_encoded_ra_same_64:
<   forall v, Archi.ptr64 = true -> 
<        Val.has_type v Tptr ->
<        v <> Vundef ->
<        Mem.encoded_ra (encode_val Mptr v) = Some v.
< Proof.
<   clear step.
<   unfold Tptr, Mem.encoded_ra, Mptr.
<   intros v ARCH WT NU.
<   destr_in WT.
<   destruct v; simpl in WT; try congruence; try easy.
<   (* + simpl. rewrite proj_inj_bytes. unfold Vptrofs; rewrite Heqb0. f_equal. f_equal. *)
<   (*   rewrite decode_encode_int. *)
<   (*   erewrite Ptrofs.agree64_to_int_eq. eauto. *)
<   (*   etransitivity. apply Ptrofs.agree64_repr. auto. *)
<   (*   rewrite Z.mod_small. *)
<   (*   rewrite Int64.repr_unsigned. auto. apply Int64.unsigned_range. *)
<   (* + simpl. rewrite WT. rewrite proj_bytes_inj_value. rewrite proj_inj_value. reflexivity. *)
< Qed.
< 
< Lemma wt_encoded_ra_same_32:
<   forall v, Archi.ptr64 = false -> 
<        Val.has_type v Tptr ->
<        v <> Vundef ->
<        Mem.encoded_ra (encode_val Mptr v) = Some v.
< Proof.
<   clear step.
<   unfold Tptr, Mem.encoded_ra, Mptr.
<   intros v ARCH WT NU.
<   destr_in WT.
<   destruct v; simpl in WT. congruence.
<   + simpl. rewrite proj_inj_bytes. unfold Vptrofs; rewrite Heqb0. f_equal. f_equal.
<     rewrite decode_encode_int.
<     erewrite Ptrofs.agree32_to_int_eq. eauto.
<     etransitivity. apply Ptrofs.agree32_repr. auto.
<     rewrite Z.mod_small.
<     rewrite Int.repr_unsigned. auto. apply Int.unsigned_range.
<   + inv WT.
<   + inv WT.
<   + inv WT.
<   + simpl. rewrite WT. rewrite proj_bytes_inj_value. rewrite proj_inj_value. reflexivity.
< Qed.
<   
< Lemma wt_encoded_ra_same:
<   forall v, Val.has_type v Tptr ->
<        v <> Vundef ->
<        Mem.encoded_ra (encode_val Mptr v) = Some v.
< Proof.
<   destruct Archi.ptr64 eqn:ARCH.
<   intros. eapply wt_encoded_ra_same_64; eauto.
<   intros. eapply wt_encoded_ra_same_32; eauto.
< Qed.
< 
< Lemma store_rule':
<   forall m b ofs v (spec1: val -> Prop) P,
<     m |= contains Mptr b ofs spec1 ** P ->
<     stack_access (Mem.stack m) b ofs (ofs + size_chunk Mptr) ->
<     Val.has_type v Tptr ->
<     v <> Vundef ->
<     exists m',
<       Mem.store Mptr m b ofs v = Some m' /\ m' |= contains_ra b ofs v ** P.
< Proof.
<   intros m b0 ofs v spec1 P ((D & E & F & v0 & G & I) & B & C) SA VPTR VNU.
<   assert (FREEABLE: Mem.valid_access m Mptr b0 ofs Freeable).
<   {
<     split;[|split]; eauto.
<   }
<   assert (WRITABLE: Mem.valid_access m Mptr b0 ofs Writable).
<   {
<     eauto with mem.
<   }
<   destruct (Mem.valid_access_store _ _ _ _ v WRITABLE) as [m' STORE].
<   exists m'; split; auto. simpl. intuition auto.
< - eapply Mem.store_valid_access_1; eauto.
< - erewrite Mem.loadbytes_store_same; eauto. 2: rewrite Ptrofs.unsigned_repr; eauto.
<   eapply wt_encoded_ra_same; eauto.
< - apply (m_invar P) with m; auto. 
<   destruct (m_invar_weak P).
<   + eapply Mem.store_strong_unchanged_on; eauto.
<     intros; red; intros. apply (C b0 i); simpl; auto.
<   + eapply Mem.store_unchanged_on; eauto.
<     intros; red; intros. apply (C b0 i); simpl; auto.
<   + intros.
<     eapply Mem.store_stack_blocks; eauto.
< Qed.
< 
< 
< Lemma contains_ra_set_stack:
<   forall v spec1 m sp ofs P,
<   m |= contains Mptr sp ofs spec1 ** P ->
<   stack_access (Mem.stack m) sp ofs (ofs + size_chunk Mptr) ->
<   Val.has_type v Tptr ->
<   v <> Vundef ->
<   exists m',
<       store_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr ofs) v = Some m'
<   /\ m' |= contains_ra sp ofs v ** P.
< Proof.
<   intros v spec1 m sp ofs P CONT SA VPTR VNU.
<   unfold store_stack. 
<   replace (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr ofs)) with (Vptr sp (Ptrofs.repr ofs)).
<   simpl Mem.storev.
<   rewrite Ptrofs.unsigned_repr; eauto.
<   eapply store_rule'; eauto.
<   destruct CONT as ((A & _) & _); auto.
<   simpl. rewrite Ptrofs.add_zero_l; auto.
< Qed.
< 
==========================================================================================
313d190
<     (* Mem.stack_access m sp pos (pos + 4 * bound) /\ *)
==========================================================================================
319,321d195
<   ;
<   m_invar_weak := false;
<   m_invar_stack := false;
==========================================================================================
325,330c199,203
<   - red; intros. eapply Mem.perm_unchanged_on; eauto. simpl; auto.
<   (* - eapply Mem.unchanged_on_stack_access; eauto. simpl; auto. *)
<   - exploit H5; eauto. intros (v & A & B). exists v; split; auto.
<     eapply Mem.load_unchanged_on; eauto.
<     simpl; intros. rewrite size_type_chunk, typesize_typesize in H9. 
<     split; auto. omega.
---
> - red; intros. eapply Mem.perm_unchanged_on; eauto. simpl; auto.
> - exploit H4; eauto. intros (v & A & B). exists v; split; auto.
>   eapply Mem.load_unchanged_on; eauto.
>   simpl; intros. rewrite size_type_chunk, typesize_typesize in H8. 
>   split; auto. omega.
==========================================================================================
340d212
<   (perm_order p Writable -> stack_access (Mem.stack m) sp pos (pos + 4 * bound)) ->
==========================================================================================
344c216
<   intros; split; [|split].
---
>   intros; split.
==========================================================================================
346c218
<   apply H0. rewrite size_type_chunk, typesize_typesize in H5. omega.
---
>   apply H0. rewrite size_type_chunk, typesize_typesize in H4. omega.
==========================================================================================
351,353d222
< - intros.
<   eapply stack_access_inside; eauto. omega.
<   rewrite size_type_chunk. rewrite typesize_typesize. omega.
==========================================================================================
358,362c227,231
<     m |= contains_locations j sp pos bound sl ls ->
<     0 <= ofs -> ofs + typesize ty <= bound -> (typealign ty | ofs) ->
<     exists v,
<       load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) = Some v
<       /\ Val.inject j (ls (S sl ofs ty)) v.
---
>   m |= contains_locations j sp pos bound sl ls ->
>   0 <= ofs -> ofs + typesize ty <= bound -> (typealign ty | ofs) ->
>   exists v,
>      load_stack m (Vptr sp Ptrofs.zero) ty (Ptrofs.repr (pos + 4 * ofs)) = Some v
>   /\ Val.inject j (ls (S sl ofs ty)) v.
==========================================================================================
373d241
<   stack_access (Mem.stack m) sp pos (pos + 4 * bound) ->
==========================================================================================
386,414c254,276
<   - unfold store_stack; simpl. rewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; eauto.
<     unfold Ptrofs.max_unsigned. generalize (typesize_pos ty). omega.
<   - simpl. intuition auto.
<     + unfold Locmap.set.
<       destruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].
<       * (* same location *)
<         inv e. rename ofs0 into ofs. rename ty0 into ty.
<         exists (Val.load_result (chunk_of_type ty) v'); split.
<         eapply Mem.load_store_similar_2; eauto. omega. 
<         apply Val.load_result_inject; auto.
<       * (* different locations *)
<         exploit H; eauto. intros (v0 & X & Y). exists v0; split; auto.
<         rewrite <- X; eapply Mem.load_store_other; eauto.
<         destruct d. congruence. right. rewrite ! size_type_chunk, ! typesize_typesize. omega.
<       * (* overlapping locations *)
<         destruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].
<         apply Mem.valid_access_implies with Writable; auto with mem. 
<         eapply valid_access_location; eauto. 
<         intros; eapply Mem.store_stack_access; eauto.
<         exists v''; auto.
<     + apply (m_invar P) with m; auto. 
<       cut (Mem.strong_unchanged_on (m_footprint P) m m').
<       {
<         destruct (m_invar_weak P); auto using Mem.strong_unchanged_on_weak.
<       }
<       eapply Mem.store_strong_unchanged_on; eauto.
<       intros i; rewrite size_type_chunk, typesize_typesize. intros; red; intros.
<       eelim C; eauto. simpl. split; auto. omega.
<       intros; eapply Mem.store_stack_blocks; eauto. 
---
> - unfold store_stack; simpl. rewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; eauto.
>   unfold Ptrofs.max_unsigned. generalize (typesize_pos ty). omega.
> - simpl. intuition auto.
> + unfold Locmap.set. 
>   destruct (Loc.eq (S sl ofs ty) (S sl ofs0 ty0)); [|destruct (Loc.diff_dec (S sl ofs ty) (S sl ofs0 ty0))].
> * (* same location *)
>   inv e. rename ofs0 into ofs. rename ty0 into ty.
>   exists (Val.load_result (chunk_of_type ty) v'); split.
>   eapply Mem.load_store_similar_2; eauto. omega. 
>   apply Val.load_result_inject; auto.
> * (* different locations *)
>   exploit H; eauto. intros (v0 & X & Y). exists v0; split; auto.
>   rewrite <- X; eapply Mem.load_store_other; eauto.
>   destruct d. congruence. right. rewrite ! size_type_chunk, ! typesize_typesize. omega.
> * (* overlapping locations *)
>   destruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].
>   apply Mem.valid_access_implies with Writable; auto with mem. 
>   eapply valid_access_location; eauto.
>   exists v''; auto.
> + apply (m_invar P) with m; auto. 
>   eapply Mem.store_unchanged_on; eauto. 
>   intros i; rewrite size_type_chunk, typesize_typesize. intros; red; intros.
>   eelim C; eauto. simpl. split; auto. omega.
==========================================================================================
428c290
<   red; intros; eauto with mem. inversion 1.
---
>   red; intros; eauto with mem.
==========================================================================================
464c326
<       let sz := AST_old.typesize ty in
---
>       let sz := AST.typesize ty in
==========================================================================================
470,488d331
< Lemma contains_callee_saves_invar_weak rl :
<   forall j sp pos ls,
<     m_invar_weak (contains_callee_saves j sp pos rl ls) = false.
< Proof.
<   induction rl; simpl; auto.
< Qed.
< 
< (** Record [massert_eqv] and [massert_imp] as relations so that they can be used by rewriting tactics. *)
< Local Add Relation massert massert_imp
<   reflexivity proved by massert_imp_refl
<   transitivity proved by massert_imp_trans
< as massert_imp_prel.
< 
< Local Add Relation massert massert_eqv
<   reflexivity proved by massert_eqv_refl
<   symmetry proved by massert_eqv_sym
<   transitivity proved by massert_eqv_trans
< as massert_eqv_prel.
< 
==========================================================================================
528,529c371,372
<  (* ** hasvalue Mptr sp fe.(fe_ofs_link) parent *)
<  ** contains_ra sp fe.(fe_ofs_retaddr) retaddr
---
>  ** hasvalue Mptr sp fe.(fe_ofs_link) parent
>  ** hasvalue Mptr sp fe.(fe_ofs_retaddr) retaddr
==========================================================================================
537,558d379
< Lemma frame_contents_invar_weak j sp ls ls0 parent retaddr:
<   m_invar_weak (frame_contents j sp ls ls0 parent retaddr) = false.
< Proof.
<   simpl.
<   rewrite contains_callee_saves_invar_weak.
<   reflexivity.
< Qed.
< Lemma m_invar_stack_contains_callee_saves:
<   forall l j b delta ls,
<     m_invar_stack (contains_callee_saves j b delta l ls) = false.
< Proof.
<   induction l; simpl; intros; eauto.
< Qed.
< 
< Lemma frame_contents_invar_stack j sp ls ls0 parent retaddr:
<   m_invar_stack (frame_contents j sp ls ls0 parent retaddr) = false.
< Proof.
<   simpl.
<   rewrite m_invar_stack_contains_callee_saves.
<   reflexivity.
< Qed.
< 
==========================================================================================
587,595c408,416
< (* Lemma frame_get_parent: *)
< (*   forall j sp ls ls0 parent retaddr m P, *)
< (*   m |= frame_contents j sp ls ls0 parent retaddr ** P -> *)
< (*   load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr fe.(fe_ofs_link)) = Some parent. *)
< (* Proof. *)
< (*   unfold frame_contents, frame_contents_1; intros. *)
< (*   apply mconj_proj1 in H. apply sep_proj1 in H. apply sep_pick3 in H. rewrite <- chunk_of_Tptr in H. *)
< (*   eapply hasvalue_get_stack; eauto. *)
< (* Qed. *)
---
> Lemma frame_get_parent:
>   forall j sp ls ls0 parent retaddr m P,
>   m |= frame_contents j sp ls ls0 parent retaddr ** P ->
>   load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr fe.(fe_ofs_link)) = Some parent.
> Proof.
>   unfold frame_contents, frame_contents_1; intros.
>   apply mconj_proj1 in H. apply sep_proj1 in H. apply sep_pick3 in H. rewrite <- chunk_of_Tptr in H.
>   eapply hasvalue_get_stack; eauto.
> Qed.
==========================================================================================
600c421
<   Mem.loadbytesv Mptr m (Val.offset_ptr (Vptr sp Ptrofs.zero) (Ptrofs.repr fe.(fe_ofs_retaddr))) = Some retaddr.
---
>   load_stack m (Vptr sp Ptrofs.zero) Tptr (Ptrofs.repr fe.(fe_ofs_retaddr)) = Some retaddr.
==========================================================================================
603,604c424,425
<   apply mconj_proj1 in H. apply sep_proj1 in H. apply sep_pick3 in H.
<   destruct H as (A & B & C & D). Opaque fe_ofs_retaddr. simpl Val.offset_ptr. rewrite Ptrofs.add_zero_l, D. auto. Transparent fe_ofs_retaddr.
---
>   apply mconj_proj1 in H. apply sep_proj1 in H. apply sep_pick4 in H. rewrite <- chunk_of_Tptr in H.
>   eapply hasvalue_get_stack; eauto.
==========================================================================================
609,621d429
< Lemma store_stack_stack_access:
<   forall m sp ty o v m',
<     store_stack m sp ty o v = Some m' ->
<     forall b lo hi,
<       stack_access (Mem.stack m') b lo hi <->
<       stack_access (Mem.stack m) b lo hi.
< Proof.
<   unfold store_stack, Mem.storev.
<   intros.
<   destruct (Val.offset_ptr sp o); try discriminate.
<   eapply Mem.store_stack_access; eauto.
< Qed.
< 
==========================================================================================
627d434
<   stack_access (Mem.stack m) sp (fe_ofs_local fe) (fe_ofs_local fe + 4 * bound_local b) ->
==========================================================================================
636,637c443
<   exploit set_location; eauto.
<   intros (m' & A & B).
---
>   exploit set_location; eauto. intros (m' & A & B).
==========================================================================================
645,646c451,452
<   intros; eapply range_preserved; eauto. 
<   intros; eapply range_preserved; eauto. 
---
>   intros; eapply range_preserved; eauto.
>   intros; eapply range_preserved; eauto.
==========================================================================================
651,654c457,459
<     m |= frame_contents j sp ls ls0 parent retaddr ** P ->
<     slot_within_bounds b Outgoing ofs ty -> slot_valid f Outgoing ofs ty = true ->
<     Val.inject j v v' ->
<     stack_access (Mem.stack m) sp fe_ofs_arg (fe_ofs_arg + 4 * bound_outgoing b) ->
---
>   m |= frame_contents j sp ls ls0 parent retaddr ** P ->
>   slot_within_bounds b Outgoing ofs ty -> slot_valid f Outgoing ofs ty = true ->
>   Val.inject j v v' ->
==========================================================================================
663,664c468
<   exploit set_location; eauto.
<   intros (m' & A & B).
---
>   exploit set_location; eauto. intros (m' & A & B).
==========================================================================================
672,673c476,477
<   intros; eapply range_preserved; eauto. 
<   intros; eapply range_preserved; eauto. 
---
>   intros; eapply range_preserved; eauto.
>   intros; eapply range_preserved; eauto.
==========================================================================================
704c508
<   m |= frame_contents j sp (LTL_old.undef_regs rl ls) ls0 parent retaddr ** P.
---
>   m |= frame_contents j sp (LTL.undef_regs rl ls) ls0 parent retaddr ** P.
==========================================================================================
768c572
<        In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters f.(Linear_old.fn_sig))) ->
---
>        In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters f.(Linear.fn_sig))) ->
==========================================================================================
793,794d596
< 
< 
==========================================================================================
860c662
<   agree_regs j (LTL_old.undef_regs rl ls) (Mach_old.undef_regs rl rs).
---
>   agree_regs j (LTL.undef_regs rl ls) (Mach.undef_regs rl rs).
==========================================================================================
948c750
<   agree_locs (LTL_old.undef_regs regs ls) ls0.
---
>   agree_locs (LTL.undef_regs regs ls) ls0.
==========================================================================================
959c761
<   agree_locs (LTL_old.undef_regs regs ls) ls0.
---
>   agree_locs (LTL.undef_regs regs ls) ls0.
==========================================================================================
969c771
<   agree_locs (LTL_old.undef_regs regs ls) ls0.
---
>   agree_locs (LTL.undef_regs regs ls) ls0.
==========================================================================================
1118,1146d919
< 
< Lemma store_stack_is_stack_top:
<   forall m sp ty o v m',
<     store_stack m sp ty o v = Some m' ->
<     forall b,
<       is_stack_top (Mem.stack m') b <->
<       is_stack_top (Mem.stack m) b.
< Proof.
<   intros; erewrite store_stack_no_abstract; eauto. tauto.
< Qed.
< 
< Lemma store_stack_stack_blocks:
<   forall m1 sp ty o v m2,
<     store_stack m1 sp ty o v = Some m2 ->
<     Mem.stack m2 = Mem.stack m1.
< Proof.
<   intros; eapply store_stack_no_abstract; eauto.
< Qed.
< 
< Lemma store_stack_get_frame_info:
<   forall m1 sp ty o v m2 b,
<     store_stack m1 sp ty o v = Some m2 ->
<     get_frame_info (Mem.stack m2) b = get_frame_info (Mem.stack m1) b.
< Proof.
<   intros; erewrite store_stack_no_abstract; eauto.
< Qed.
< 
< 
< 
==========================================================================================
1170d942
<   is_stack_top (Mem.stack m) sp ->
1176,1181c948,949
<   /\ (forall b ofs k p, Mem.perm m b ofs k p -> Mem.perm m' b ofs k p)
<   /\ Mem.stack m = Mem.stack m'
<   /\ (forall b, get_frame_info (Mem.stack m') b = get_frame_info (Mem.stack m) b)
<   /\ agree_regs j ls rs'
<   /\ (forall b, Mem.valid_block m b -> Mem.valid_block m' b)
<   /\ Mem.unchanged_on (fun b o => b <> sp) m m'.
---
>   /\ (forall ofs k p, Mem.perm m sp ofs k p -> Mem.perm m' sp ofs k p)
>   /\ agree_regs j ls rs'.
==========================================================================================
1184c952
<   induction l as [ | r l]; simpl; intros until P; intros CS SEP AG IST.
---
>   induction l as [ | r l]; simpl; intros until P; intros CS SEP AG.
==========================================================================================
1188,1192c956,957
<   split. auto.
<   split. tauto. 
<   split. auto.
<   split. auto.
<   split. auto. apply Mem.unchanged_on_refl. 
---
>   split. auto. 
>   auto.
==========================================================================================
1194c959
<   set (sz := AST_old.typesize ty) in *.
---
>   set (sz := AST.typesize ty) in *.
==========================================================================================
1196c961
<   assert (SZPOS: sz > 0) by (apply AST_old.typesize_pos).
---
>   assert (SZPOS: sz > 0) by (apply AST.typesize_pos).
==========================================================================================
1209,1210c974
<   left. auto.
<   apply load_result_inject; auto. apply wt_ls.
---
>   apply load_result_inject; auto. apply wt_ls. 
==========================================================================================
1219,1220c983
<   eapply store_stack_is_stack_top; eauto.
<   intros (rs2 & m2 & A & B & C & ST & GFI & D & VALID & UNCH).
---
>   intros (rs2 & m2 & A & B & C & D).
==========================================================================================
1222,1223c985
<   split. eapply star_left; eauto. constructor. exact STORE.
<   auto. traceEq.
---
>   split. eapply star_left; eauto. constructor. exact STORE. auto. traceEq.
==========================================================================================
1226,1234c988
<   split. intros; rewrite <- ST. symmetry. eapply store_stack_stack_blocks; eauto.
<   split. intros; rewrite GFI. eapply store_stack_get_frame_info; eauto.
<   split. auto.
<   split. unfold store_stack, Val.offset_ptr, Mem.storev in STORE.
<   eauto with mem.
<   unfold store_stack, Val.offset_ptr, Mem.storev in STORE.
<   eapply Mem.unchanged_on_trans. 2: apply UNCH.
<   eapply Mem.store_unchanged_on; eauto.
<   left. auto. 
---
>   auto.
==========================================================================================
1240c994
<   forall r rl ls, In r rl -> LTL_old.undef_regs rl ls (R r) = Vundef.
---
>   forall r rl ls, In r rl -> LTL.undef_regs rl ls (R r) = Vundef.
==========================================================================================
1249c1003
<   forall r rl ls, ~In r rl -> LTL_old.undef_regs rl ls (R r) = ls (R r).
---
>   forall r rl ls, ~In r rl -> LTL.undef_regs rl ls (R r) = ls (R r).
==========================================================================================
1256c1010
<   forall sl ofs ty rl ls, LTL_old.undef_regs rl ls (S sl ofs ty) = ls (S sl ofs ty).
---
>   forall sl ofs ty rl ls, LTL.undef_regs rl ls (S sl ofs ty) = ls (S sl ofs ty).
==========================================================================================
1264c1018
<   Val.has_type (ls l) ty -> Val.has_type (LTL_old.undef_regs rl ls l) ty.
---
>   Val.has_type (ls l) ty -> Val.has_type (LTL.undef_regs rl ls l) ty.
==========================================================================================
1272,1324d1025
< 
< 
< (* Lemma callee_save_retaddr_sep: *)
< (*   forall b, *)
< (*     let fe := make_env b in *)
< (*     forall o, *)
< (*       fe_ofs_callee_save fe <= o < size_callee_save_area_rec (used_callee_save b) (fe_ofs_callee_save fe) -> *)
< (*       fe_ofs_retaddr fe <= o < fe_ofs_retaddr fe + size_chunk Mptr -> *)
< (*       False. *)
< (* Proof. *)
< (*   clear. intros b fe. *)
< (*   generalize (frame_env_separated' b). *)
< (*   simpl. intuition. *)
< (*   unfold Mptr in *. *)
< (*   cut (o < o). omega. *)
< (*   eapply Z.lt_le_trans. apply H8. *)
< (*   etransitivity. 2: apply H4. *)
< (*   etransitivity. 2: apply align_le. *)
< (*   etransitivity. 2: apply le_add_pos. *)
< (*   etransitivity. 2: apply align_le. *)
< (*   etransitivity. 2: apply le_add_pos. *)
< (*   etransitivity. 2: apply align_le. *)
< (*   unfold size_callee_save_area. omega. *)
< (*   all: try destr; try omega. *)
< (*   generalize (bound_local_pos b); omega. *)
< (*   generalize (bound_stack_data_pos b); omega. *)
< (* Qed. *)
< 
< 
< (* Lemma callee_save_link_sep: *)
< (*   forall b, *)
< (*     let fe := make_env b in *)
< (*     forall o, *)
< (*       fe_ofs_callee_save fe <= o < size_callee_save_area_rec (used_callee_save b) (fe_ofs_callee_save fe) -> *)
< (*       fe_ofs_link fe <= o < fe_ofs_link fe + size_chunk Mptr -> *)
< (*       False. *)
< (* Proof. *)
< (*   clear. intros b fe. *)
< (*   generalize (frame_env_separated' b). *)
< (*   simpl. intuition. *)
< (*   unfold Mptr in *. *)
< (*   cut (o < o). omega. *)
< (*   eapply Z.lt_le_trans. apply H10. *)
< (*   etransitivity. 2: apply H8. *)
< (*   destr. *)
< (* Qed. *)
< 
< 
< 
< 
< Opaque fe_ofs_retaddr fe_ofs_local fe_ofs_arg fe_ofs_callee_save
<        bound_local bound_outgoing size_callee_save_area_rec used_callee_save.
< 
==========================================================================================
1331,1332c1032
<   is_stack_top (Mem.stack m) sp ->
<   let ls1 := LTL_old.undef_regs destroyed_at_function_entry (LTL_old.call_regs ls) in
---
>   let ls1 := LTL.undef_regs destroyed_at_function_entry (LTL.call_regs ls) in
==========================================================================================
1339,1344c1039,1040
<   /\ (forall b ofs k p, Mem.perm m b ofs k p -> Mem.perm m' b ofs k p)
<   /\ Mem.stack m = Mem.stack m'
<   /\ (forall b, get_frame_info (Mem.stack m') b = get_frame_info (Mem.stack m) b)
<   /\ agree_regs j ls1 rs'
<   /\ (forall b, Mem.valid_block m b -> Mem.valid_block m' b )
<   /\ Mem.unchanged_on (fun b o => b <> sp) m m'.
---
>   /\ (forall ofs k p, Mem.perm m sp ofs k p -> Mem.perm m' sp ofs k p)
>   /\ agree_regs j ls1 rs'.
==========================================================================================
1346c1042
<   intros until P; intros SEP TY AGCS AG IST; intros ls1 rs1.
---
>   intros until P; intros SEP TY AGCS AG; intros ls1 rs1.
==========================================================================================
1353,1354c1049
< - auto.
< - clear SEP. intros (rs' & m' & EXEC & SEP & PERMS & ST & GFI' & AG' & VALID & UNCH).
---
> - clear SEP. intros (rs' & m' & EXEC & SEP & PERMS & AG').
==========================================================================================
1367,1372c1062
<   split. exact PERMS.
<   split. exact ST.
<   split. exact GFI'.
<   split. exact AG'.
<   split. exact VALID.
<   exact UNCH.
---
>   split. exact PERMS. exact AG'.
==========================================================================================
1380,1387d1069
< Lemma m_invar_stack_sepconj:
<   forall P Q,
<     m_invar_stack (P ** Q) = m_invar_stack P || m_invar_stack Q.
< Proof.
<   reflexivity.
< Qed.
< 
< 
==========================================================================================
1389,1390c1071
<   forall j ls ls0 ls1 rs rs1 m1 m1' m2 m2' sp parent ra cs fb k P,
<     m_invar_stack P = false ->
---
>   forall j ls ls0 ls1 rs rs1 m1 m1' m2 sp parent ra cs fb k P,
==========================================================================================
1394c1075
<   ls1 = LTL_old.undef_regs destroyed_at_function_entry (LTL_old.call_regs ls) ->
---
>   ls1 = LTL.undef_regs destroyed_at_function_entry (LTL.call_regs ls) ->
==========================================================================================
1396,1423c1077,1091
<   Mem.alloc m1 0 f.(Linear_old.fn_stacksize) = (m2', sp) ->
<   Mem.record_stack_blocks m2' (make_singleton_frame_adt sp (Linear_old.fn_stacksize f) (fe_size fe)) = Some m2 ->
<   Val.has_type parent Tptr -> Val.has_type ra Tptr -> ra <> Vundef ->
<   top_tframe_tc (Mem.stack m1') ->
<   stack_equiv (Mem.stack m1) (Mem.stack m1') ->
<   m1' |= minjection j (flat_frameinj (length (Mem.stack m1))) m1 ** globalenv_inject ge j ** P ->
<   exists j' rs' m2' sp' m3' m4' m5' fi,
<     Mem.alloc m1' 0 (fn_stacksize tf) = (m2', sp')
<     /\ store_stack m2' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_retaddr_ofs) ra = Some m3'
<     /\ frame_info_of_size_and_pubrange (fn_stacksize tf) (fn_frame_pubrange tf) = Some fi
<     /\ Mem.record_stack_blocks m3' (make_singleton_frame_adt' sp' fi (fn_stacksize tf)) = Some m4'
<     /\ star step tge
<            (State cs fb (Vptr sp' Ptrofs.zero) (save_callee_save fe k) rs1 m4')
<            E0 (State cs fb (Vptr sp' Ptrofs.zero) k rs' m5')
<     /\ agree_regs j' ls1 rs'
<     /\ agree_locs ls1 ls0
<     /\ m5' |= frame_contents j' sp' ls1 ls0 parent ra
<           ** minjection j' (flat_frameinj (length (Mem.stack m2))) m2
<           ** globalenv_inject ge j' ** P
<     /\ j' sp = Some(sp', fe.(fe_stack_data))
<     /\ inject_incr j j'
<     /\ inject_separated j j' m1 m1'
<     /\ (forall b, Mem.valid_block m1 b -> Mem.valid_block m2 b)
<     /\ (forall b, Mem.valid_block m1' b -> Mem.valid_block m5' b)
<     /\ (forall b o k p, Mem.perm m1' b o k p -> Mem.perm m5' b o k p)
<     /\ Mem.unchanged_on (fun b o => b <> sp') m1' m5'
<     /\ (Mem.stack m5' = Mem.stack m4' /\ Mem.stack m3' = Mem.stack m1')
<     /\ (forall b, get_frame_info (Mem.stack m5') b = get_frame_info (Mem.stack m4') b).
---
>   Mem.alloc m1 0 f.(Linear.fn_stacksize) = (m2, sp) ->
>   Val.has_type parent Tptr -> Val.has_type ra Tptr ->
>   m1' |= minjection j m1 ** globalenv_inject ge j ** P ->
>   exists j', exists rs', exists m2', exists sp', exists m3', exists m4', exists m5',
>      Mem.alloc m1' 0 tf.(fn_stacksize) = (m2', sp')
>   /\ store_stack m2' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_link_ofs) parent = Some m3'
>   /\ store_stack m3' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_retaddr_ofs) ra = Some m4'
>   /\ star step tge
>          (State cs fb (Vptr sp' Ptrofs.zero) (save_callee_save fe k) rs1 m4')
>       E0 (State cs fb (Vptr sp' Ptrofs.zero) k rs' m5')
>   /\ agree_regs j' ls1 rs'
>   /\ agree_locs ls1 ls0
>   /\ m5' |= frame_contents j' sp' ls1 ls0 parent ra ** minjection j' m2 ** globalenv_inject ge j' ** P
>   /\ j' sp = Some(sp', fe.(fe_stack_data))
>   /\ inject_incr j j'.
==========================================================================================
1425c1093
<   intros until P; intros STACK AGREGS AGCS WTREGS LS1 RS1 ALLOC RECORD TYPAR TYRA RANU TTNP SEQ SEP.
---
>   intros until P; intros AGREGS AGCS WTREGS LS1 RS1 ALLOC TYPAR TYRA SEP.
==========================================================================================
1427c1095
<   unfold fn_stacksize, fn_retaddr_ofs, fn_frame_pubrange.
---
>   unfold fn_stacksize, fn_link_ofs, fn_retaddr_ofs.
==========================================================================================
1429,1431c1097,1098
<   Local Opaque b fe_size.
<   generalize (frame_env_range b) (frame_env_aligned b). replace (make_env b) with fe by auto. simpl.
<   replace (make_env b) with fe by auto. simpl.
---
> Local Opaque b fe.
>   generalize (frame_env_range b) (frame_env_aligned b). replace (make_env b) with fe by auto. simpl. 
==========================================================================================
1434,1436c1101,1103
<   destruct (Mem.alloc m1' 0 (fe_size fe)) as (m2_ & sp') eqn:ALLOC'. 
<   exploit alloc_parallel_rule_2_flat.
<   eexact SEP. eexact ALLOC. eauto.
---
>   destruct (Mem.alloc m1' 0 (fe_size fe)) as [m2' sp'] eqn:ALLOC'.
>   exploit alloc_parallel_rule_2.
>   eexact SEP. eexact ALLOC. eexact ALLOC'. 
==========================================================================================
1440c1107
<   change (0 <= fe_size fe <= Ptrofs.max_unsigned). generalize (bound_stack_data_pos b) size_no_overflow; omega.
---
>   generalize (bound_stack_data_pos b) size_no_overflow; omega.
==========================================================================================
1443,1445c1110
<   rename SEP into SEP_init.
<   intros (j' & SEP & INCR1 & NEW & INJSEP).
<   (* clear SEP. intros (j' & m2__ & sp' & m2_ & ALLOC' & RECORD' & SEP & INCR & SAME & INJSEP). *)
---
>   clear SEP. intros (j' & SEP & INCR & SAME).
==========================================================================================
1448,1450c1113,1115
<             m2_ |= mconj (range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe))
<                 (range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe))
<                 ** minjection j' (flat_frameinj (length (Mem.stack m2'))) m2' ** globalenv_inject ge j' ** P).
---
>     m2' |= mconj (range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe))
>                  (range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe))
>            ** minjection j' m2 ** globalenv_inject ge j' ** P).
==========================================================================================
1453c1118
<   apply (frame_env_separated b) in SEP. replace (make_env b) with fe in * by auto.
---
>   apply (frame_env_separated b) in SEP. replace (make_env b) with fe in SEP by auto.
==========================================================================================
1456,1465c1121,1124
<   apply (range_contains Mptr) in SEP. 2: tauto.
<   Focus 2.
<   right. 
<   red. erewrite Mem.alloc_get_frame_info_fresh; eauto.
<   exploit (contains_ra_set_stack ra (fun _ => True) m2_).
<   eexact SEP.
<   right.
<   red. erewrite Mem.alloc_get_frame_info_fresh; eauto.
<   auto. auto.
<   clear SEP; intros (m3' & STORE_RETADDR & SEP).
---
>   apply (range_contains Mptr) in SEP; [|tauto].
>   exploit (contains_set_stack (fun v' => v' = parent) parent (fun _ => True) m2' Tptr).
>   rewrite chunk_of_Tptr; eexact SEP. apply Val.load_result_same; auto.
>   clear SEP; intros (m3' & STORE_PARENT & SEP).
==========================================================================================
1467,1556c1126,1131
< 
<   assert (SEP' : m3' |= minjection j' (flat_frameinj (length (Mem.stack m2'))) m2' **
<                      range sp' (fe_ofs_local fe) (fe_ofs_local fe + 4 * bound_local b) **
<                      range sp' fe_ofs_arg (fe_ofs_arg + 4 * bound_outgoing b) **
<                      contains_ra sp' (fe_ofs_retaddr fe) ra **
<                      range sp' (fe_ofs_callee_save fe) (size_callee_save_area b (fe_ofs_callee_save fe)) **
<                      globalenv_inject ge j' ** P).
<   {
<     rewrite sep_swap12.
<     rewrite sep_swap23.
<     rewrite sep_swap34.
<     rewrite sep_swap45. auto.
<   }
<   assert (exists fi, frame_info_of_size_and_pubrange (fn_stacksize tf) (fe_stack_data fe, fe_stack_data fe + bound_stack_data b) = Some fi).
<   {
<     unfold frame_info_of_size_and_pubrange.
<     destr. eauto.
<     generalize (fe_size_pos b). simpl. fold fe.
<     rewrite unfold_transf_function in g; simpl in g. omega.
<   }
<   destruct H as (fi & FRAME).
<   exploit record_stack_block_parallel_rule_2. apply NEW.
<   2: apply SEP'. rewrite ! m_invar_stack_sepconj. simpl. auto.
<   {
<     intro INF.
<     erewrite store_stack_stack_blocks in INF. 2: eauto.
<     erewrite Mem.alloc_stack_blocks in INF; eauto.
<     eapply Mem.in_frames_valid in INF. eapply Mem.fresh_block_alloc in INF; eauto.
<   }
<   eauto.
<   {
<     intros. eapply Mem.perm_implies. eapply Mem.perm_alloc_2; eauto.
<     constructor.
<   }
<   {
<     instantiate (1 := fi).
<     Opaque fe_stack_data. simpl. 
<     intros.
<     eapply Mem.perm_alloc_3 in H; eauto.
<     unfold frame_info_of_size_and_pubrange in FRAME; repeat destr_in FRAME. red. simpl.
<     assert (fe_stack_data fe <= ofs + fe_stack_data fe < fe_stack_data fe + bound_stack_data b).
<     {
<       generalize bound_stack_data_stacksize.
<       omega.
<     }
<     rewrite ! and_sumbool.
<     repeat destr.
<   }
<   {
<     intros ofs k0 p PERM.
<     unfold store_stack in STORE_RETADDR. simpl in STORE_RETADDR.
<     eapply Mem.perm_store_2 in PERM. 2: eauto.
<     eapply Mem.perm_alloc_inv in PERM. 2: eauto. rewrite pred_dec_true in PERM; auto.
<     unfold frame_info_of_size_and_pubrange in FRAME; repeat destr_in FRAME. simpl.
<     rewrite unfold_transf_function; simpl; auto.
<   }
<   {
<     intros.
<     destruct (j bb) eqn:JBB.
<     destruct p.
<     exploit INCR1. eauto. rewrite H. intro A; inv A.
<     eapply Mem.valid_block_inject_2 in JBB; eauto. 2: apply SEP_init.
<     eapply Mem.fresh_block_alloc in JBB; eauto. easy.
<     generalize (INJSEP _ _ _ JBB H). intros (NVB1 & NVB2).
<     destruct (peq bb sp); auto.
<     exfalso; apply NVB1. eapply Mem.valid_block_alloc_inv in ALLOC.
<     destruct ALLOC; eauto. congruence.
<     eapply Mem.valid_block_inject_1; eauto.
<     apply SEP.
<   }
<   {
<     unfold store_stack in STORE_RETADDR. repeat rewrite_stack_blocks.
<     auto.
<   }
<   repeat rewrite_stack_blocks. rewrite (store_stack_stack_blocks _ _ _ _ _ _ STORE_RETADDR).
<   repeat rewrite_stack_blocks. eauto.
<   intros (m5' & RSB & SEP2).
<   (* Saving callee-save registers *)
<   assert (SEP3 : m5'
<          |= range sp' (fe_ofs_local fe) (fe_ofs_local fe + 4 * bound_local b) **
<             range sp' fe_ofs_arg (fe_ofs_arg + 4 * bound_outgoing b) **
<             contains_ra sp' (fe_ofs_retaddr fe) ra **
<             range sp' (fe_ofs_callee_save fe) (size_callee_save_area b (fe_ofs_callee_save fe)) **
<             minjection j' (flat_frameinj (length (Mem.stack m2))) m2 **
<             globalenv_inject ge j' ** P).
<   {
<     rewrite <- ! (sep_swap (minjection j' _ m2)). auto.
<   }
<   clear SEP2 SEP' SEP.
<   rename SEP3 into SEP.
---
>   (* Store of return address *)
>   rewrite sep_swap4 in SEP.
>   apply (range_contains Mptr) in SEP; [|tauto].
>   exploit (contains_set_stack (fun v' => v' = ra) ra (fun _ => True) m3' Tptr).
>   rewrite chunk_of_Tptr; eexact SEP. apply Val.load_result_same; auto.
>   clear SEP; intros (m4' & STORE_RETADDR & SEP).
==========================================================================================
1557a1133,1134
>   (* Saving callee-save registers *)
>   rewrite sep_swap5 in SEP.
==========================================================================================
1560,1562c1137
<   eapply Mem.record_stack_block_is_stack_top; eauto.
<   red. simpl; auto.
<   replace (LTL_old.undef_regs destroyed_at_function_entry (call_regs ls)) with ls1 by auto.
---
>   replace (LTL.undef_regs destroyed_at_function_entry (call_regs ls)) with ls1 by auto.
==========================================================================================
1564,1566c1139,1140
<   simpl.
<   clear SEP; intros (rs2 & m6' & SAVE_CS & SEP & PERMS & ST & GFI & AGREGS' & VALID & UNCH).
<   rewrite sep_swap4 in SEP.
---
>   clear SEP; intros (rs2 & m5' & SAVE_CS & SEP & PERMS & AGREGS').
>   rewrite sep_swap5 in SEP.
==========================================================================================
1579,1614c1153,1164
<   assert (SEPFINAL: m6' |= frame_contents j' sp' ls1 ls0 parent ra ** minjection j'
<                         (flat_frameinj (length (Mem.stack m2))) m2 ** globalenv_inject ge j' ** P).
<   {
<     assert (forall ofs k p, Mem.perm m2_ sp' ofs k p -> Mem.perm m6' sp' ofs k p) as PERMS'.
<       { intros. apply PERMS. 
<         unfold store_stack in STORE_RETADDR.
<         eapply Mem.record_stack_block_perm'. eauto.
<         simpl in STORE_RETADDR.
<         eapply Mem.perm_store_1 in H; eauto.
<       }
<     assert (  m6' |= range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe)) as RANGE.
<     {
<       split. eapply range_preserved. apply SEPCONJ. auto.
<       split. eapply range_preserved. apply SEPCONJ. auto.
<       red; intros b0 ofs R1 R2. simpl in R1, R2.
<       generalize (bound_stack_data_pos b). omega.
<     }
<     eapply frame_mconj.
<     - split. split; apply RANGE. 
<       split. apply SEP.
<       intros bb o. simpl.
<       intros FP1 FP2.      
<       destruct SEPCONJ as (? & ? & DISJ).
<       apply (DISJ bb o). simpl. auto.
<       change (m_footprint (minjection j' (flat_frameinj (length (Mem.stack m2')))  m2') bb o \/ m_footprint (globalenv_inject ge j' ** P) bb o).
<       change (m_footprint (minjection j' (flat_frameinj (length (Mem.stack m2)))  m2) bb o \/ m_footprint (globalenv_inject ge j' ** P) bb o) in FP2.
<       destruct FP2 as [FP2|FP2]; auto.
<       left.
<       simpl. simpl in FP2.
<       destruct FP2 as (b0 & delta & EQ & PERM).
<       exists b0, delta; rewrite EQ; split; auto.
<       eapply Mem.record_stack_block_perm in PERM; eauto.
<     - unfold frame_contents_1; rewrite ! sep_assoc. exact SEP.
<     - eapply sep_preserved. eapply sep_proj1. eapply mconj_proj2. eexact SEPCONJ.
<       intros; apply range_preserved with m2_; auto.
<       intros; apply range_preserved with m2_; auto.
---
>   assert (SEPFINAL: m5' |= frame_contents j' sp' ls1 ls0 parent ra ** minjection j' m2 ** globalenv_inject ge j' ** P).
>   { eapply frame_mconj. eexact SEPCONJ.
>     rewrite chunk_of_Tptr in SEP.  
>     unfold frame_contents_1; rewrite ! sep_assoc. exact SEP.
>     assert (forall ofs k p, Mem.perm m2' sp' ofs k p -> Mem.perm m5' sp' ofs k p).
>     { intros. apply PERMS. 
>       unfold store_stack in STORE_PARENT, STORE_RETADDR.
>       simpl in STORE_PARENT, STORE_RETADDR.
>       eauto using Mem.perm_store_1. }
>     eapply sep_preserved. eapply sep_proj1. eapply mconj_proj2. eexact SEPCONJ.
>     intros; apply range_preserved with m2'; auto.
>     intros; apply range_preserved with m2'; auto.
==========================================================================================
1617,1619c1167,1168
<   (* Conclusions *)
<   exists j', rs2, m2_, sp', m3', m5', m6'. eexists.
<   split. auto.
---
> (* Conclusions *)
>   exists j', rs2, m2', sp', m3', m4', m5'.
==========================================================================================
1621,1624c1170,1173
<   split. rewrite <- FRAME. rewrite unfold_transf_function. simpl.  f_equal.
<   split. auto.
<   split. subst. eexact SAVE_CS.
<   split. subst. exact AGREGS'.
---
>   split. exact STORE_PARENT.
>   split. exact STORE_RETADDR.
>   split. eexact SAVE_CS.
>   split. exact AGREGS'.
==========================================================================================
1626,1628c1175,1177
<   constructor; intros. unfold call_regs. apply AGCS. 
<   unfold mreg_within_bounds in H; tauto.
<   unfold call_regs. apply AGCS. auto.
---
>     constructor; intros. unfold call_regs. apply AGCS. 
>     unfold mreg_within_bounds in H; tauto.
>     unfold call_regs. apply AGCS. auto.
==========================================================================================
1630,1665c1179
<   split. auto.
<   split. exact INCR1.
<   split. exact INJSEP.
<   split.
<   {
<     intros. eapply Mem.record_stack_block_valid; eauto.
<     eapply Mem.valid_block_alloc in H; eauto.
<   }
<   split.
<   {
<     unfold store_stack, Val.offset_ptr, Mem.storev in *.
<     intros.
<     eapply VALID.
<     eapply Mem.record_stack_block_valid; eauto.
<     eapply Mem.valid_block_alloc in H. 2: eauto.
<     eapply Mem.store_valid_block_1 in H; eauto.
<   }
<   split.
<   {
<     intros.
<     eapply PERMS.
<     eapply Mem.record_stack_block_perm'; eauto.
<     eapply Mem.perm_alloc_1 in H. 2: eauto.    
<     unfold store_stack, Val.offset_ptr, Mem.storev in * .
<     eapply Mem.perm_store_1 in H; eauto.
<   }
<   split.
<   - eapply Mem.unchanged_on_trans. eapply Mem.alloc_unchanged_on. eauto.
<     eapply Mem.unchanged_on_trans. eapply Mem.store_unchanged_on.
<     unfold store_stack in STORE_RETADDR. simpl in STORE_RETADDR. eauto.
<     intuition.
<     eapply Mem.unchanged_on_trans.
<     eapply Mem.strong_unchanged_on_weak. eapply Mem.record_stack_block_unchanged_on. eauto.
<     exact UNCH.
<   - rewrite <- ST. split; auto. split; auto.
<     unfold store_stack in STORE_RETADDR. repeat rewrite_stack_blocks. auto.
---
>   split. exact SAME. exact INCR.
==========================================================================================
1704c1218
<   set (sz := AST_old.typesize ty) in *.
---
>   set (sz := AST.typesize ty) in *.
==========================================================================================
1706c1220
<   assert (SZPOS: sz > 0) by (apply AST_old.typesize_pos).
---
>   assert (SZPOS: sz > 0) by (apply AST.typesize_pos).
==========================================================================================
1746c1260
<   apply mconj_proj1 in H. rewrite ! sep_assoc in H. apply sep_pick4 in H. 
---
>   apply mconj_proj1 in H. rewrite ! sep_assoc in H. apply sep_pick5 in H. 
==========================================================================================
1759d1272
< 
==========================================================================================
1767,1768c1280
<     m_invar_stack P = false ->
<   m' |= frame_contents j sp' ls ls0 pa ra ** minjection j (flat_frameinj (length (Mem.stack m))) m ** P ->
---
>   m' |= frame_contents j sp' ls ls0 pa ra ** minjection j m ** P ->
==========================================================================================
1772,1773c1284
<   Mem.free m sp 0 f.(Linear_old.fn_stacksize) = Some m1 ->
<   stack_equiv (Mem.stack m) (Mem.stack m') ->
---
>   Mem.free m sp 0 f.(Linear.fn_stacksize) = Some m1 ->
==========================================================================================
1775,1776c1286,1288
<       Mem.loadbytesv Mptr m' (Val.offset_ptr (Vptr sp' Ptrofs.zero) tf.(fn_retaddr_ofs)) = Some ra
<   /\ Mem.free m' sp' 0 (fe_size fe) = Some m1'
---
>      load_stack m' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_link_ofs) = Some pa
>   /\ load_stack m' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_retaddr_ofs) = Some ra
>   /\ Mem.free m' sp' 0 tf.(fn_stacksize) = Some m1'
==========================================================================================
1782,1783c1294
<   /\ m1' |= minjection j (flat_frameinj (length (Mem.stack m1))) m1 ** P
<   /\ stack_equiv (Mem.stack m1) (Mem.stack m1').
---
>   /\ m1' |= minjection j m1 ** P.
==========================================================================================
1785c1296
<   intros until fb; intros STACK SEP AGR AGL INJ FREE SE.  (* fi r n ADT SIZE. *)
---
>   intros until fb; intros SEP AGR AGL INJ FREE.
==========================================================================================
1788,1790c1299,1302
<   apply mconj_proj2 in SEP. rewrite <- sep_assoc. eauto. eauto. constructor.
<   eexact INJ.
<   auto. rewrite Z.max_comm; reflexivity.
---
>     rewrite <- sep_assoc. eapply mconj_proj2. eexact SEP.
>     eexact FREE.
>     eexact INJ.
>     auto. rewrite Z.max_comm; reflexivity.
==========================================================================================
1801,1804c1313,1314
<   assert (LOAD_RETADDR: Mem.loadbytesv Mptr m' (Val.offset_ptr (Vptr sp' Ptrofs.zero) (Ptrofs.repr (fe_ofs_retaddr fe))) = Some ra).
<   {
<     exploit sep_pick3. apply SEP. intros (A & B & C & D). simpl Val.offset_ptr. rewrite Ptrofs.add_zero_l. auto.
<   }
---
>   exploit (hasvalue_get_stack Tptr). rewrite chunk_of_Tptr. eapply sep_pick3; eexact SEP. intros LOAD_LINK.
>   exploit (hasvalue_get_stack Tptr). rewrite chunk_of_Tptr. eapply sep_pick4; eexact SEP. intros LOAD_RETADDR.
==========================================================================================
1806d1315
<   Opaque Mem.loadbytesv.
==========================================================================================
1808,1809c1317
<   rewrite unfold_transf_function; simpl in *.
<   Transparent Mem.loadbytesv.
---
>   rewrite unfold_transf_function; simpl.
==========================================================================================
1812a1321
>   split. assumption.
==========================================================================================
1820,1821c1329
<   split. rewrite_stack_blocks. assumption.
<   repeat rewrite_stack_blocks. eauto.
---
>   assumption.
==========================================================================================
1831,1834c1339
< Variable init_ls: locset.
< 
< Fixpoint stack_contents (j: meminj) (cs: list Linear_old.stackframe) (cs': list Mach_old.stackframe)
<          (stk: stack): massert :=
---
> Fixpoint stack_contents (j: meminj) (cs: list Linear.stackframe) (cs': list Mach.stackframe) : massert :=
==========================================================================================
1837,1839c1342,1344
<   | Linear_old.Stackframe f _ ls c :: cs, Mach_old.Stackframe fb sp' ra c' :: cs' =>
<     frame_contents f j sp' ls (parent_locset init_ls cs) (parent_sp stk) (parent_ra init_ra cs')
<                    ** stack_contents j cs cs' (tl stk)
---
>   | Linear.Stackframe f _ ls c :: cs, Mach.Stackframe fb (Vptr sp' _) ra c' :: cs' =>
>       frame_contents f j sp' ls (parent_locset cs) (parent_sp cs') (parent_ra cs')
>       ** stack_contents j cs cs'
==========================================================================================
1843,1887d1347
< Lemma stack_contents_invar_weak cs :
<   forall j cs' stk, m_invar_weak (stack_contents j cs cs' stk) = false.
< Proof.
<   induction cs; destruct cs' ; simpl; auto.
<   + destruct a; auto.
<   + destruct a; auto.
<     destruct s; auto.
<     intros.
<     match goal with
<         [ |- context [m_invar_weak (?U ** ?V)] ] =>
<         replace (m_invar_weak (U ** V))
<                 with (m_invar_weak U || m_invar_weak V)
<           by reflexivity
<     end.
<     rewrite frame_contents_invar_weak.
<     simpl.
<     auto.
< Qed.
< 
< 
< Lemma stack_contents_invar_stack cs :
<   forall j cs' stk, m_invar_stack (stack_contents j cs cs' stk) = false.
< Proof.
<   induction cs; destruct cs' ; simpl; intros; auto.
<   + destruct a; auto.
<   + destruct a; auto.
<     destruct s; auto.
<     match goal with
<         [ |- context [m_invar_stack (?U ** ?V)] ] =>
<         replace (m_invar_stack (U ** V))
<                 with (m_invar_stack U || m_invar_stack V)
<           by reflexivity
<     end.
<     rewrite frame_contents_invar_stack.
<     simpl.
<     auto.
< Qed.
< 
< (* [init_sg] is the signature of the outermost calling function. In the
< whole-program, this is the signature of the [main] function (see the
< match_states' definition at the very end of this file) *)
< 
< Variable init_sg: signature.
< 
< 
==========================================================================================
1891,1913c1351,1367
< Inductive match_stacks (j: meminj) :
<   list Linear_old.stackframe -> list stackframe -> signature -> signature -> Prop :=
< | match_stacks_empty:
<     forall sg
<       (TP: tailcall_possible sg \/ sg = init_sg)
<       (BND: 4 * size_arguments sg <= Ptrofs.max_unsigned),
<       match_stacks j nil nil sg sg
< | match_stacks_cons:
<     forall f sp ls c cs fb sp' ra c' cs' sg trf
<       isg
<       (TAIL: is_tail c (Linear_old.fn_code f))
<       (FINDF: Genv.find_funct_ptr tge fb = Some (Internal trf))
<       (TRF: transf_function f = OK trf)
<       (TRC: transl_code (make_env (function_bounds f)) c = c')
<       (INJ: j sp = Some(sp', (fe_stack_data (make_env (function_bounds f)))))
<       (INJ_UNIQUE: forall b delta, j b = Some (sp', delta) -> b = sp)
<       (TY_RA: Val.has_type ra Tptr)
<       (AGL: agree_locs f ls (parent_locset init_ls cs))
<       (ARGS: forall ofs ty,
<           In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->
<           slot_within_bounds (function_bounds f) Outgoing ofs ty)
<       (BND: 4 * size_arguments sg <= Ptrofs.max_unsigned)
<       (STK: match_stacks j cs cs' (Linear_old.fn_sig f) isg),
---
> Inductive match_stacks (j: meminj):
>        list Linear.stackframe -> list stackframe -> signature -> Prop :=
>   | match_stacks_empty: forall sg,
>       tailcall_possible sg ->
>       match_stacks j nil nil sg
>   | match_stacks_cons: forall f sp ls c cs fb sp' ra c' cs' sg trf
>         (TAIL: is_tail c (Linear.fn_code f))
>         (FINDF: Genv.find_funct_ptr tge fb = Some (Internal trf))
>         (TRF: transf_function f = OK trf)
>         (TRC: transl_code (make_env (function_bounds f)) c = c')
>         (INJ: j sp = Some(sp', (fe_stack_data (make_env (function_bounds f)))))
>         (TY_RA: Val.has_type ra Tptr)
>         (AGL: agree_locs f ls (parent_locset cs))
>         (ARGS: forall ofs ty,
>            In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) ->
>            slot_within_bounds (function_bounds f) Outgoing ofs ty)
>         (STK: match_stacks j cs cs' (Linear.fn_sig f)),
==========================================================================================
1915,1933c1369,1371
<                    (Linear_old.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)
<                    (Stackframe fb sp' ra c' :: cs')
<                    sg isg.
< 
< Lemma match_stacks_size_args:
<   forall j ll lm sg sg_
<     (MS: match_stacks j ll lm sg sg_),
<     4 * size_arguments sg <= Ptrofs.max_unsigned.
< Proof.
<   inversion 1; auto.
< Qed.
< 
< Lemma match_stacks_size_args':
<   forall j ll lm sg sg_
<     (MS: match_stacks j ll lm sg sg_),
<     4 * size_arguments sg_ <= Ptrofs.max_unsigned.
< Proof.
<   induction 1; auto.
< Qed.
---
>                    (Linear.Stackframe f (Vptr sp Ptrofs.zero) ls c :: cs)
>                    (Stackframe fb (Vptr sp' Ptrofs.zero) ra c' :: cs')
>                    sg.
==========================================================================================
1939,1941c1377,1379
<   forall cs cs' stk P,
<   m |= stack_contents j cs cs' stk ** P ->
<   m |= stack_contents j' cs cs' stk ** P.
---
>   forall cs cs' P,
>   m |= stack_contents j cs cs' ** P ->
>   m |= stack_contents j' cs cs' ** P.
==========================================================================================
1945c1383,1384
<   rewrite sep_assoc in H0 |- * .
---
>   destruct sp0; auto.
>   rewrite sep_assoc in *.
==========================================================================================
1952,1957c1391,1393
<           (exists m m',
<               inject_separated j j' m m' /\
<               (forall b b' delta, j b = Some (b', delta) -> Mem.valid_block m' b')) ->
<   forall cs cs' sg isg,
<   match_stacks j cs cs' sg isg ->
<   match_stacks j' cs cs' sg isg.
---
>   forall cs cs' sg,
>   match_stacks j cs cs' sg ->
>   match_stacks j' cs cs' sg.
==========================================================================================
1959c1395
<   induction 3; intros.
---
>   induction 2; intros.
==========================================================================================
1962,1969d1397
<   destruct H0 as (m & m' & (H0 & VB)).
<   intros.
<   destruct (j b) eqn:?.
<   + destruct p. exploit H. eauto. intros.
<     assert (b0 = sp') by congruence. subst. eapply INJ_UNIQUE in Heqo. auto.
<   + generalize (H0 _ _ _ Heqo H2).
<     intros (A & B).
<     apply VB in INJ. congruence.
==========================================================================================
1972c1400
< Opaque Z.mul.
---
> (** Invariance with respect to change of signature. *)
==========================================================================================
1975,1976c1403,1404
<   forall sg1 j cs cs' sg isg,
<   match_stacks j cs cs' sg isg ->
---
>   forall sg1 j cs cs' sg,
>   match_stacks j cs cs' sg ->
==========================================================================================
1978,1983c1406
<   4 * size_arguments sg1 <= Ptrofs.max_unsigned ->
<   match_stacks j cs cs' sg1
<                match cs with
<                    nil => sg1
<                  | _ => isg
<                end.
---
>   match_stacks j cs cs' sg1.
==========================================================================================
1987c1410
<   econstructor; eauto. intros. elim (H0 _ H2).
---
>   econstructor; eauto. intros. elim (H0 _ H1).
==========================================================================================
1992,1996c1415,1421
< (** [CompCertX:test-compcert-protect-stack-arg] In whole-program settings, [init_sp = Vzero], so the following hypotheses are trivially true. 
<     In non-whole-program settings, the following two hypotheses are provided by the caller's assembly semantics, which maintains the well-typedness of the assembly register set as an invariant. *)
< Hypothesis init_ra_int: Val.has_type init_ra Tptr.
< Hypothesis init_ra_not_undef: init_ra <> Vundef.
< 
---
> Lemma match_stacks_type_sp:
>   forall j cs cs' sg,
>   match_stacks j cs cs' sg ->
>   Val.has_type (parent_sp cs') Tptr.
> Proof.
>   induction 1; unfold parent_sp. apply Val.Vnullptr_has_type. apply Val.Vptr_has_type.
> Qed. 
==========================================================================================
1999,2001c1424,1426
<   forall j cs cs' sg isg,
<   match_stacks j cs cs' sg isg ->
<   Val.has_type (parent_ra init_ra cs') Tptr.
---
>   forall j cs cs' sg,
>   match_stacks j cs cs' sg ->
>   Val.has_type (parent_ra cs') Tptr.
==========================================================================================
2003c1428
<   induction 1; unfold parent_ra. auto. auto. 
---
>   induction 1; unfold parent_ra. apply Val.Vnullptr_has_type. auto.
==========================================================================================
2014c1439
<   Mach_old.find_label lbl (save_callee_save_rec l ofs k) = Mach_old.find_label lbl k.
---
>   Mach.find_label lbl (save_callee_save_rec l ofs k) = Mach.find_label lbl k.
==========================================================================================
2021c1446
<   Mach_old.find_label lbl (restore_callee_save_rec l ofs k) = Mach_old.find_label lbl k.
---
>   Mach.find_label lbl (restore_callee_save_rec l ofs k) = Mach.find_label lbl k.
==========================================================================================
2034,2035c1459,1460
<   Mach_old.find_label lbl (transl_code fe c) =
<     option_map (transl_code fe) (Linear_old.find_label lbl c).
---
>   Mach.find_label lbl (transl_code fe c) =
>     option_map (transl_code fe) (Linear.find_label lbl c).
==========================================================================================
2051,2052c1476,1477
<   Linear_old.find_label lbl f.(Linear_old.fn_code) = Some c ->
<   Mach_old.find_label lbl tf.(Mach_old.fn_code) =
---
>   Linear.find_label lbl f.(Linear.fn_code) = Some c ->
>   Mach.find_label lbl tf.(Mach.fn_code) =
==========================================================================================
2066c1491
<   Linear_old.find_label lbl c = Some c' -> is_tail c' c.
---
>   Linear.find_label lbl c = Some c' -> is_tail c' c.
==========================================================================================
2070c1495
<   intro c'. case (Linear_old.is_label lbl a); intros.
---
>   intro c'. case (Linear.is_label lbl a); intros.
==========================================================================================
2115c1540
<   is_tail c (Linear_old.fn_code f) ->
---
>   is_tail c (Linear.fn_code f) ->
==========================================================================================
2136,2139d1560
< Lemma genv_next_preserved:
<   Genv.genv_next tge = Genv.genv_next ge.
< Proof. apply senv_preserved. Qed.
< 
==========================================================================================
2155c1576
<   forall f tf, transf_fundef f = OK tf -> Mach_old.funsig tf = Linear_old.funsig f.
---
>   forall f tf, transf_fundef f = OK tf -> Mach.funsig tf = Linear.funsig f.
==========================================================================================
2167c1588
<   Linear_old.find_function ge ros ls = Some f ->
---
>   Linear.find_function ge ros ls = Some f ->
==========================================================================================
2189,2206d1609
< (* [init_args_mach] states that the locations of the arguments of function with
< signature [sg] can be retrieved in [m'] (a Mach memory state) and agree with the
< locset [init_ls].*)
< 
< Variables init_stk : stack.
< 
< Definition init_sp : val := current_sp init_stk.
< 
< Definition init_args_mach j sg m' :=
<   forall sl of ty,
<     List.In (Locations_old.S sl of ty) (regs_of_rpairs (loc_arguments sg)) ->
<     forall rs,
<     exists v,
<       extcall_arg rs m' init_sp (S sl of ty) v /\
<       Val.inject j (init_ls (S sl of ty)) v.
< 
< (** General case *)
< 
==========================================================================================
2210c1613
< Variable cs: list Linear_old.stackframe.
---
> Variable cs: list Linear.stackframe.
==========================================================================================
2214,2215c1617
< Variable isg: signature.
< Hypothesis MS: match_stacks j cs cs' sg isg.
---
> Hypothesis MS: match_stacks j cs cs' sg.
==========================================================================================
2219c1621
< Hypothesis AGCS: agree_callee_save ls (parent_locset init_ls cs).
---
> Hypothesis AGCS: agree_callee_save ls (parent_locset cs).
==========================================================================================
2221,2225c1623
< Variable stk: stack.
< Hypothesis SEP: m' |= stack_contents j cs cs' stk.
< Hypothesis init_args: init_args_mach j isg m'.
< Variable curstack: stack.
< Hypothesis CSC: list_prefix init_sg init_stk (stack_blocks_of_callstack tge cs') (tl curstack).
---
> Hypothesis SEP: m' |= stack_contents j cs cs'.
==========================================================================================
2230c1628
<   exists v, extcall_arg rs m' (parent_sp curstack) l v /\ Val.inject j (ls l) v.
---
>   exists v, extcall_arg rs m' (parent_sp cs') l v /\ Val.inject j (ls l) v.
==========================================================================================
2238,2254c1636,1644
<   + destruct TP as [TP|TP].
<     * elim (TP _ H).
<     * subst isg. simpl in *.
<       red in AGCS. rewrite AGCS; auto.
<       edestruct init_args with (rs:=rs) as (v & EQ & INJ); eauto. eexists; split; eauto. constructor. inv EQ.
<       rewrite <- H4. f_equal. unfold init_sp, parent_sp. inv CSC. destr. inv INIT.
<   + simpl in SEP. simpl.
<     assert (slot_valid f Outgoing pos ty = true).
<     { destruct H0. unfold slot_valid, proj_sumbool.
<       rewrite zle_true by omega. rewrite pred_dec_true by auto. reflexivity. }
<     assert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.
<     exploit frame_get_outgoing; eauto. intros (v & A & B).
<     exists v; split.
<     simpl in CSC. inv CSC. rewrite FINDF in H4. repeat destr_in H4. unfold parent_sp. destr.  inv H6.
<     constructor.
<     simpl in H6. subst s0. simpl.
<     unfold current_frame_sp. simpl. rewrite BLOCKS. auto. red in AGCS. rewrite AGCS; auto.
---
> + elim (H1 _ H).
> + simpl in SEP. unfold parent_sp.
>   assert (slot_valid f Outgoing pos ty = true).
>   { destruct H0. unfold slot_valid, proj_sumbool. 
>     rewrite zle_true by omega. rewrite pred_dec_true by auto. reflexivity. }
>   assert (slot_within_bounds (function_bounds f) Outgoing pos ty) by eauto.
>   exploit frame_get_outgoing; eauto. intros (v & A & B).
>   exists v; split.
>   constructor. exact A. red in AGCS. rewrite AGCS; auto.
==========================================================================================
2260c1650
<   exists v, extcall_arg_pair rs m' (parent_sp curstack) p v /\ Val.inject j (Locmap.getpair p ls) v.
---
>   exists v, extcall_arg_pair rs m' (parent_sp cs') p v /\ Val.inject j (Locmap.getpair p ls) v.
==========================================================================================
2276c1666
<       list_forall2 (extcall_arg_pair rs m' (parent_sp curstack)) locs vl
---
>       list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl
==========================================================================================
2288c1678
<       extcall_arguments rs m' (parent_sp curstack) sg vl
---
>       extcall_arguments rs m' (parent_sp cs') sg vl
==========================================================================================
2302c1692
< Variable f: Linear_old.function.
---
> Variable f: Linear.function.
==========================================================================================
2305c1695
< Variable tf: Mach_old.function.
---
> Variable tf: Mach.function.
==========================================================================================
2308d1697
< Variable g: frameinj.
==========================================================================================
2316c1705
< Hypothesis SEP: m' |= frame_contents f j sp' ls ls0 parent retaddr ** minjection j g m ** globalenv_inject ge j.
---
> Hypothesis SEP: m' |= frame_contents f j sp' ls ls0 parent retaddr ** minjection j m ** globalenv_inject ge j.
==========================================================================================
2378,2379d1766
< Section WITHMEMINIT.
< 
2406,2487c1793,1796
< Definition has_at_most_one_antecedent (j: meminj) P :=
<   forall b' o' (EQ: P = Vptr b' o')
<     b1 b2 delta1 delta2
<     (J1: j b1 = Some (b', delta1))
<     (J2: j b2 = Some (b', delta2)),
<     b1 = b2.
< 
< Lemma has_at_most_one_antecedent_incr:
<   forall j j' (INCR: inject_incr j j')
<     m m' (SEP: inject_separated j j' m m')
<     v (HAMOA: has_at_most_one_antecedent j v)
<     (BP: block_prop (Mem.valid_block m') v),
<     has_at_most_one_antecedent j' v.
< Proof.
<   red; intros. subst. red in HAMOA.
<   specialize (HAMOA _ _ eq_refl).
<   destruct (j b1) eqn:?. destruct p.
<   destruct (j b2) eqn:?. destruct p.
<   erewrite INCR in J1; eauto.
<   erewrite INCR in J2; eauto.
<   inv J1; inv J2.
<   eapply HAMOA; eauto.
<   generalize (SEP _ _ _ Heqo0 J2). intros (A & B); elim B. apply BP.
<   generalize (SEP _ _ _ Heqo J1). intros (A & B); elim B. apply BP.
< Qed.
< 
< Opaque Z.mul.
< 
< Program Definition minit_args_mach j sg_ : massert :=
<   {|
<     m_pred := init_args_mach j sg_;
<     m_footprint := fun b o =>
<                      exists sl ofs ty,
<                        In (S sl ofs ty) (regs_of_rpairs (loc_arguments sg_)) /\
<                        exists o', init_sp = Vptr b o' /\
<                              let lo := Ptrofs.unsigned (Ptrofs.add o' (Ptrofs.repr (fe_ofs_arg + 4 * ofs))) in
<                              lo <= o < lo + size_chunk (chunk_of_type ty);
<     m_invar_weak := false;
<     m_invar_stack := false;
<   |}.
< Next Obligation.
<   red; intros.
<   exploit H. eauto. intros (v & EA & INJ).
<   inv EA.
<   eexists; split; eauto. econstructor; eauto.
<   unfold load_stack, Val.offset_ptr, Mem.loadv in *.
<   destruct init_sp eqn:ISP; try discriminate.
<   eapply Mem.load_unchanged_on; eauto.
<   simpl; intros.
<   exists Outgoing, of, ty; split; auto.
<   eexists; split; eauto.
<   Unshelve. eauto.
< Defined.
< Next Obligation.
<   exploit H. eauto.
<   intros (v & EA & INJ). inv EA.
<   unfold load_stack, Val.offset_ptr, Mem.loadv in *.
<   repeat destr_in H12. repeat destr_in Heqv0. inv H5.
<   eapply Mem.load_valid_access in H8.
<   destruct H8.
<   exploit H0. split.
<   apply Zle_refl. destruct H2; simpl; omega.
<   eapply Mem.perm_valid_block; eauto.
<   Unshelve. constructor.
< Defined.
< 
< Definition fn_stack_requirements (i: ident) : Z :=
<   match Genv.find_symbol tge i with
<     Some b =>
<     match Genv.find_funct_ptr tge b with
<     | Some (Internal f) => fn_stacksize f
<     | _ => 0
<     end
<   | None => 0
<   end.
< 
< Variable init_m: mem.
< 
< Inductive match_states: Linear_old.state -> Mach_old.state -> Prop :=
< | match_states_intro:
<     forall sg_ cs f sp c ls m cs' fb sp' rs m' j tf
<         (STACKS: match_stacks j cs cs' f.(Linear_old.fn_sig) sg_)
---
> Inductive match_states: Linear.state -> Mach.state -> Prop :=
>   | match_states_intro:
>       forall cs f sp c ls m cs' fb sp' rs m' j tf
>         (STACKS: match_stacks j cs cs' f.(Linear.fn_sig))
2491c1800
<         (AGLOCS: agree_locs f ls (parent_locset init_ls cs))
---
>         (AGLOCS: agree_locs f ls (parent_locset cs))
2493,2507c1802,1808
<         (INJUNIQUE: forall b delta, j b = Some (sp', delta) -> b = sp)
<         (INJ_INIT_SP: block_prop (fun b => j b = Some (b,0)) init_sp)
<         (HAMOA: has_at_most_one_antecedent j init_sp)
<         (INCR_init: inject_incr (Mem.flat_inj (Mem.nextblock init_m)) j)
<         (INCR_sep: inject_separated (Mem.flat_inj (Mem.nextblock init_m)) j init_m init_m)
<         (MACH: Ple (Mem.nextblock init_m) (Mem.nextblock m'))
<         (TAIL: is_tail c (Linear_old.fn_code f))
<         (SEP: m' |= frame_contents f j sp' ls (parent_locset init_ls cs) (parent_sp (Mem.stack m')) (parent_ra init_ra cs')
<                  ** stack_contents j cs cs' (tl (Mem.stack m'))
<                  ** (mconj (minjection j (flat_frameinj (length (Mem.stack m))) m) (minit_args_mach j sg_))
<                  ** globalenv_inject ge j
<         )
<         (SE: stack_equiv (Mem.stack m) (Mem.stack m')),
<       match_states (Linear_old.State cs f (Vptr sp Ptrofs.zero) c ls m)
<                    (Mach_old.State cs' fb (Vptr sp' Ptrofs.zero) (transl_code (make_env (function_bounds f)) c) rs m')
---
>         (TAIL: is_tail c (Linear.fn_code f))
>         (SEP: m' |= frame_contents f j sp' ls (parent_locset cs) (parent_sp cs') (parent_ra cs')
>                  ** stack_contents j cs cs'
>                  ** minjection j m
>                  ** globalenv_inject ge j),
>       match_states (Linear.State cs f (Vptr sp Ptrofs.zero) c ls m)
>                    (Mach.State cs' fb (Vptr sp' Ptrofs.zero) (transl_code (make_env (function_bounds f)) c) rs m')
2509,2510c1810,1811
<       forall sg_ cs f ls m cs' fb rs m' j tf sz
<         (STACKS: match_stacks j cs cs' (Linear_old.funsig f) sg_)
---
>       forall cs f ls m cs' fb rs m' j tf
>         (STACKS: match_stacks j cs cs' (Linear.funsig f))
2513d1813
<         (SZEQ: exists i, Genv.invert_symbol tge fb = Some i /\ sz = fn_stack_requirements i) 
2515,2526c1815,1820
<         (AGLOCS: agree_callee_save ls (parent_locset init_ls cs))
<         (INCR_init: inject_incr (Mem.flat_inj (Mem.nextblock init_m)) j)
<         (INCR_sep: inject_separated (Mem.flat_inj (Mem.nextblock init_m)) j init_m init_m)
<         (MACH: Ple (Mem.nextblock init_m) (Mem.nextblock m'))
<         (INJ_INIT_SP: block_prop (fun b => j b = Some (b,0)) init_sp)
<         (HAMOA: has_at_most_one_antecedent j init_sp)
<         (SEP: m' |= stack_contents j cs cs' (tl (Mem.stack m'))
<                  ** (mconj (minjection j (flat_frameinj (length (Mem.stack m))) m) (minit_args_mach j sg_))
<                  ** globalenv_inject ge j)
<         (SE: stack_equiv (Mem.stack m) (Mem.stack m'))
<         (* (TTNP: top_tframe_no_perm (Mem.perm m') (Mem.stack m')) *),
<       match_states (Linear_old.Callstate cs f ls m sz) (Mach_old.Callstate cs' fb rs m')
---
>         (AGLOCS: agree_callee_save ls (parent_locset cs))
>         (SEP: m' |= stack_contents j cs cs'
>                  ** minjection j m
>                  ** globalenv_inject ge j),
>       match_states (Linear.Callstate cs f ls m)
>                    (Mach.Callstate cs' fb rs m')
2528,2529c1822,1823
<       forall sg_ cs ls m cs' rs m' j sg
<         (STACKS: match_stacks j cs cs' sg sg_)
---
>       forall cs ls m cs' rs m' j sg
>         (STACKS: match_stacks j cs cs' sg)
2531,3134c1825,1830
<         (AGLOCS: agree_callee_save ls (parent_locset init_ls cs))
<         (INCR_init: inject_incr (Mem.flat_inj (Mem.nextblock init_m)) j)
<         (INCR_sep: inject_separated (Mem.flat_inj (Mem.nextblock init_m)) j init_m init_m)
<         (MACH: Ple (Mem.nextblock init_m) (Mem.nextblock m'))
<         (INJ_INIT_SP: block_prop (fun b => j b = Some (b,0)) init_sp)
<         (HAMOA: has_at_most_one_antecedent j init_sp)
<         (SEP: m' |= stack_contents j cs cs' (tl (Mem.stack m'))
<                  ** (mconj (minjection j (flat_frameinj (length (Mem.stack m))) m) (minit_args_mach j sg_))
<                  ** globalenv_inject ge j)
<         (SE: stack_equiv (Mem.stack m) (Mem.stack m')),
<       match_states (Linear_old.Returnstate cs ls m) (Mach_old.Returnstate cs' rs m').
< 
< (** Record [massert_eqv] and [massert_imp] as relations so that they can be used by rewriting tactics. *)
< Local Add Relation massert massert_imp
<   reflexivity proved by massert_imp_refl
<   transitivity proved by massert_imp_trans
< as massert_imp_prel2.
< 
< Local Add Relation massert massert_eqv
<   reflexivity proved by massert_eqv_refl
<   symmetry proved by massert_eqv_sym
<   transitivity proved by massert_eqv_trans
< as massert_eqv_prel2.
< 
< Lemma sep_rot:
<   forall P Q R S,
<     massert_eqv (P ** Q ** R ** S) (S ** P ** Q ** R).
< Proof.
<   intros.
<   rewrite <- (sep_assoc  Q R), <- (sep_assoc P).
<   rewrite (sep_comm _ S). auto.
< Qed.
< 
< Lemma Ple_Plt:
<   forall a b,
<     (forall c, Plt c a -> Plt c b) ->
<     Ple a b.
< Proof.
<   intros a b H.
<   destruct (peq a xH).
<   + subst a. xomega.
<   + exploit Ppred_Plt; eauto.
<     intros H0.
<     specialize (H _ H0).
<     exploit Pos.succ_pred; eauto.
<     intro K.
<     xomega.
< Qed.
< 
< Lemma eval_addressing_lessdef_strong:
<   forall sp1 sp2 addr vl1 vl2 v1,
<     Val.lessdef_list vl1 vl2 ->
<     Val.lessdef sp1 sp2 ->
<     eval_addressing ge sp1 addr vl1 = Some v1 ->
<     exists v2, eval_addressing ge sp2 addr vl2 = Some v2 /\ Val.lessdef v1 v2.
< Proof.
<   intros. rewrite val_inject_list_lessdef in H.
<   assert (exists v2 : val,
<              eval_addressing ge sp2 addr vl2 = Some v2
<              /\ Val.inject (fun b => Some(b, 0)) v1 v2).
<   eapply eval_addressing_inj with (sp1 := sp1).
<   intros. rewrite <- val_inject_lessdef; auto.
<   rewrite <- val_inject_lessdef; auto.
<   eauto. auto.
<   destruct H2 as [v2 [A B]]. exists v2; split; auto. rewrite val_inject_lessdef; auto.
< Qed.
< 
< Lemma reglist_lessdef rs1 rs2
<       (LESSDEF: forall r, Val.lessdef (rs1 r) (rs2 r))
<       l:
<   Val.lessdef_list (reglist rs1 l) (reglist rs2 l).
< Proof.
<   induction l; simpl; auto.
< Qed.
< 
< Lemma block_prop_impl (P Q: block -> Prop) v:
<   (forall b, P b -> Q b) ->
<   block_prop P v -> block_prop Q v.
< Proof.
<   destruct v; auto. simpl. intuition.
< Qed.
< 
< Lemma map_reg_lessdef rs1 rs2
<       (LESSDEF: forall r: loc, Val.lessdef (rs1 r) (rs2 r))
<       args:
<   Val.lessdef_list (fun p => Locmap.getpair p rs1) ## args (fun p => Locmap.getpair p rs2) ## args.
< Proof.
<   induction args; simpl; auto.
<   constructor; auto.
<   destruct a; simpl; auto.
<   apply Val.longofwords_lessdef; auto.
< Qed.
< 
< Ltac constr_match_states :=
<   econstructor;
<   match goal with
<   | |- _ => idtac
<   end.
< 
< Lemma intv_dec:
<   forall a b c,
<     { a <= b < c } + { b < a \/ b >= c }.
< Proof.
<   clear.
<   intros.
<   destruct (zle a b); destruct (zlt b c); try (right; omega); try (left; omega).
< Qed.
< 
< Section EVAL_BUILTIN_ARG_LESSDEF.
< 
<   Variable A : Type.
<   Variable ge' : Senv.t.
<   Variables rs1 rs2 : A -> val.
<   Hypothesis rs_lessdef: forall a, Val.lessdef (rs1 a) (rs2 a).
<   Variables sp sp' : val.
<   Hypothesis sp_lessdef: Val.lessdef sp sp'.
<   Variable m m' : mem.
<   Hypothesis m_ext: Mem.extends m m'.
< 
< 
<   Lemma eval_builtin_arg_lessdef':
<   forall arg v v'
<     (EBA: eval_builtin_arg ge' rs1 sp m arg v)
<     (EBA': eval_builtin_arg ge' rs2 sp' m' arg v'),
<     Val.lessdef v v'.
<   Proof.
<     induction arg; intros; inv EBA; inv EBA'; subst; auto.
<     - intros. exploit Mem.loadv_extends. eauto. apply H2.
<       2: rewrite H3. simpl. apply Val.offset_ptr_lessdef; auto. intros (v2 & B & C). inv B. auto.
<     - intros; apply Val.offset_ptr_lessdef; auto.
<     - intros. exploit Mem.loadv_extends. eauto.  apply H3.
<       2: rewrite H4. auto. intros (v2 & B & C). inv B. auto.
<     - apply Val.longofwords_lessdef. eauto. eauto.
<   Qed.
< 
<   Lemma eval_builtin_args_lessdef':
<     forall args vl vl'
<       (EBA: eval_builtin_args ge' rs1 sp m args vl)
<       (EBA': eval_builtin_args ge' rs2 sp' m' args vl'),
<       Val.lessdef_list vl vl'.
<   Proof.
<     induction args; simpl; intros. inv EBA; inv EBA'. constructor.
<     inv EBA; inv EBA'. constructor; auto.
<     eapply eval_builtin_arg_lessdef'; eauto.
<   Qed.
< 
< End EVAL_BUILTIN_ARG_LESSDEF.
< 
< Lemma init_args_incr:
<   forall j j' sg m,
<     inject_incr j j' ->
<     init_args_mach j sg m ->
<     init_args_mach j' sg m.
< Proof.
<   red. intros j j' sg m INCR IAM sl of ty IN rs.
<   exploit IAM; eauto. instantiate (1 := rs).
<   intros (v & ea & inj); eexists; split; eauto.
< Qed.
< 
< Lemma footprint_impl:
<   forall P Q Q' b o,
<     (forall b o, m_footprint Q b o -> m_footprint Q' b o) ->
<     m_footprint (P ** Q) b o ->
<     m_footprint (P ** Q') b o.
< Proof.
<   intros.
<   destruct H0.
<   left; auto.
<   right; eauto.
< Qed.
< 
< Lemma init_args_mach_unch:
<   forall j sg m m' P,
<     Mem.unchanged_on P m m' ->
<     (forall b o, init_sp = Vptr b o -> forall i, P b i) ->
<     init_args_mach j sg m ->
<     init_args_mach j sg m'.
< Proof.
<   red. intros j sg m m' P UNCH NSP IAM sl of ty IN rs.
<   exploit IAM; eauto. instantiate (1 := rs).
<   intros (v & ea & inj); eexists; split; eauto.
<   inv ea; econstructor; eauto.
<   destruct init_sp eqn:?; try discriminate.
<   unfold load_stack in *. simpl in *.
<   erewrite Mem.load_unchanged_on; eauto.
< Qed.
< 
< Lemma inject_incr_sep_trans:
<   forall f j j' im im' m m',
<     inject_incr f j ->
<     inject_incr j j' ->
<     inject_separated f j im im' ->
<     inject_separated j j' m m' ->
<     Ple (Mem.nextblock im) (Mem.nextblock m) ->
<     Ple (Mem.nextblock im') (Mem.nextblock m') ->
<     inject_separated f j' im im'.
< Proof.
<   clear.
<   red. intros f j j' im im' m m' INCR INCR' SEP SEP' PLE PLE' b1 b2 delta FB J'B.
<   destruct (j b1) as [ (b & delta') | ] eqn: JB.
<   exploit INCR'. apply JB. rewrite J'B. injection 1. intros; subst.
<   exploit SEP; eauto.
<   exploit SEP'; eauto.
<   unfold Mem.valid_block; intuition xomega.
< Qed.
< 
< Lemma no_stack_slot_size64_0:
<   forall (l : list typ) (z z0 : Z),
<     (forall l0 : loc, In l0 (regs_of_rpairs (loc_arguments_64 l z0 z 0)) -> match l0 with
<                                                                       | R _ => True
<                                                                       | S _ _ _ => False
<                                                                       end) ->
<     size_arguments_64 l z0 z 0 = 0.
< Proof.
<   induction l; intros; eauto.
<   Opaque list_nth_z. simpl in *.
<   destruct a.
<   + destruct (list_nth_z int_param_regs z0).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
<   + destruct (list_nth_z float_param_regs z).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
<   + destruct (list_nth_z int_param_regs z0).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
<   + destruct (list_nth_z float_param_regs z).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
<   + destruct (list_nth_z int_param_regs z0).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
<   + destruct (list_nth_z int_param_regs z0).
<     apply IHl. intros; apply H. simpl. auto.
<     simpl in H. specialize (H _ (or_introl eq_refl)).
<     simpl in H. easy.
< Qed.
< 
< Lemma no_stack_slot_size32_0:
<   forall (l : list typ),
<     (forall l0 : loc, In l0 (regs_of_rpairs (loc_arguments_32 l 0)) -> match l0 with
<                                                                  | R _ => True
<                                                                  | S _ _ _ => False
<                                                                  end) ->
<     size_arguments_32 l 0 = 0.
< Proof.
<   induction l; intros; eauto.
<   simpl in *.
<   destruct a; exploit H;
<     try (apply in_app; left; simpl; auto);
<     simpl; try easy.
< Qed.
< 
< Lemma match_stacks_is_init_sg:
<   forall j cs cs' sg sg',
<     match_stacks j cs cs' sg sg' ->
<     (tailcall_possible sg' /\ size_arguments sg' = 0) \/ sg' = init_sg.
< Proof.
<   induction 1; simpl; intros; eauto.
<   destruct TP; auto.
<   left. split; auto.
<   red in H.
<   revert H.
<   unfold size_arguments, loc_arguments.
<   destruct Archi.ptr64.
<   apply no_stack_slot_size64_0.
<   apply no_stack_slot_size32_0.
< Qed.
< 
< 
< Lemma in_stack_slot_bounds:
<   forall sg of ty,
<     In (S Outgoing of ty) (regs_of_rpairs (loc_arguments sg)) ->
<     fe_ofs_arg <= 4 * of < 4 * size_arguments sg.
< Proof.
<   intros sg of ty IN.
<   generalize (loc_arguments_bounded _ _ _ IN).
<   generalize (typesize_pos ty). 
<   exploit loc_arguments_acceptable_2. apply IN. simpl.
<   unfold fe_ofs_arg. omega.
< Qed.
< 
< Lemma external_call_is_stack_top:
<   forall (ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block),
<     external_call ef ge vargs m1 t vres m2 -> (is_stack_top (Mem.stack m1) b <-> is_stack_top (Mem.stack m2) b).
< Proof.
<   intros.
<   eapply external_call_stack_blocks in H.
<   rewrite ! is_stack_top_stack_blocks. rewrite H. tauto.
< Qed.
< 
< Lemma le_add_pos:
<   forall a b,
<     0 <= b ->
<     a <= a + b.
< Proof.
<   intros; omega.
< Qed.
< 
< (* Lemma fe_ofs_retaddr_fe_size: *)
< (*   forall b, *)
< (*     fe_ofs_retaddr (make_env b) <= fe_size (make_env b). *)
< (* Proof. *)
< (*   destruct b. simpl. *)
< (*   apply le_add_pos.  *)
< (*   destruct Archi.ptr64; omega. *)
< (* Qed. *)
< 
< (* Lemma fe_ofs_retaddr_pos: *)
< (*   forall b, *)
< (*     0 <= fe_ofs_retaddr (make_env b). *)
< (* Proof. *)
< (*   destruct b. *)
< (*   Local Opaque Z.mul. *)
< (*   simpl. *)
< (*   etransitivity. 2: apply align_le; try now (destruct Archi.ptr64; omega). *)
< (*   apply Z.add_nonneg_nonneg; try omega. *)
< (*   etransitivity. 2: apply align_le; try omega. *)
< (*   apply Z.add_nonneg_nonneg; try omega. *)
< (*   etransitivity. 2: apply align_le; try now (destruct Archi.ptr64; omega). *)
< (*   etransitivity. 2: apply size_callee_save_area_incr. *)
< (*   etransitivity. 2: apply align_le; try now (destruct Archi.ptr64; omega). *)
< (*   omega. *)
< (* Qed. *)
< 
< Lemma list_prefix_is_prefix:
<   forall isg istk cs stk,
<     list_prefix isg istk cs stk ->
<     exists l, stk = l ++ istk.
< Proof.
<   induction 1; simpl; intros; eauto.
<   subst. exists nil; reflexivity.
<   destruct IHlist_prefix as (l & EQ); subst.
<   exists ((Some f, r)::l); reflexivity.
< Qed.
< 
< Lemma list_prefix_spec_istk:
<   forall isg istk cs stk,
<     list_prefix isg istk cs stk ->
<     init_sp_stackinfo isg istk.
< Proof.
<   induction 1; simpl; intros; eauto. subst; auto.
< Qed.
< 
< Lemma in_stack'_app:
<   forall s1 s2 b,
<     in_stack' (s1 ++ s2) b <-> in_stack' s1 b \/ in_stack' s2 b.
< Proof.
<   induction s1; simpl; intros; eauto.
<   tauto.
<   rewrite IHs1. tauto.
< Qed.
< 
< Lemma init_sp_csc:
<   forall b o
<     (ISP: init_sp = Vptr b o)
<     s stk
<     (LP: list_prefix init_sg init_stk s stk),
<   exists fi, in_stack' stk (b, fi) /\
<         forall i, (fe_ofs_arg <= i < 4 * size_arguments init_sg)%Z ->
<              frame_private fi i /\ Ptrofs.unsigned (Ptrofs.repr (fe_ofs_arg + i)) = (fe_ofs_arg + i)%Z.
< Proof.
<   intros b o ISP.
<   unfold init_sp, current_sp, current_frame_sp in ISP. repeat destr_in ISP.
<   intros.
<   edestruct list_prefix_is_prefix as (l & EQ); eauto.
<   apply list_prefix_spec_istk in LP.
<   destruct stk. simpl in *. apply app_cons_not_nil in EQ. easy.
<   simpl in *.
<   inv LP. simpl in *. inv Heqo0.
<   exists f0; split.
<   destruct l; simpl in EQ; inv EQ.
<   left. red. simpl. red. rewrite Heql. left; reflexivity.
<   right. rewrite in_stack'_app. right. left. red. simpl. red. rewrite Heql. left; reflexivity.
<   rewrite Heql in PRIV. inv PRIV.
<   intros; eapply PROP; eauto.
< Qed.
< 
< Lemma external_call_step_correct:
<   forall s ef res rs1 m t m' sz
<     (H0 : external_call ef ge (fun p : rpair loc => Locmap.getpair p rs1) ## (loc_arguments (ef_sig ef)) m t res m')
<     (WTS : wt_state init_ls (Linear_old.Callstate s (External ef) rs1 m sz))
<     (LIN : nextblock_properties_linear init_m (Linear_old.Callstate s (External ef) rs1 m sz))
<     cs' fb rs m'0
<     (CSC : call_stack_consistency tge init_sg init_stk (Callstate cs' fb rs m'0))
<     (MACH: Ple (Mem.nextblock init_m) (Mem.nextblock m'0))
<     (* (MACH : nextblock_properties_mach init_sp init_m init_sg (Callstate cs' fb rs m'0)) *)
<     sg_ j tf
<     (STACKS : match_stacks j s cs' (Linear_old.funsig (External ef)) sg_)
<     (TRANSL : transf_fundef (External ef) = OK tf)
<     (FIND : Genv.find_funct_ptr tge fb = Some tf)
<     (AGREGS : agree_regs j rs1 rs)
<     (AGLOCS : agree_callee_save rs1 (parent_locset init_ls s))
<     (INCR_init : inject_incr (Mem.flat_inj (Mem.nextblock init_m)) j)
<     (INCR_sep : inject_separated (Mem.flat_inj (Mem.nextblock init_m)) j init_m init_m)
<     (INJ_INIT_SP : block_prop (fun b : block => j b = Some (b, 0)) init_sp)
<     (HAMOA : has_at_most_one_antecedent j init_sp)
<     (SEP : m'0 |= stack_contents j s cs' (tl (Mem.stack m'0)) ** mconj (minjection j (flat_frameinj (length (Mem.stack m))) m) (minit_args_mach j sg_) ** globalenv_inject ge j)
<     (SE:   stack_equiv (Mem.stack m) (Mem.stack m'0)),
<   exists s2' : state,
<     plus step tge (Callstate cs' fb rs m'0) t s2' /\
<     match_states (Linear_old.Returnstate s (Locmap.setpair (loc_result (ef_sig ef)) res (LTL_old.undef_regs destroyed_at_call rs1)) m') s2'.
< Proof.
<   intros.
<   simpl in TRANSL. inversion TRANSL; subst tf.
<   inv CSC.
<   exploit transl_external_arguments; eauto. apply sep_proj1 in SEP; eauto.
<   { (* init_args_mach *)
<     eapply sep_drop in SEP.
<     eapply mconj_proj2 in SEP.
<     eapply sep_proj1 in SEP.
<     simpl in SEP; eauto.
<   }
<   intros [vl [ARGS VINJ]].
<   assert (SEP_init := SEP).
<   rewrite <- sep_swap12 in SEP. apply mconj_proj1 in SEP.
<   rewrite (sep_comm _ (globalenv_inject _ _)) in SEP.
<   exploit external_call_parallel_rule; eauto.
<   {
<     rewrite stack_contents_invar_weak. reflexivity.
<   }
<   intros (j' & res' & m1' & A &  B & C & D & E).
<   econstructor; split.
<   - apply plus_one. eapply exec_function_external; eauto.
<     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
<   - constr_match_states.
<     eapply match_stacks_change_meminj.
<     3: eexact STACKS.
<     all:eauto.
<     exists m, m'0; split; eauto.
<     + intros; eapply Mem.valid_block_inject_2; eauto. apply sep_proj1 in SEP; simpl in SEP; eauto.
<     + clear - AGREGS D B.
<       apply agree_regs_set_pair. apply agree_regs_undef_regs. apply agree_regs_inject_incr with j; auto. auto.
<     + apply agree_callee_save_set_result; auto.
<       red in AGLOCS |- *. intros.
<       destruct l.
<       rewrite LTL_undef_regs_others. auto.
<       Opaque all_mregs.
<       intro IN.
<       unfold destroyed_at_call in IN.
<       rewrite filter_In in IN.
<       rewrite H in IN. simpl in IN. destruct IN. discriminate.
<       rewrite LTL_undef_regs_slot.
<       auto.
<     + eapply inject_incr_trans; eauto.
<     + eapply inject_incr_sep_trans; eauto. inv LIN; auto.
<     + rewnb. xomega.
<     + revert INJ_INIT_SP D. clear.
<       destruct init_sp; simpl; auto.
<     + assert (ISPVALID: forall b o, init_sp = Vptr b o -> Mem.valid_block m'0 b).
<       {
<         intros.
<         revert INJ_INIT_SP. rewrite H. simpl. intros; eapply Mem.valid_block_inject_2. apply INJ_INIT_SP. apply SEP.
<       }
<       revert MACH HAMOA D E ISPVALID. clear.
<       red; intros.
<       destruct (j b1) eqn:JB1. destruct p.
<       destruct (j b2) eqn:JB2. destruct p.
<       exploit D. eexact JB1.
<       exploit D. eexact JB2.
<       intros. assert (b0 = b' /\ b = b') by (split; congruence). destruct H1; subst.
<       eapply HAMOA; eauto.
<       exploit E; eauto. apply ISPVALID in EQ; intuition congruence.
<       exploit E; eauto. apply ISPVALID in EQ; intuition congruence.
<     + apply stack_contents_change_meminj with j; auto.
<       rewrite sep_swap12.
<       apply mconj_intro.
<       rewrite (sep_comm (stack_contents _ _ _ _)).
<       repeat rewrite_stack_blocks. eauto.
<       split.
<       rewrite sep_swap12 in SEP_init. apply mconj_proj2 in SEP_init.
<       apply sep_proj1 in SEP_init. revert SEP_init.
<       * simpl.
<         intro IAM.
<         red; intros.
<         exploit IAM. eauto. instantiate (1 := rs0).
<         destruct (match_stacks_is_init_sg _ _ _ _ _ STACKS) as [[TP _] | EQsig].
<         apply TP in H. easy. subst.
<         intros (v & ea & inj); eexists; split; eauto.
<         inv ea; constructor; eauto.
<         clearbody step. destruct init_sp eqn:?; simpl in *; try discriminate.
<         revert Heqv0.
<         unfold load_stack in *; simpl in *.
<         intros; eapply Mem.load_unchanged_on; eauto.
<         eapply external_call_unchanged_on. apply A.
<         intros. simpl.
<         intros [IST | NPSA].
<         { revert IST.
<           inv TTNP. unfold is_stack_top. simpl. unfold get_frames_blocks.
<           rewrite H3. easy.
<         }
<         unfold public_stack_access in NPSA.
<         edestruct init_sp_csc as (fi & INS & PRIV); eauto.
<         unfold get_frame_info in NPSA.
<         rewrite in_stack'_rew in INS. destruct INS as (tf & IFR & INS).
<         rewrite in_frames'_rew in IFR. destruct IFR as (fr & IFR & IFRS).
<         erewrite get_assoc_stack_lnr in NPSA; eauto.
<         assert (i = Ptrofs.zero).
<         {
<           revert Heqv0. clear.
<           unfold init_sp, parent_sp, current_sp, current_frame_sp. repeat destr; inversion 1.
<         } subst.
<         rewrite Ptrofs.add_zero_l in H1.
<         red in NPSA.
<         2: apply Mem.stack_norepet.
<         2: apply In_tl; auto.
<         specialize (NPSA i0).
<         trim (NPSA). omega.
<         unfold fe_ofs_arg in PRIV. simpl in PRIV.
<         rewrite (fun pf => proj2 (PRIV (4 * of) pf)) in H1.
<         red in NPSA. contradict NPSA. setoid_rewrite (fun pf => proj1 (PRIV _ pf)). congruence.
<         split. etransitivity. 2: apply H1.
<         exploit loc_arguments_acceptable_2. apply H. simpl. omega.
<         eapply Z.lt_le_trans. apply H1.
<         generalize (loc_arguments_bounded _ _ _ H).
<         generalize (typesize_pos ty).
<         exploit loc_arguments_acceptable_2. apply H. simpl.
<         rewrite size_type_chunk. rewrite typesize_typesize.
<         omega.
<         split.
<         exploit loc_arguments_acceptable_2. apply H. simpl. omega.
<         generalize (loc_arguments_bounded _ _ _ H).
<         generalize (typesize_pos ty).
<         exploit loc_arguments_acceptable_2. apply H. simpl. omega.
<       * repeat rewrite_stack_blocks.
<         split. apply sep_proj2 in C. rewrite sep_comm in C. eauto.
<         rewrite sep_swap12 in SEP_init.
<         apply mconj_proj2 in SEP_init.
<         destruct SEP_init as (A1 & A2 & A3).
<         revert A3.
<         clear - D. red; simpl.
<         intros. decompose [ex and] H. clear H.
<         exploit A3. simpl. repeat eexists; eauto.
<         revert H0.
<         eapply footprint_impl.
<         simpl. auto. auto.
<     + repeat rewrite_stack_blocks. eauto.
< Qed.
< 
< Lemma fe_ofs_local_pos:
<   forall b,
<     0 <= fe_ofs_local (make_env b).
< Proof.
<   destruct b.
<   Local Opaque Z.mul .
<   simpl.
<   etransitivity. 2: apply align_le ; try omega.
<   etransitivity. 2: apply size_callee_save_area_incr.
<   etransitivity. 2: apply align_le; try omega. simpl. omega. destruct Archi.ptr64; omega.
< Qed.
< 
< (* Lemma fe_ofs_local_fe_size: *)
< (*   forall b, *)
< (*     fe_ofs_local (make_env b) <= fe_size (make_env b). *)
< (* Proof. *)
< (*   destruct b. simpl. *)
< (*   etransitivity. 2: apply le_add_pos. *)
< (*   etransitivity. 2: apply align_le.  *)
< (*   etransitivity. 2: apply le_add_pos. *)
< (*   etransitivity. 2: apply align_le. *)
< (*   apply le_add_pos. omega. omega. *)
< (*   omega. *)
< (*   destruct Archi.ptr64; omega. *)
< (*   destruct Archi.ptr64; omega. *)
< (* Qed. *)
< 
< 
< Transparent fe_ofs_arg.
< 
< Lemma fe_retaddr_lt_fe_size:
<   forall b, fe_ofs_retaddr (make_env b) < fe_size (make_env b).
< Proof.
<   simpl. intros.
<   destr; omega.
< Qed.
< 
< Lemma tailcall_stage_rule:
<   forall m1 m1' m2 j g P,
<     m2 |= minjection j g m1 ** P ->
<     Mem.tailcall_stage m1 = Some m1' ->
<     Mem.top_frame_no_perm m2 ->
<     m_invar_stack P = false ->
<     exists m2', Mem.tailcall_stage m2 = Some m2' /\
<            m2' |= minjection j g m1' ** P.
< Proof.
<   intros m1 m1' m2 j g P SEP TC TFNP INVAR.
<   exploit Mem.tailcall_stage_inject; eauto. apply SEP. intros (m2' & TC' & INJ').
<   eexists; split; eauto.
<   destruct SEP as (INJ & PM & DISJ).
<   split; [|split].
<   - simpl in *. auto.
<   - eapply m_invar. eauto.
<     destruct (m_invar_weak P); eauto using Mem.strong_unchanged_on_weak, Mem.tailcall_stage_unchanged_on.
<     congruence.
<   - red; intros. eapply DISJ. 2: eauto. simpl in H |- *.
<     decompose [ex and] H.
<     repeat eexists;  eauto.
<     revert H3; rewrite_perms. auto.
< Qed.
---
>         (AGLOCS: agree_callee_save ls (parent_locset cs))
>         (SEP: m' |= stack_contents j cs cs'
>                  ** minjection j m
>                  ** globalenv_inject ge j),
>       match_states (Linear.Returnstate cs ls m)
>                   (Mach.Returnstate cs' rs m').
3137,3143c1833,1834
<   forall s1 t s2, Linear_old.step fn_stack_requirements init_ls ge s1 t s2 ->
<              forall (WTS: wt_state init_ls s1) s1'
<                (LIN: nextblock_properties_linear init_m s1)
<                (* (MACH: nextblock_properties_mach init_sp init_m init_sg s1') *)
<                (CSC: call_stack_consistency tge init_sg init_stk s1')
<                (HC: has_code return_address_offset tge s1')
<                (MS: match_states s1 s1'),
---
>   forall s1 t s2, Linear.step ge s1 t s2 ->
>   forall (WTS: wt_state s1) s1' (MS: match_states s1 s1'),
3146c1837,1838
<   induction 1; intros; inv MS; (try congruence);
---
>   induction 1; intros;
>   try inv MS;
3152,3273c1844,1908
<   - (* Lgetstack *)
<     destruct BOUND as [BOUND1 BOUND2].
<     exploit wt_state_getstack; eauto. intros SV.
<     unfold destroyed_by_getstack; destruct sl.
<     + (* Lgetstack, local *)
<       exploit frame_get_local; eauto. intros (v & A & B).
<       econstructor; split.
<       apply plus_one. apply exec_Mgetstack. exact A.
<       constr_match_states.
<       4: apply agree_regs_set_reg; eauto.
<       4: apply agree_locs_set_reg; eauto.
<       all: eauto with mem.
<       eapply is_tail_cons_left; eauto.
< 
<     + (* Lgetstack, incoming *)
<       unfold slot_valid in SV. InvBooleans.
<       exploit incoming_slot_in_parameters; eauto. intros IN_ARGS.
<       inversion STACKS; clear STACKS.
<       subst. destruct TP as [TP | TP] .
<       * elim (TP _ IN_ARGS).
<       * assert (init_args_mach j init_sg m') as INIT_ARGS_MACH.
<         {
<           apply sep_proj2 in SEP. apply sep_proj2 in SEP.
<           apply sep_proj1 in SEP. destruct SEP. simpl in H; subst; auto.
<         }
<         (* exploit frame_get_parent; eauto. *)
<         (* intro PARST.  *)
<         Opaque Z.mul bound_outgoing.
<         subst.
<         generalize (INIT_ARGS_MACH _ _ _ IN_ARGS rs0). intros (v & EA & EAinj).
<         esplit.
<         -- split.
<            ++ eapply plus_one.
<               econstructor; eauto. inv EA. inv CSC. inv CallStackConsistency. simpl. inv REC. unfold init_sp in H4. eauto.
<            ++ constr_match_states.
<               constructor; auto. all: eauto with mem.
<               ** apply agree_regs_set_reg; auto.
<                  change (rs0 # temp_for_parent_frame <- Vundef)
<                  with (undef_regs (destroyed_by_getstack Incoming) rs0).
<                  eapply agree_regs_undef_regs; eauto.
<                  erewrite agree_incoming. eauto. eauto. eauto.
<               ** apply agree_locs_set_reg; eauto.
<                  apply agree_locs_set_reg; eauto.
<                  apply caller_save_reg_within_bounds.
<                  reflexivity.
<               ** eapply is_tail_cons_left; eauto.
< 
<       * subst sg isg.
<         subst s cs'.
<         exploit frame_get_outgoing.
<         apply sep_proj2 in SEP. simpl in SEP. rewrite sep_assoc in SEP. eexact SEP.
<         eapply ARGS; eauto.
<         eapply slot_outgoing_argument_valid; eauto.
<         intros (v & A & B).
<         econstructor; split.
<         -- apply plus_one. eapply exec_Mgetparam; eauto.
<            inv CSC. inv CallStackConsistency. simpl. rewrite FINDF in REC. repeat destr_in REC. simpl.
<            unfold current_frame_sp. simpl.
<            rewrite BLOCKS0. eauto.
<         -- constr_match_states.
<            now (econstructor; eauto).
<            all: eauto.
<            ++ apply agree_regs_set_reg; auto.
<               change (rs0 # temp_for_parent_frame <- Vundef)
<               with (undef_regs (destroyed_by_getstack Incoming) rs0).
<               eapply agree_regs_undef_regs; eauto.
<               erewrite agree_incoming. eauto. eauto. eauto.
<            ++ apply agree_locs_set_reg; eauto.
<               apply agree_locs_set_reg; eauto.
<               apply caller_save_reg_within_bounds.
<               reflexivity.
<            ++ eapply is_tail_cons_left; eauto.
< 
<     + (* Lgetstack, outgoing *)
<       exploit frame_get_outgoing; eauto. intros (v & A & B).
<       econstructor; split.
<       apply plus_one. apply exec_Mgetstack. exact A.
<       constr_match_states. all: eauto with coqlib.
<       apply agree_regs_set_reg; auto.
<       apply agree_locs_set_reg; auto.
< 
<   - (* Lsetstack *)
<     assert (is_stack_top (Mem.stack m') sp') as IST.
<     {
<       unfold is_stack_top, get_stack_top_blocks.
<       inv CSC. inv CallStackConsistency.
<       unfold get_frames_blocks, get_frame_blocks. simpl. unfold get_frame_blocks.
<       rewrite BLOCKS. simpl. auto.
<     }
<     exploit wt_state_setstack; eauto. intros (SV & SW).
<     set (ofs' := match sl with
<                  | Local => offset_local (make_env (function_bounds f)) ofs
<                  | Incoming => 0 (* dummy *)
<                  | Outgoing => offset_arg ofs
<                  end).
<     eapply frame_undef_regs with (rl := destroyed_by_setstack ty) in SEP.
<     assert (A: exists m'',
<                store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) = Some m''
<                /\ m'' |= frame_contents f j sp' (Locmap.set (S sl ofs ty) (rs (R src))
<                                                            (LTL_old.undef_regs (destroyed_by_setstack ty) rs))
<                      (parent_locset init_ls s) (parent_sp (Mem.stack m')) (parent_ra init_ra cs')
<                      ** stack_contents j s cs' (tl (Mem.stack m')) ** (mconj (minjection j (flat_frameinj (length (Mem.stack m))) m) (minit_args_mach j sg_)) ** globalenv_inject ge j
<            ).
<     {
<       unfold ofs'; destruct sl; try discriminate.
<       - eapply frame_set_local; eauto. left; auto.
<       - eapply frame_set_outgoing; eauto. left; auto.
<     }
<     clear SEP; destruct A as (m'' & STORE & SEP).
<     econstructor; split.
<     + apply plus_one. destruct sl; try discriminate.
<       econstructor. eexact STORE.
<       eauto.
<       econstructor. eexact STORE.
<       eauto.
<     + constr_match_states. all: eauto with coqlib. 
<       * apply agree_regs_set_slot. apply agree_regs_undef_regs. auto.
<       * apply agree_locs_set_slot. apply agree_locs_undef_locs. auto. apply destroyed_by_setstack_caller_save. auto.
<       * unfold store_stack in *; rewnb; auto.
<       * unfold store_stack in *; simpl in *; rewrite_stack_blocks; eauto.
<       * unfold store_stack in *; simpl in *; rewrite_stack_blocks; eauto.
<   
---
> - (* Lgetstack *)
>   destruct BOUND as [BOUND1 BOUND2].
>   exploit wt_state_getstack; eauto. intros SV.
>   unfold destroyed_by_getstack; destruct sl.
> + (* Lgetstack, local *)
>   exploit frame_get_local; eauto. intros (v & A & B).
>   econstructor; split.
>   apply plus_one. apply exec_Mgetstack. exact A.
>   econstructor; eauto with coqlib.
>   apply agree_regs_set_reg; auto.
>   apply agree_locs_set_reg; auto.
> + (* Lgetstack, incoming *)
>   unfold slot_valid in SV. InvBooleans.
>   exploit incoming_slot_in_parameters; eauto. intros IN_ARGS.
>   inversion STACKS; clear STACKS.
>   elim (H1 _ IN_ARGS).
>   subst s cs'.
>   exploit frame_get_outgoing.
>   apply sep_proj2 in SEP. simpl in SEP. rewrite sep_assoc in SEP. eexact SEP.
>   eapply ARGS; eauto.
>   eapply slot_outgoing_argument_valid; eauto.
>   intros (v & A & B).
>   econstructor; split.
>   apply plus_one. eapply exec_Mgetparam; eauto. 
>   rewrite (unfold_transf_function _ _ TRANSL). unfold fn_link_ofs.
>   eapply frame_get_parent. eexact SEP.
>   econstructor; eauto with coqlib. econstructor; eauto.
>   apply agree_regs_set_reg. apply agree_regs_set_reg. auto. auto.
>   erewrite agree_incoming by eauto. exact B.
>   apply agree_locs_set_reg; auto. apply agree_locs_undef_locs; auto.
> + (* Lgetstack, outgoing *)
>   exploit frame_get_outgoing; eauto. intros (v & A & B).
>   econstructor; split.
>   apply plus_one. apply exec_Mgetstack. exact A.
>   econstructor; eauto with coqlib.
>   apply agree_regs_set_reg; auto.
>   apply agree_locs_set_reg; auto.
> 
> - (* Lsetstack *)
>   exploit wt_state_setstack; eauto. intros (SV & SW).
>   set (ofs' := match sl with
>                | Local => offset_local (make_env (function_bounds f)) ofs
>                | Incoming => 0 (* dummy *)
>                | Outgoing => offset_arg ofs
>                end).
>   eapply frame_undef_regs with (rl := destroyed_by_setstack ty) in SEP.
>   assert (A: exists m'',
>               store_stack m' (Vptr sp' Ptrofs.zero) ty (Ptrofs.repr ofs') (rs0 src) = Some m''
>            /\ m'' |= frame_contents f j sp' (Locmap.set (S sl ofs ty) (rs (R src))
>                                                (LTL.undef_regs (destroyed_by_setstack ty) rs))
>                                             (parent_locset s) (parent_sp cs') (parent_ra cs')
>                   ** stack_contents j s cs' ** minjection j m ** globalenv_inject ge j).
>   { unfold ofs'; destruct sl; try discriminate.
>     eapply frame_set_local; eauto.
>     eapply frame_set_outgoing; eauto. }
>   clear SEP; destruct A as (m'' & STORE & SEP).
>   econstructor; split.
>   apply plus_one. destruct sl; try discriminate.
>     econstructor. eexact STORE. eauto.
>     econstructor. eexact STORE. eauto.
>   econstructor. eauto. eauto. eauto. 
>   apply agree_regs_set_slot. apply agree_regs_undef_regs. auto.
>   apply agree_locs_set_slot. apply agree_locs_undef_locs. auto. apply destroyed_by_setstack_caller_save. auto.
>   eauto. eauto with coqlib. eauto.
> 
3275,3287c1910,1917
<   assert (OP_INJ:
<             exists v',
<               eval_operation ge (Vptr sp' Ptrofs.zero)
<                              (transl_op (make_env (function_bounds f)) op) rs0##args m' = Some v' /\
<               Val.inject j v v').
<   {
<     eapply eval_operation_inject; eauto.
<     eapply globalenv_inject_preserves_globals. eapply sep_proj2. eapply sep_proj2.
<     eapply sep_proj2. eexact SEP.
<     eapply agree_reglist; eauto.
<     apply sep_proj2 in SEP. apply sep_proj2 in SEP. apply sep_proj1 in SEP. apply SEP.
<   }
<   destruct OP_INJ as [v' [A B]].
---
>   assert (exists v',
>           eval_operation ge (Vptr sp' Ptrofs.zero) (transl_op (make_env (function_bounds f)) op) rs0##args m' = Some v'
>        /\ Val.inject j v v').
>   eapply eval_operation_inject; eauto.
>   eapply globalenv_inject_preserves_globals. eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
>   eapply agree_reglist; eauto.
>   apply sep_proj2 in SEP. apply sep_proj2 in SEP. apply sep_proj1 in SEP. exact SEP.
>   destruct H0 as [v' [A B]].
3289,3296c1919,1926
<   + apply plus_one. econstructor.
<     instantiate (1 := v'). rewrite <- A. apply eval_operation_preserved.
<     exact symbols_preserved. eauto.
<   + constr_match_states. all: eauto with coqlib.
<     * apply agree_regs_set_reg; auto.
<       rewrite transl_destroyed_by_op.  apply agree_regs_undef_regs; auto.
<     * apply agree_locs_set_reg; auto. apply agree_locs_undef_locs. auto. apply destroyed_by_op_caller_save.
<     * apply frame_set_reg. apply frame_undef_regs. exact SEP.
---
>   apply plus_one. econstructor.
>   instantiate (1 := v'). rewrite <- A. apply eval_operation_preserved.
>   exact symbols_preserved. eauto.
>   econstructor; eauto with coqlib.
>   apply agree_regs_set_reg; auto.
>   rewrite transl_destroyed_by_op.  apply agree_regs_undef_regs; auto.
>   apply agree_locs_set_reg; auto. apply agree_locs_undef_locs. auto. apply destroyed_by_op_caller_save.
>   apply frame_set_reg. apply frame_undef_regs. exact SEP. 
3299,3310c1929,1935
<   assert (ADDR_INJ:
<             exists a',
<               eval_addressing ge (Vptr sp' Ptrofs.zero)
<                               (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a' /\
<               Val.inject j a a').
<   {
<     eapply eval_addressing_inject; eauto.
<     eapply globalenv_inject_preserves_globals.
<     eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
<     eapply agree_reglist; eauto.
<   }
<   destruct ADDR_INJ as [a' [A B]].
---
>   assert (exists a',
>           eval_addressing ge (Vptr sp' Ptrofs.zero) (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a'
>        /\ Val.inject j a a').
>   eapply eval_addressing_inject; eauto.
>   eapply globalenv_inject_preserves_globals. eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
>   eapply agree_reglist; eauto.
>   destruct H1 as [a' [A B]].
3312c1937
<   apply sep_proj2 in SEP. apply sep_proj2 in SEP. apply sep_proj1 in SEP. apply SEP.
---
>   apply sep_proj2 in SEP. apply sep_proj2 in SEP. apply sep_proj1 in SEP. eexact SEP.
3316,3322c1941,1947
<   + apply plus_one. econstructor.
<     instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
<     eexact C. eauto.
<   + constr_match_states. all: eauto with coqlib.
<     * apply agree_regs_set_reg. rewrite transl_destroyed_by_load. apply agree_regs_undef_regs; auto. auto.
<     * apply agree_locs_set_reg. apply agree_locs_undef_locs. auto. apply destroyed_by_load_caller_save. auto.
<       
---
>   apply plus_one. econstructor.
>   instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
>   eexact C. eauto.
>   econstructor; eauto with coqlib.
>   apply agree_regs_set_reg. rewrite transl_destroyed_by_load. apply agree_regs_undef_regs; auto. auto.
>   apply agree_locs_set_reg. apply agree_locs_undef_locs. auto. apply destroyed_by_load_caller_save. auto. 
> 
3324,3335c1949,1955
<   assert (STORE_INJ:
<             exists a',
<               eval_addressing ge (Vptr sp' Ptrofs.zero)
<                               (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a' /\
<               Val.inject j a a').
<   {
<     eapply eval_addressing_inject; eauto.
<     eapply globalenv_inject_preserves_globals.
<     eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
<     eapply agree_reglist; eauto.
<   }
<   destruct STORE_INJ as [a' [A B]].
---
>   assert (exists a',
>           eval_addressing ge (Vptr sp' Ptrofs.zero) (transl_addr (make_env (function_bounds f)) addr) rs0##args = Some a'
>        /\ Val.inject j a a').
>   eapply eval_addressing_inject; eauto.
>   eapply globalenv_inject_preserves_globals. eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
>   eapply agree_reglist; eauto.
>   destruct H1 as [a' [A B]].
3337,3343c1957,1958
<   exploit storev_parallel_rule.
<   eapply mconj_proj1. eexact SEP.
<   eauto.
<   eauto.
<   apply AGREGS.
<   rename SEP into SEP_init.
<   intros (m1' & C & SEP).
---
>   exploit storev_parallel_rule. eexact SEP. eauto. eauto. apply AGREGS. 
>   clear SEP; intros (m1' & C & SEP).
3346,3455c1961,1968
<   + apply plus_one. econstructor.
<     instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
<     eexact C.
<     eauto.
<   + destruct a, a'; try discriminate. simpl in *. constr_match_states. all: eauto with coqlib.
<     * rewrite transl_destroyed_by_store. apply agree_regs_undef_regs; auto.
<     * apply agree_locs_undef_locs. auto. apply destroyed_by_store_caller_save.
<     * rewnb. auto.
<     * eapply frame_undef_regs; eauto.
<       rewrite sep_swap23, sep_swap12.
<       rewrite sep_swap23, sep_swap12 in SEP.
<       apply mconj_intro. repeat rewrite_stack_blocks. eauto.
<       split; [|split].
<       2: eapply sep_proj2; eauto.
<       -- simpl. red; simpl. intros sl of ty IN rs2 .
<          exploit mconj_proj2. eexact SEP_init. intro D; apply sep_proj1 in D.
<          simpl in D. red in D. generalize IN; intro IN'. eapply D with (rs := rs2) in IN.
<          clear D. destruct IN as (v & EA' & INJ).
<          inv EA'.
<          eexists; split; eauto. constructor.
<          unfold load_stack in H5 |- *. clear SEP_init.
<          clearbody step.
<          destruct init_sp eqn:?; simpl in *; try discriminate.
<          erewrite Mem.load_store_other. eauto. eauto.
<          inversion B. subst i0 b3 ofs1 b4 ofs2.
<          destruct (eq_block b1 b2); auto.
<          assert (b0 = b1).
<          clear - H4 e INJ_INIT_SP HAMOA MACH external_calls_prf. subst.
<          eapply HAMOA; eauto.
<          subst b1. subst b0. assert (delta = 0) by congruence. subst delta.
<          rewrite Ptrofs.add_zero in *.
<          destruct (zle (Ptrofs.unsigned (Ptrofs.add i1 (Ptrofs.repr (4*of))) + size_chunk (chunk_of_type ty))
<                        (Ptrofs.unsigned i)); auto.
<          destruct (zle (Ptrofs.unsigned i + size_chunk chunk)
<                        (Ptrofs.unsigned (Ptrofs.add i1 (Ptrofs.repr (4 * of))))); auto.
<          eapply Mem.store_valid_access_3 in C. destruct C as (C1 & C2 & C3).
<          specialize (C3 (perm_refl _)). red in C3.
< 
<          inv CSC. inv CallStackConsistency. edestruct init_sp_csc as (fi' & INS & PRIV); eauto.
<          unfold public_stack_access in C3.
<          rewrite in_stack'_rew in INS.
<          setoid_rewrite in_frames'_rew in INS.
<          destruct INS as (ttf & (fr & IN1 & IN2) & IN3).
<          erewrite get_assoc_stack_lnr in C3; eauto.
<          2: apply Mem.stack_norepet.
<          2: apply In_tl; rewrite <- H7; simpl; auto.
<          destruct C3 as [IST | C3].
<          {
<            exfalso.
<            exploit Mem.stack_norepet. rewrite <- H7 in *. clear - IN1 IN2 IN3 IST.
<            intro ND. inv ND.
<            red in IST. simpl in IST.
<            eapply H2. apply IST.
<            eapply in_frames_in_stack; eauto.
<            eapply in_frame_in_frames; eauto.
<            eapply in_frame'_in_frame; eauto.
<          }
<          destruct (match_stacks_is_init_sg _ _ _ _ _ STACKS).
<          generalize (loc_arguments_bounded _ _ _ IN').
<          generalize (typesize_pos ty). destruct H1. rewrite H2.
<          intros.
<          exploit loc_arguments_acceptable_2. apply IN'. simpl.
<          omega.
<          subst sg_.
<          assert (i1 = Ptrofs.zero).
<          {
<            clear - Heqv0. unfold init_sp, parent_sp, current_sp, current_frame_sp in Heqv0.
<            repeat destr_in Heqv0.
<          } subst i1.
<          cut (exists o,
<                  Ptrofs.unsigned i <= o < Ptrofs.unsigned i + size_chunk chunk /\
<                  (fe_ofs_arg + 4 * of) <= o <
<                  (fe_ofs_arg + 4 * of) + size_chunk (chunk_of_type ty)).
<          intros (o & RNG1 & RNG2).
<          exfalso.
<          red in C3. red in C3.
<          specialize (C3 o RNG1).
<          setoid_rewrite (proj1 (PRIV _ _)) in C3. congruence.
<          split. etransitivity. 2: apply RNG2.
<          exploit loc_arguments_acceptable_2. apply IN'. simpl.
<          generalize (loc_arguments_bounded _ _ _ IN').
<          generalize (match_stacks_size_args' _ _ _ _ _ STACKS). 
<          intros. simpl.
<          Transparent fe_ofs_arg.
<          unfold fe_ofs_arg. omega.
<          eapply Z.lt_le_trans. apply RNG2.
<          generalize (loc_arguments_bounded _ _ _ IN').
<          generalize (typesize_pos ty).
<          exploit loc_arguments_acceptable_2. apply IN'. simpl.
<          rewrite size_type_chunk. rewrite typesize_typesize.
<          omega.
<          simpl.
<          rewrite Ptrofs.add_zero_l in *.
<          exists (Z.max (Ptrofs.unsigned i) (Ptrofs.unsigned (Ptrofs.repr (4*of)))).
<          repeat split.
<          apply Zmax_bound_l. omega.
<          rewrite Zmax_spec. destruct (zlt _ _). generalize (size_chunk_pos chunk); omega. omega.
<          apply Zmax_bound_r.
<          setoid_rewrite (proj2 (PRIV _ _)). simpl. omega.
<          eapply in_stack_slot_bounds; eauto.
<          rewrite Zmax_spec. destruct (zlt _ _).
<          setoid_rewrite (proj2 (PRIV _ _)) in g. simpl in g. omega.
<          eapply in_stack_slot_bounds; eauto.
<          setoid_rewrite (proj2 (PRIV _ _)). simpl. generalize (size_chunk_pos (chunk_of_type ty)). omega.
<          eapply in_stack_slot_bounds; eauto.
<       -- repeat rewrite_stack_blocks; eauto.
<       -- apply mconj_proj2 in SEP_init.
<          apply sep_swap23 in SEP_init. destruct SEP_init as (A1 & A2 & A3).
<          revert A3. repeat rewrite_stack_blocks. eauto.
<     * repeat rewrite_stack_blocks; eauto.
---
>   apply plus_one. econstructor.
>   instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
>   eexact C. eauto.
>   econstructor. eauto. eauto. eauto. 
>   rewrite transl_destroyed_by_store. apply agree_regs_undef_regs; auto.
>   apply agree_locs_undef_locs. auto. apply destroyed_by_store_caller_save.
>   auto. eauto with coqlib.
>   eapply frame_undef_regs; eauto.
3459c1972
<   eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
---
>     eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
3464,3485d1976
<   assert (SEP' :
<             Mem.push_new_stage m' |=
<                                frame_contents f j sp' rs (parent_locset init_ls s) (parent_sp (Mem.stack (Mem.push_new_stage m')))
<                                (parent_ra init_ra cs') **
<                                stack_contents j s cs' (tl (Mem.stack m')) **
<                                mconj (minjection j (flat_frameinj (length (Mem.stack (Mem.push_new_stage m)))) (Mem.push_new_stage m)) (minit_args_mach j sg_) **
<                                globalenv_inject ge j).
<   {
<     repeat rewrite_stack_blocks.
<     rewrite sep_swap3 in SEP |- *.
<     eapply frame_mconj. apply SEP.
<     apply mconj_proj1 in SEP.
<     apply push_rule in SEP.
<     eapply sep_imp. apply SEP.
<     red; split; auto. split; auto. 
<     rewrite ! m_invar_stack_sepconj.
<     rewrite stack_contents_invar_stack.
<     rewrite frame_contents_invar_stack.
<     reflexivity.
<     eapply m_invar. apply mconj_proj2 in SEP. apply SEP. simpl.
<     eapply Mem.strong_unchanged_on_weak, Mem.push_new_stage_unchanged_on. simpl. congruence.
<   }
3487,3521c1978,1986
<   + apply plus_one. econstructor; eauto.
<   + constr_match_states; eauto.
<     * econstructor; eauto with coqlib.
<       apply Val.Vptr_has_type.
<       intros; red.
<       apply Zle_trans with (size_arguments (Linear_old.funsig f')); auto.
<       apply loc_arguments_bounded; auto.
<       etransitivity. apply Z.mul_le_mono_nonneg_l. omega. apply BOUND.
<       etransitivity. 2: eapply size_no_overflow; eauto.
<       transitivity (fe_stack_data (make_env (function_bounds f))).
<       generalize (frame_env_separated' (function_bounds f)). simpl. clear. intros. decompose [and] H.
<       change (Z.max (max_over_instrs f outgoing_space) (max_over_slots_of_funct f outgoing_slot) ) with
<       (bound_outgoing (function_bounds f)).
<       etransitivity.
<       2: apply H6. apply align_le. destruct Archi.ptr64; omega.
<       generalize (frame_env_range (function_bounds f)).
<       generalize (bound_stack_data_pos (function_bounds f)). simpl.
<       omega.
<     * exists id; split; auto.
<       destruct ros; simpl in *; eauto.
<       repeat destr_in A.
<       destruct IFI as (bb & oo & IFI & IFI').
<       exploit globalenv_inject_preserves_globals. apply SEP. intros (MPG1 & MPG2 & MPG3).
<       generalize (AGREGS m0).
<       rewrite IFI, Heqv. inversion 1; subst.
<       erewrite MPG1 in H4; eauto. inv H4.
<       eapply Genv.find_invert_symbol; eauto.
<       rewrite symbols_preserved; eauto.
<       subst. 
<       eapply Genv.find_invert_symbol; eauto.
<     * simpl; red; auto.
<     * rewnb; auto.
<     * simpl. rewrite sep_assoc. revert SEP'. repeat rewrite_stack_blocks. auto.
<     * repeat rewrite_stack_blocks; eauto.
<       repeat constructor. auto.
---
>   apply plus_one. econstructor; eauto.
>   econstructor; eauto.
>   econstructor; eauto with coqlib.
>   apply Val.Vptr_has_type.
>   intros; red.
>     apply Zle_trans with (size_arguments (Linear.funsig f')); auto.
>     apply loc_arguments_bounded; auto.
>   simpl; red; auto.
>   simpl. rewrite sep_assoc. exact SEP.
3524,3526c1989
<   rewrite (sep_swap (stack_contents j s cs' _)) in SEP.
<   inv CSC. rewrite FIND in FIND0; inv FIND0.
<   rename tf0 into tf. 
---
>   rewrite (sep_swap (stack_contents j s cs')) in SEP.
3528,3542c1991
<   2: rewrite sep_swap12. 2: eapply mconj_proj1. 2:rewrite sep_swap12. 2: eauto.
<   rewrite m_invar_stack_sepconj. rewrite stack_contents_invar_stack. reflexivity.
<   rename SEP into SEP_init.
<   intros (rs1 & m1' & Q & R & S & T & U & SEP & SE').
< 
<   edestruct tailcall_stage_rule as (m2' & TC' & SEP'); eauto.
<   {
<     inv CallStackConsistency.
<     eapply Mem.free_top_tframe_no_perm; eauto.
<     unfold frame_info_of_size_and_pubrange in FRAME; repeat destr_in FRAME. simpl frame_size.
<     rewrite (unfold_transf_function _ _ TRANSL).  Opaque fe_size. simpl. symmetry; apply Z.max_r.
<     generalize (fe_size_pos (function_bounds f)). simpl. omega.
<   }
<   rewrite m_invar_stack_sepconj. rewrite stack_contents_invar_stack. reflexivity.
<   clear SEP; rename SEP' into SEP.
---
>   clear SEP. intros (rs1 & m1' & P & Q & R & S & T & U & SEP).
3545c1994
<   eapply sep_proj2. eapply sep_proj2. eexact SEP.
---
>     eapply sep_proj2. eapply sep_proj2. eexact SEP.
3548,3621c1997,2000
<   + eapply plus_right. eexact S. econstructor; eauto.
<     rewrite Ptrofs.unsigned_zero; simpl.
<     rewrite (unfold_transf_function _ _ TRANSL). apply R. 
<     traceEq.
<   + assert (TAILCALL: tailcall_possible (Linear_old.funsig f')).
<     {
<       apply zero_size_arguments_tailcall_possible. eapply wt_state_tailcall; eauto.
<     }
<     exploit match_stacks_change_sig. eauto. eauto.
<     erewrite wt_state_tailcall. vm_compute. congruence. eauto.
<     intros MS'.
<     constr_match_states. all: eauto. subst; eauto.
<     * exists id; split; auto.
<       destruct ros; simpl in *; eauto.
<       repeat destr_in A.
<       destruct IFI as (bb & oo & IFI & IFI').
<       exploit globalenv_inject_preserves_globals. apply SEP. intros (MPG1 & MPG2 & MPG3).
<       generalize (U (Locations_old.R m0)), (AGREGS m0), (T m0).
<       destr_in IFI.
<       simpl. rewrite IFI, Heqv. rewrite Heqb0. inversion 3; subst.
<       erewrite MPG1 in H8; eauto. inv H8.
<       eapply Genv.find_invert_symbol; eauto.
<       rewrite symbols_preserved; eauto.
<       simpl. rewrite IFI, Heqv. rewrite Heqb0. inversion 3; subst.
<       erewrite MPG1 in H8; eauto. inv H8.
<       eapply Genv.find_invert_symbol; eauto.
<       rewrite symbols_preserved; eauto.
<       subst. 
<       eapply Genv.find_invert_symbol; eauto.
<     * rewnb; auto.
<     * rewrite sep_swap12.
<       eapply mconj_intro.
<       revert SEP. rewrite sep_swap12; eauto.
<       repeat rewrite_stack_blocks. intros D E; rewrite D, E. simpl; auto.
<       repeat rewrite_stack_blocks. intro EQ1; rewrite EQ1 in *.
<       split. 2:split.
<       -- simpl. inv MS'. inv STACKS. simpl in *. auto.
<          ++ red.
<             intros sl of ty H rs2.
<             elim (TAILCALL _ H).
<          ++ rewrite sep_swap12 in SEP_init. apply mconj_proj2 in SEP_init. apply sep_proj1 in SEP_init.
<             red; intros.
<             exploit SEP_init. eauto. instantiate (1 := rs2). intros (v & ea & VINJ).
<             econstructor; split; eauto.
<             inv ea; constructor.
<             clear SEP_init.
<             clearbody step.
<             destruct init_sp eqn:?; try discriminate.
<             unfold load_stack in H7 |- *; simpl in *.
<             eapply Mem.load_unchanged_on with (P:= fun b o => b <> sp'); eauto.
<             eapply Mem.unchanged_on_trans.
<             eapply Mem.free_unchanged_on. apply R. intuition.
<             eapply Mem.strong_unchanged_on_weak, Mem.tailcall_stage_unchanged_on; eauto.
<             intros; intro; subst.
<             inv CallStackConsistency.
<             edestruct init_sp_csc as (fi' & INS' & _). eauto. eauto.
<             exploit Mem.stack_norepet. rewrite EQ1.
<             intro ND. inv ND.
<             eapply H8.
<             2: eapply in_stack'_in_stack; eauto.
<             eapply in_frame_in_frames; eauto. 
<             eapply in_frame'_in_frame; eauto.
<             red; rewrite BLOCKS. left; reflexivity. reflexivity.
<       -- eapply sep_proj2. apply sep_swap12. eauto.
<       -- apply sep_proj2 in SEP_init. apply mconj_proj2 in SEP_init.
<          destruct SEP_init as (A1 & A2 & A3). revert A3. destruct s; auto.
<          red; intros.
<          eapply A3; eauto.
<          destruct H. decompose [ex and] H.
<          exploit TAILCALL. apply H4. simpl. easy.
<     * revert SE'. repeat rewrite_stack_blocks.
<       clear; intros A B; rewrite A, B; intro SE; inv SE; constructor; auto.
<       split; simpl; auto.
<       red. destruct LF2 as (C & D); red in C; red in D; repeat destr_in C; constructor; auto.
---
>   eapply plus_right. eexact S. econstructor; eauto. traceEq.
>   econstructor; eauto.
>   apply match_stacks_change_sig with (Linear.fn_sig f); auto.
>   apply zero_size_arguments_tailcall_possible. eapply wt_state_tailcall; eauto.
3626,3631c2005,2007
<   eauto. eauto.
<   rewrite sep_swap12.
<   rewrite sep_swap12 in SEP. apply sep_proj2 in SEP.
<   rewrite sep_swap12 in SEP. apply mconj_proj1 in SEP. eauto.
<   eauto. rewrite <- forallb_forall. eapply wt_state_builtin; eauto.
<   exact BND2.
---
>     eauto. eauto. rewrite sep_swap in SEP; apply sep_proj2 in SEP; eexact SEP.
>     eauto. rewrite <- forallb_forall. eapply wt_state_builtin; eauto.
>     exact BND2.
3633,3667c2009,2012
<   assert (m'0
<             |= minjection j (flat_frameinj (length (Mem.stack m))) m **
<             globalenv_inject ge j **
<             frame_contents f j sp' rs (parent_locset init_ls s)
<             (parent_sp (Mem.stack m'0))
<             (parent_ra init_ra cs') **
<             stack_contents j s cs' (tl (Mem.stack m'0))).
<   {
<     eapply mconj_proj1.
<     rewrite sep_rot, sep_rot. eexact SEP.
<   }
<   
<   exploit (external_call_parallel_rule).
<   2: eassumption.
<   2: apply push_rule; eauto.
<   {
<     repeat
<     match goal with
<         [ |- context [m_invar_weak (?U ** ?V)] ] =>
<         replace (m_invar_weak (U ** V))
<                 with (m_invar_weak U || m_invar_weak V)
<           by reflexivity
<     end.
<     rewrite frame_contents_invar_weak.
<     rewrite stack_contents_invar_weak.
<     reflexivity.
<   }
<   all: eauto.
<   rewrite ! m_invar_stack_sepconj.
<   rewrite frame_contents_invar_stack, stack_contents_invar_stack; reflexivity.
<   rename SEP into SEP_init; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).
<   exploit unrecord_stack_block_parallel_rule. 3: eassumption. 2: eassumption.
<   rewrite ! m_invar_stack_sepconj.
<   rewrite frame_contents_invar_stack, stack_contents_invar_stack; reflexivity.
<   intros (m2' & USB & SEP').
---
>   rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.
>   exploit external_call_parallel_rule; eauto.
>   clear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).
>   rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.
3669,3776c2014,2024
<   + apply plus_one. econstructor; eauto.
<     eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
<     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
<   + constr_match_states.
<     4: apply agree_regs_set_res; auto. 4: apply agree_regs_undef_regs; auto. 4: eapply agree_regs_inject_incr; eauto.
<     4: eauto.
<     4: apply agree_locs_set_res; auto. 4: apply agree_locs_undef_regs; auto.
<     eapply match_stacks_change_meminj; eauto. all: eauto.
<     * eexists _, _; split; eauto.
<       intros. red; rewrite Mem.push_new_stage_nextblock. eapply Mem.valid_block_inject_2; eauto.
<       apply sep_proj2 in SEP_init. apply sep_proj2 in SEP_init.
<       apply mconj_proj1 in SEP_init. apply sep_proj1 in SEP_init.
<       simpl in SEP_init. eauto.
<     * intros.
<       destruct (j b0) eqn:?. destruct p.
<       generalize (INCR _ _ _ Heqo). intros. rewrite H4 in H3; inv H3.
<       eapply INJUNIQUE; eauto.
<       generalize (ISEP _ _ _ Heqo H3).
<       unfold Mem.valid_block; rewrite ! Mem.push_new_stage_nextblock.
<       intros (A & B).
<       apply sep_proj2 in SEP_init. apply sep_proj2 in SEP_init.
<       apply mconj_proj1 in SEP_init. apply sep_proj1 in SEP_init.
<       simpl in SEP_init. simpl in SEP_init.
<       exploit Mem.valid_block_inject_2. apply INJSP. eauto. congruence.
<     * revert INJ_INIT_SP. revert INCR. clear. destruct init_sp; simpl; auto.
<     * eapply has_at_most_one_antecedent_incr; eauto.
<       red. destr. red; rewnb.
<       eapply Mem.valid_block_inject_2; eauto.
<       apply H2.
<     * eapply inject_incr_trans; eauto.
<     * eapply inject_incr_sep_trans; eauto. 
<       rewrite Mem.push_new_stage_nextblock. inv LIN; auto.
<       rewrite Mem.push_new_stage_nextblock. auto.
<     * rewnb; auto.
<     * eauto with coqlib.
<     * apply frame_set_res. apply frame_undef_regs. apply frame_contents_incr with j; auto.
<       rewrite sep_swap2. apply stack_contents_change_meminj with j; auto. rewrite sep_swap2.
<       rewrite sep_swap23, sep_swap12.
<       apply mconj_intro. rewrite <- ! sep_assoc.
<       rewrite sep_comm. rewrite ! sep_assoc. rewrite sep_swap12.
<       repeat rewrite_stack_blocks; eauto.
<       split.
<       rewrite sep_swap23, sep_swap12 in SEP_init. apply mconj_proj2 in SEP_init.
<       apply sep_proj1 in SEP_init. revert SEP_init.
<       -- simpl.
<          red; intros.
<          exploit SEP_init. eauto. instantiate (1 := rs1).
<          destruct (match_stacks_is_init_sg _ _ _ _ _ STACKS) as [[TP _] | EQsig].
<          apply TP in H3. easy. subst.
<          intros (v & ea & inj); eexists; split; eauto.
<          inv ea; constructor; eauto.
<          clearbody step. destruct init_sp eqn:?; simpl in *; try discriminate.
<          unfold load_stack in *; simpl in *.
<          eapply Mem.load_unchanged_on; eauto.
<          eapply Mem.unchanged_on_trans. 
<          eapply Mem.strong_unchanged_on_weak, Mem.push_new_stage_unchanged_on.
<          eapply Mem.unchanged_on_trans.
<          eapply external_call_unchanged_on. apply EC.
<          eapply Mem.strong_unchanged_on_weak, Mem.unrecord_stack_block_unchanged_on. eauto.
<          simpl; intros.
<          rewrite_stack_blocks. intros [IST|NPSA].
<          red in IST. simpl in IST. auto.
<          red in NPSA.
<          simpl in NPSA.
< 
<          inv CSC. inv CallStackConsistency.
<          edestruct init_sp_csc as (fi' & INS & PRIV); eauto.
<          unfold get_frame_info in NPSA.
<          rewrite in_stack'_rew in INS. destruct INS as (tf' & IFR & INS).
<          rewrite in_frames'_rew in IFR. destruct IFR as (fr' & IFR & IFRS).
<          assert (i = Ptrofs.zero).
<          {
<            revert Heqv0. clear.
<            unfold init_sp, parent_sp, current_sp, current_frame_sp. repeat destr; inversion 1.
<          } subst.
<          erewrite get_assoc_stack_lnr in NPSA; eauto.
<          rewrite Ptrofs.add_zero_l in H4.
<          red in NPSA.
<          2: apply Mem.stack_norepet.
<          2: rewrite <- H10; apply In_tl; auto.
<          specialize (NPSA i0).
<          trim (NPSA). omega.
<          unfold fe_ofs_arg in PRIV. simpl in PRIV.
<          rewrite (fun pf => proj2 (PRIV (4 * of) pf)) in H4.
<          red in NPSA. contradict NPSA. setoid_rewrite (fun pf => proj1 (PRIV _ pf)). congruence.
<          split. etransitivity. 2: apply H4.
<          exploit loc_arguments_acceptable_2. apply H3. simpl. omega.
<          eapply Z.lt_le_trans. apply H4.
<          generalize (loc_arguments_bounded _ _ _ H3).
<          generalize (typesize_pos ty).
<          exploit loc_arguments_acceptable_2. apply H3. simpl.
<          rewrite size_type_chunk. rewrite typesize_typesize.
<          omega.
<          split.
<          exploit loc_arguments_acceptable_2. apply H3. simpl. omega.
<          generalize (loc_arguments_bounded _ _ _ H3).
<          generalize (typesize_pos ty).
<          exploit loc_arguments_acceptable_2. apply H3. simpl. omega.
<       -- split.
<          apply sep_proj2 in SEP'. rewrite sep_comm in SEP'. rewrite <- sep_assoc.
<          repeat rewrite_stack_blocks. simpl; eauto.
<          rewrite sep_swap23, sep_swap12 in SEP_init.
<          apply mconj_proj2 in SEP_init.
<          destruct SEP_init as (A1 & A2 & A3).
<          revert A3.
<          repeat rewrite_stack_blocks. simpl. auto.
<     * repeat rewrite_stack_blocks. simpl. auto.
<       
---
>   apply plus_one. econstructor; eauto.
>   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
>   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
>   eapply match_states_intro with (j := j'); eauto with coqlib.
>   eapply match_stacks_change_meminj; eauto.
>   apply agree_regs_set_res; auto. apply agree_regs_undef_regs; auto. eapply agree_regs_inject_incr; eauto.
>   apply agree_locs_set_res; auto. apply agree_locs_undef_regs; auto.
>   apply frame_set_res. apply frame_undef_regs. apply frame_contents_incr with j; auto. 
>   rewrite sep_swap2. apply stack_contents_change_meminj with j; auto. rewrite sep_swap2.
>   exact SEP.
> 
3780,3782c2028,2029
<   constr_match_states.
<   all: eauto with coqlib.
<   
---
>   econstructor; eauto with coqlib.
> 
3787c2034
<   constr_match_states; eauto.
---
>   econstructor; eauto.
3789c2036
<   
---
> 
3793,3794c2040
<   eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto.
<   apply sep_pick3 in SEP. destruct SEP. exact H0. auto.
---
>   eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
3796,3797c2042,2043
<   constr_match_states. eauto. eauto. eauto.
<   apply agree_regs_undef_regs; auto. 
---
>   econstructor. eauto. eauto. eauto.
>   apply agree_regs_undef_regs; auto.
3799c2045
<   all: eauto.
---
>   auto. 
3800a2047
>   apply frame_undef_regs; auto.
3805,3808c2052,2054
<   eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto.
<   apply sep_pick3 in SEP. destruct SEP. exact H0. auto.
<   constr_match_states. eauto. eauto. eauto.
<   apply agree_regs_undef_regs; eauto.
---
>   eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
>   econstructor. eauto. eauto. eauto.
>   apply agree_regs_undef_regs; auto.
3810,3812c2056,2058
<   all: eauto.
<   eauto with coqlib.
<   
---
>   auto. eauto with coqlib.
>   apply frame_undef_regs; auto.
> 
3819,3820c2065,2066
<   constr_match_states. eauto. eauto. eauto.
<   apply agree_regs_undef_regs; eauto.
---
>   econstructor. eauto. eauto. eauto.
>   apply agree_regs_undef_regs; auto.
3822,3824c2068,2070
<   all: eauto.
<   eapply find_label_tail; eauto.
<   
---
>   auto. eapply find_label_tail; eauto.
>   apply frame_undef_regs; auto.
> 
3826,3827c2072
<   rewrite (sep_swap (stack_contents j s cs' _)) in SEP.
<   inv CSC. rewrite FIND0 in FIND; inv FIND.
---
>   rewrite (sep_swap (stack_contents j s cs')) in SEP.
3829,3832c2074
<   2: rewrite sep_swap12 in SEP |- *.
<   2: apply mconj_proj1 in SEP; eauto.
<   rewrite m_invar_stack_sepconj, stack_contents_invar_stack; reflexivity.
<   intros (rs' & m1' & B & C & D & E & F & G & SE').
---
>   intros (rs' & m1' & A & B & C & D & E & F & G).
3834,3866c2076,2079
<   eapply plus_right. eexact D. econstructor; eauto.
<   rewrite Ptrofs.unsigned_zero. simpl. erewrite (unfold_transf_function _ _ TRANSL). apply C.
<   traceEq.
<   constr_match_states. all: try subst; eauto; repeat rewrite_stack_blocks.
<   + rewnb; auto.
<   + rewrite sep_swap.
<     eapply frame_mconj. apply sep_drop in SEP. apply SEP. revert G.
<     rewrite_stack_blocks. auto.
<     simpl.
<     red; intros.
<     apply sep_proj2 in SEP.
<     apply mconj_proj2 in SEP.
<     apply sep_pick1 in SEP.
<     exploit SEP. eauto. instantiate (1 := rs1). intros (v & ea & VINJ).
<     econstructor; split; eauto.
<     inv ea; constructor.
<     clear SEP.
<     clearbody step.
<     destruct init_sp eqn:?; try discriminate.
<     unfold load_stack in H5 |- *; simpl in *.
<     eapply Mem.load_unchanged_on with (P:= fun b o => b <> sp') .
<     eapply Mem.free_unchanged_on. apply C. intuition. 2: eauto. intros; intro; subst.
<     
<     inv CallStackConsistency.
<     edestruct init_sp_csc as (fi' & INS' & _). eauto. eauto.
<     exploit Mem.stack_norepet. rewrite <- H7 in *.
<     intro ND. inv ND.
<     eapply H6.
<     2: eapply in_stack'_in_stack; eauto.
<     eapply in_frame_in_frames; eauto. 
<     eapply in_frame'_in_frame; eauto.
<     red; rewrite BLOCKS. left; reflexivity. reflexivity.
<       
---
>   eapply plus_right. eexact D. econstructor; eauto. traceEq.
>   econstructor; eauto.
>   rewrite sep_swap; exact G.
> 
3871,3878c2084,2085
<   rewrite <- sep_assoc, sep_comm in SEP.
<   rewrite <- sep_assoc, sep_comm in SEP.
<   exploit function_prologue_correct.
<   15: eapply mconj_proj1; eassumption.
<   eassumption.
<   apply stack_contents_invar_stack.
<   eassumption.
<   eassumption.
---
>   rewrite sep_comm, sep_assoc in SEP. 
>   exploit function_prologue_correct; eauto.
3880,3890c2087
<   reflexivity.
<   reflexivity.
<   eassumption.
<   revert H0.
<   destruct SZEQ as (i & IS & EQ); subst.
<   unfold fn_stack_requirements.
<   erewrite Genv.invert_find_symbol; eauto.
<   rewrite FIND.
<   erewrite (unfold_transf_function _ _ TRANSL).
<   simpl. eauto.
<   eapply (type_parent_sp init_stk); eauto.
---
>   eapply match_stacks_type_sp; eauto.
3892,3896c2089,2092
<   inv HC. inv CFD; simpl. congruence. congruence.
<   inv CSC. auto.
<   auto.
<   rename SEP into SEP_init;
<     intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & fi & A1 & B & FRAME & C & D & E & F & SEP & J & K & KSEP & KV & KV' & PERMS & UNCH & IST & GFI).
---
>   clear SEP;
>   intros (j' & rs' & m2' & sp' & m3' & m4' & m5' & A & B & C & D & E & F & SEP & J & K).
>   rewrite (sep_comm (globalenv_inject ge j')) in SEP.
>   rewrite (sep_swap (minjection j' m')) in SEP.
3898,4005c2094,2100
<   + eapply plus_left. econstructor; eauto. 
<     rewrite (unfold_transf_function _ _ TRANSL). unfold fn_code. unfold transl_body.
<     eexact D. traceEq.
<   + constr_match_states.
<     eapply match_stacks_change_meminj; eauto. all: eauto with coqlib.
<     * exists m, m'0; split; eauto.
<       intros.
<       eapply Mem.valid_block_inject_2; eauto.
<       apply mconj_proj1 in SEP_init; apply sep_proj1 in SEP_init; simpl in SEP_init ; eauto.
<     * intros b0 delta JB.
<       destruct (j b0) eqn:?. destruct p.
<       exploit K. apply Heqo. rewrite JB. intro Z; inv Z.
<       eapply Mem.valid_block_inject_2 in Heqo.
<       2:       apply mconj_proj1 in SEP_init; apply sep_proj1 in SEP_init; simpl in SEP_init ; eauto.
<       eapply Mem.fresh_block_alloc in A1. congruence.
<       generalize (KSEP _ _ _ Heqo JB).
<       intros (VB1 & VB2).
<       eapply Mem.valid_block_inject_1 in JB.
<       2:   apply sep_proj2 in SEP; apply sep_proj1 in SEP; simpl in SEP ; eauto.
<       clear - VB1 JB H0 H external_calls_prf.
<       unfold Mem.valid_block in *.
<       exploit Mem.nextblock_alloc; eauto.
<       exploit Mem.alloc_result; eauto. intros; subst.
<       rewrite (Mem.record_stack_block_nextblock _ _ _ H0), H2 in JB.
<       apply Plt_succ_inv in JB; destruct JB; congruence.
<     * revert INJ_INIT_SP K; clear. destruct init_sp; simpl; auto.
<     * eapply has_at_most_one_antecedent_incr; eauto.
<       red. destr.
<       eapply Mem.valid_block_inject_2; eauto. apply SEP_init.
<     * eapply inject_incr_trans; eauto.
<     * eapply inject_incr_sep_trans; eauto. inv LIN; auto.
<     * unfold store_stack in *.
<       etransitivity. 2: eapply Mem.unchanged_on_nextblock; eauto. auto.
<     * rewrite sep_rot in SEP. rewrite sep_swap12.
<       eapply stack_contents_change_meminj; eauto.
<       rewrite sep_swap23, sep_swap12.
<       eapply mconj_intro.
<       rewrite sep_swap12, sep_swap23.
<       revert SEP.
<       destruct IST as (ST1 & ST2). rewrite ST1.
<       unfold store_stack in *.
<       repeat rewrite_stack_blocks. intros A BB; rewrite ?A, ?BB in *. simpl. auto.
<       split;[|split].
<       -- simpl.
<          apply mconj_proj2 in SEP_init. apply sep_proj1 in SEP_init.
<          eapply init_args_mach_unch; eauto. simpl.
<          intros. intro; subst.
<          inv CSC. inv TTNP. rewrite <- H2 in CallStackConsistency. simpl in CallStackConsistency.
<          edestruct init_sp_csc as (fi' & INS' & _). eauto. eauto.
<          exploit Mem.stack_norepet. instantiate (1:= m5'). rewrite (proj1 IST).
<          unfold store_stack in *; revert IST. repeat rewrite_stack_blocks.
<          rewrite <- H2. inversion 1; subst.
<          intros EQ3 ND. inv ND.
<          eapply H7.
<          2: eapply in_stack'_in_stack; eauto.
<          eapply in_frame_in_frames; eauto. 
<          eapply in_frame'_in_frame; eauto.
<          2: reflexivity.
<          red; left; reflexivity.
<          eapply init_args_incr; eauto.
<       -- rewrite sep_swap23, sep_swap12 in SEP. apply sep_proj2 in SEP.
<          rewrite (proj1 IST). rewrite_stack_blocks.
<          unfold store_stack in *.
<          repeat rewrite_stack_blocks.
<          intro EQ1; rewrite EQ1 in *. simpl in *.
<          apply SEP.
<       --
<         unfold store_stack in *.
<         rewrite (proj1 IST).
<         repeat rewrite_stack_blocks.
<         intro EQ1; rewrite EQ1 in *. simpl in *.
<         pose proof SEP_init as SEP_init'.
<         apply mconj_proj2 in SEP_init.
<         destruct SEP_init as (AA1 & AA2 & A3). revert A3.
<         red. simpl.
<         intros.
<         exploit A3. simpl. eauto.
<         destruct H2. right; auto. simpl in H2.
<         destruct H2. 2: left; auto.
<         simpl in H2.
<         assert ( b = sp' ).
<         clear - H2.
<         repeat match goal with
<                  H : m_footprint _ _ _ \/ m_footprint _ _ _ |- _ => destruct H; auto
<                | H : m_footprint _ _ _ |- _ => destruct H; auto
<                end.
<         revert H.
<         generalize (used_callee_save (function_bounds f))
<                    (fe_ofs_callee_save (make_env (function_bounds f)))
<                    (parent_locset init_ls s).
<         induction l; simpl; intros. easy.
<         destruct H; auto. destruct H. auto. eauto.
<         decompose [ex and] H1.
<         exfalso. subst. eapply Mem.fresh_block_alloc; eauto.
<         2: tauto.
<         eapply Mem.valid_block_inject_2. red in INJ_INIT_SP. rewrite H6 in INJ_INIT_SP. apply INJ_INIT_SP. apply mconj_proj1 in SEP_init'. apply SEP_init'.
<     * repeat rewrite_stack_blocks. destruct IST as (IST1 & IST2). rewrite IST1.
<       repeat rewrite_stack_blocks. rewrite IST2.
<       intros.
<       rewrite EQ1, EQ3 in SE. simpl in *. inv SE; repeat constructor; auto.
<       simpl.
<       destruct SZEQ as (i & INVERT & EQ).
<       subst.
<       unfold fn_stack_requirements.
<       erewrite Genv.invert_find_symbol; eauto.
<       rewrite FIND. reflexivity.
<       simpl. apply LF2.
<       
---
>   eapply plus_left. econstructor; eauto.
>   rewrite (unfold_transf_function _ _ TRANSL). unfold fn_code. unfold transl_body.
>   eexact D. traceEq.
>   eapply match_states_intro with (j := j'); eauto with coqlib.
>   eapply match_stacks_change_meminj; eauto.
>   rewrite sep_swap in SEP. rewrite sep_swap. eapply stack_contents_change_meminj; eauto.
> 
4007,4008c2102,2116
<   eapply external_call_step_correct; eauto.
<   
---
>   simpl in TRANSL. inversion TRANSL; subst tf.
>   exploit transl_external_arguments; eauto. apply sep_proj1 in SEP; eauto. intros [vl [ARGS VINJ]].
>   rewrite sep_comm, sep_assoc in SEP.
>   exploit external_call_parallel_rule; eauto.
>   intros (j' & res' & m1' & A & B & C & D & E).
>   econstructor; split.
>   apply plus_one. eapply exec_function_external; eauto.
>   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
>   eapply match_states_return with (j := j').
>   eapply match_stacks_change_meminj; eauto.
>   apply agree_regs_set_pair. apply agree_regs_inject_incr with j; auto. auto.
>   apply agree_callee_save_set_result; auto.
>   apply stack_contents_change_meminj with j; auto. 
>   rewrite sep_comm, sep_assoc; auto.
> 
4010,4016c2118
<   inv STACKS. simpl in AGLOCS. simpl in SEP. rewrite sep_assoc in SEP.
<   edestruct Mem.unrecord_stack as (b & EQ). eauto. rewrite EQ in SEP. simpl in SEP.
<   exploit unrecord_stack_block_parallel_rule. 3: eauto. 
<   2: rewrite sep_swap3 in SEP.
<   2: eapply mconj_proj1; eauto.
<   rewrite ! m_invar_stack_sepconj, stack_contents_invar_stack, frame_contents_invar_stack. reflexivity.
<   intros (m2' & USB & SEP').
---
>   inv STACKS. simpl in AGLOCS. simpl in SEP. rewrite sep_assoc in SEP. 
4018,4019c2120,2121
<   apply plus_one. apply exec_return. eauto.
<   constr_match_states; eauto.
---
>   apply plus_one. apply exec_return.
>   econstructor; eauto.
4021,4080c2123
<   rewnb; auto.
<   apply frame_contents_exten with rs0 (parent_locset init_ls s); auto.
<   rewrite sep_swap3. apply mconj_intro.
<   eapply sep_imp. apply SEP'. repeat split; auto. simpl.
<   repeat rewrite_stack_blocks. auto.
<   split.
<   rewrite sep_swap23, sep_swap12 in SEP. apply mconj_proj2 in SEP.
<   apply sep_proj1 in SEP. revert SEP.
<   intros. eapply m_invar. apply SEP. simpl.
<   eapply Mem.strong_unchanged_on_weak, Mem.unrecord_stack_block_unchanged_on; eauto.
<   simpl. congruence.
<   rewrite_stack_blocks.
<   split. apply SEP'.
<   red; simpl.
<   intros. decompose [ex and] H0. clear H0.
<   rewrite sep_swap3 in SEP.
<   apply mconj_proj2 in SEP.
<   destruct SEP as (A1 & A2 & A3).
<   exploit A3. simpl. repeat eexists; eauto.
<   revert H1.
<   eapply footprint_impl.
<   intros b1 o; apply footprint_impl.
<   simpl. auto. auto.
<   repeat rewrite_stack_blocks.
<   eapply stack_equiv_tail; eauto.
< Qed.
< 
< Inductive match_states_inv (s : Linear_old.state) (s': Mach_old.state): Prop :=
< | msi_intro
<     (MS: match_states s s')
<     (LIN: nextblock_properties_linear init_m s)
<     (HC: has_code return_address_offset tge s')
<     (CSC: call_stack_consistency tge init_sg init_stk s'):
<     match_states_inv s s'.
< 
< Theorem transf_step_correct'
<         (frame_size_correct: forall (fb : block) (f : function), Genv.find_funct_ptr tge fb = Some (Internal f) -> 0 < fn_stacksize f)
<         (init_sp_zero: forall b o, init_sp = Vptr b o -> o = Ptrofs.zero):
<   forall s1 t s2, Linear_old.step fn_stack_requirements init_ls ge s1 t s2 ->
<              forall (WTS: wt_state init_ls s1) s1'
<                (MS: match_states_inv s1 s1'),
<   exists s2', plus step tge s1' t s2' /\ match_states_inv s2 s2'.
< Proof.
<   intros. inv MS.
<   exploit transf_step_correct; eauto.
<   intros (s2' & PLUS & MS).
<   eexists; split; eauto.
<   assert (has_code return_address_offset tge s2' /\ call_stack_consistency tge init_sg init_stk s2').
<   {
<     eapply inv_plus with (P:= fun s => has_code return_address_offset tge s /\ call_stack_consistency tge init_sg init_stk s).
<     2: apply PLUS.
<     intros s0 t0 s3 STEP (HC' & CSC'); split.
<     eapply has_code_step; eauto.
<     eapply csc_step. eauto.
<     apply invalidate_frame1_tl_stack.
<     apply invalidate_frame1_top_no_perm. eauto.
<     eauto. eauto. eauto. split; auto.
<   } destruct H0.
<   constructor; auto.
<   eapply np_linear_step; eauto.
---
>   apply frame_contents_exten with rs0 (parent_locset s); auto. 
4083,4102d2125
< End WITHMEMINIT.
< 
< End WITHINITSP.
< 
< Definition mem_state (s: Mach_old.state) : mem :=
<   match s with
<     State _ _ _ _ _ m
<   | Callstate _ _ _ m
<   | Returnstate _ _ m => m
<   end.
< 
< Inductive match_states' (s : Linear_old.state) (s': Mach_old.state): Prop :=
< | match_states'_intro IS:
<     Mach_old.initial_state tprog IS ->
<     match_states_inv
<       Vnullptr (Locmap.init Vundef) (signature_main)
<       ((Some (make_singleton_frame_adt (Genv.genv_next (Genv.globalenv tprog)) 0 0), nil) :: nil)
<                      (mem_state IS) s s' ->
<     match_states' s s'.
< 
4104,4105c2127,2128
<   forall st1, Linear_old.initial_state fn_stack_requirements prog st1 ->
<   exists st2, Mach_old.initial_state tprog st2 /\ match_states' st1 st2.
---
>   forall st1, Linear.initial_state prog st1 ->
>   exists st2, Mach.initial_state tprog st2 /\ match_states st1 st2.
4108,4117d2130
<   exploit (Genv.init_mem_transf_partial TRANSF). eauto. intro TINIT.
<   exploit Genv.initmem_inject. apply H0. intro INJ0.
<   exploit Mem.record_init_sp_flat_inject. apply INJ0. omega. eauto. reflexivity. rewrite H4.
<   intros (m1 & EQ & INJRIS). inv EQ.
<   assert (initial_state tprog (Callstate nil b (Regmap.init Vundef) (Mem.push_new_stage m1))).
<   {
<     econstructor; eauto.
<     rewrite (match_program_main TRANSF).
<     rewrite symbols_preserved. eauto.
<   }
4119,4174c2132,2151
<   eexists; split; eauto.
<   set (j := Mem.flat_inj (Mem.nextblock m1)).
<   econstructor. eauto.
<   inv H. erewrite (Genv.init_mem_transf_partial TRANSF) in H7; eauto. inv H7.
<   rewrite H4 in H9; inv H9.
<   clear H6.
< 
<   constructor. econstructor. instantiate (2 := j). all: eauto.
<   - rewrite H3. constructor.
<     right; auto.
<     vm_compute. congruence.
<   - exists (prog_main prog); split; auto.
<     apply Genv.find_invert_symbol.
<     rewrite symbols_preserved; eauto.
<   - unfold Locmap.init. red; intros; auto.
<   - unfold Locmap.init. red; intros; auto.
<   - unfold j, Mem.flat_inj.
<     red. simpl. rewnb. auto.
<   - simpl. unfold j. unfold Mem.flat_inj.
<     rewnb. red. congruence.
<   - simpl. xomega.
<   - red. simpl.
<     unfold j, Mem.flat_inj. rewnb. destr.
<     rewrite (Genv.genv_next_match TRANSF) in n. xomega.
<   - simpl. red. inversion 1. subst.
<     unfold j. unfold Mem.flat_inj.
<     intros b1 b2 delta1 delta2 J1 J2. destr_in J1; destr_in J2.
<   - simpl stack_contents. rewrite sep_pure. split; auto. split;[|split].
<     + split.
<       * simpl.
<         apply Mem.push_new_stage_inject_flat. auto.
<       * simpl. red. simpl. easy.
<     + simpl. exists (Mem.nextblock m3); split.
<       rewrite Mem.push_new_stage_nextblock.
<       apply Ple_refl.
<       unfold j.
<       unfold Mem.flat_inj; constructor; intros.
<       apply pred_dec_true; auto.
<       destr_in H.
<       change (Mem.valid_block m3 b0). eapply Genv.find_symbol_not_fresh in H; [|eauto].
<       revert H; unfold Mem.valid_block. rewnb. intros; xomega.
<       change (Mem.valid_block m3 b0). eapply Genv.find_funct_ptr_not_fresh in H; [|eauto].
<       revert H; unfold Mem.valid_block. rewnb. intros; xomega.
<       change (Mem.valid_block m3 b0). eapply Genv.find_var_info_not_fresh in H; [|eauto].
<       revert H; unfold Mem.valid_block. rewnb. intros; xomega.
<     + red; simpl; tauto.
<   - repeat rewrite_stack_blocks. repeat constructor; auto.
<   - constructor. simpl. rewnb. xomega. constructor.
<   - repeat constructor.
<   - constructor. constructor.
<     repeat rewrite_stack_blocks. simpl.
<     rewnb. reflexivity.
<     repeat rewrite_stack_blocks. simpl. constructor.
<     change (size_arguments signature_main) with 0.
<     simpl. constructor. intros. unfold fe_ofs_arg in H. omega.
<     repeat rewrite_stack_blocks. constructor. reflexivity.
---
>   econstructor; split.
>   econstructor.
>   eapply (Genv.init_mem_transf_partial TRANSF); eauto.
>   rewrite (match_program_main TRANSF).
>   rewrite symbols_preserved. eauto.
>   set (j := Mem.flat_inj (Mem.nextblock m0)).
>   eapply match_states_call with (j := j); eauto.
>   constructor. red; intros. rewrite H3, loc_arguments_main in H. contradiction.
>   red; simpl; auto.
>   red; simpl; auto.
>   simpl. rewrite sep_pure. split; auto. split;[|split].
>   eapply Genv.initmem_inject; eauto.
>   simpl. exists (Mem.nextblock m0); split. apply Ple_refl.
>   unfold j, Mem.flat_inj; constructor; intros.
>     apply pred_dec_true; auto.
>     destruct (plt b1 (Mem.nextblock m0)); congruence.
>     change (Mem.valid_block m0 b0). eapply Genv.find_symbol_not_fresh; eauto.
>     change (Mem.valid_block m0 b0). eapply Genv.find_funct_ptr_not_fresh; eauto.
>     change (Mem.valid_block m0 b0). eapply Genv.find_var_info_not_fresh; eauto.
>   red; simpl; tauto.
4179c2156
<   match_states' st1 st2 -> Linear_old.final_state st1 r -> Mach_old.final_state st2 r.
---
>   match_states st1 st2 -> Linear.final_state st1 r -> Mach.final_state st2 r.
4181,4182c2158
<   intros. inv H0. inv H. inv H2. inv MS.
<   inv STACKS; try congruence.
---
>   intros. inv H0. inv H. inv STACKS.
4189,4190c2165
<   generalize (AGREGS rres).
<   rewrite H1. intro A; inv A.
---
>   generalize (AGREGS rres). rewrite H1. intros A; inv A.
4195c2170
<   forall i fd, In (i, Some (Gfun fd)) prog.(prog_defs) -> wt_fundef fd.
---
>   forall i fd, In (i, Gfun fd) prog.(prog_defs) -> wt_fundef fd.
4199,4202c2174,2175
<   intros ([i' g] & P & Q & R). simpl in *. inv R.
<   inv H1.
<   destruct fd; simpl in *.
< - monadInv H3. unfold transf_function in EQ.
---
>   intros ([i' g] & P & Q & R). simpl in *. inv R. destruct fd; simpl in *.
> - monadInv H2. unfold transf_function in EQ.
4207,4226d2179
< Lemma stacking_frame_correct:
<   forall p tp,
<     match_prog p tp ->
<     forall (fb : Values.block) (f : Mach_old.function),
<       Genv.find_funct_ptr (Genv.globalenv tp) fb = Some (Internal f) ->
<       0 < Mach_old.fn_stacksize f.
< Proof.
<   intros p tp MP fb f FFP.
<   red in MP.
<   inv MP.
<   exploit Globalenvs.Genv.find_funct_ptr_inversion. eauto. intros (id & IN).
<   eapply list_forall2_in_right in IN; eauto.
<   destruct IN as (x1 & IN & MIOG).
<   inv MIOG. simpl in *. subst. inv H2. inv H4.
<   destruct f1; simpl in *; try discriminate.
<   monadInv H6.
<   rewrite (unfold_transf_function _ _ EQ). 
<   Opaque fe_size. simpl. apply fe_size_pos.
< Qed.
< 
4228c2181
<   forward_simulation (Linear_old.semantics fn_stack_requirements prog) (Mach_old.semantics1 return_address_offset tprog).
---
>   forward_simulation (Linear.semantics prog) (Mach.semantics return_address_offset tprog).
4230c2183
<   set (ms := fun s s' => wt_state (Locmap.init Vundef) s /\ match_states' s s').
---
>   set (ms := fun s s' => wt_state s /\ match_states s s').
4235c2188
<   eapply wt_initial_state with (prog0 := prog); auto. exact wt_prog. apply H.
---
>   apply wt_initial_state with (prog := prog); auto. exact wt_prog.
4237,4249c2190,2194
< - intros. simpl in H.
<   destruct H0. destruct H1.
<   exploit transf_step_correct'; eauto. 
<   + apply Val.Vnullptr_has_type.
<   + inversion 1.
<   + eapply stacking_frame_correct; eauto.
<   + simpl. inversion 1. auto.
<   + intros [s2' [A B]].
<     exists s2'; split.
<     simpl. 
<     exact A. split.
<     * eapply step_type_preservation; eauto. eexact wt_prog. 
<     * econstructor; eauto. 
---
> - intros. destruct H0.
>   exploit transf_step_correct; eauto. intros [s2' [A B]].
>   exists s2'; split. exact A. split.
>   eapply step_type_preservation; eauto. eexact wt_prog. eexact H.
>   auto.
4252d2196
< 
