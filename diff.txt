32,36d31
< Section WITHEXTCALLS.
< Context `{external_calls_prf: ExternalCalls}.
< 
< Variable fn_stack_requirements: ident -> Z.
< 
==========================================================================================
82,83d76
< Variable function_entry: genv -> function -> list val -> mem -> env -> temp_env -> mem -> Z -> Prop.
< 
==========================================================================================99c92
<   | exec_Scall:   forall e le m optid a al tyargs tyres cconv vf vargs f t m' m'' vres id (IFI: is_function_ident ge vf id),
---
>   | exec_Scall:   forall e le m optid a al tyargs tyres cconv vf vargs f t m' vres,
==========================================================================================105,106c98
<       eval_funcall (Mem.push_new_stage m) f vargs t m' vres (fn_stack_requirements id) ->
<       Mem.unrecord_stack_block m' = Some m'' ->
---
>       eval_funcall m f vargs t m' vres ->
==========================================================================================108,109c100,101
<                 t (set_opttemp optid vres le) m'' Out_normal
<   | exec_Sbuiltin:   forall e le m optid ef al tyargs vargs t m' vres m'',
---
>                 t (set_opttemp optid vres le) m' Out_normal
>   | exec_Sbuiltin:   forall e le m optid ef al tyargs vargs t m' vres,
==========================================================================================111,113c103
<       external_call ef ge vargs (Mem.push_new_stage m) t vres m' ->
<       Mem.unrecord_stack_block m' = Some m'' ->
<       forall BUILTIN_ENABLED: builtin_enabled ef,
---
>       external_call ef ge vargs m t vres m' ->
==========================================================================================115c105
<                 t (set_opttemp optid vres le) m'' Out_normal
---
>                 t (set_opttemp optid vres le) m' Out_normal
==========================================================================================175,178c165,170
< with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Z -> Prop :=
<   | eval_funcall_internal: forall le m f vargs t e le' m2 m3 out vres m4 sz,
<       function_entry ge f vargs m e le m2 sz ->
<       exec_stmt e le m2 f.(fn_body) t le' m3 out ->
---
> with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop :=
>   | eval_funcall_internal: forall le m f vargs t e m1 m2 m3 out vres m4,
>       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
>       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
>       bind_parameters ge e m1 f.(fn_params) vargs m2 ->
>       exec_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t le m3 out ->
==========================================================================================181c173
<       eval_funcall m (Internal f) vargs t m4 vres sz
---
>       eval_funcall m (Internal f) vargs t m4 vres
==========================================================================================184c176
<       eval_funcall m (External ef targs tres cconv) vargs t m' vres 0.
---
>       eval_funcall m (External ef targs tres cconv) vargs t m' vres.
==========================================================================================198c190
<   | execinf_Scall:   forall e le m optid a al vf tyargs tyres cconv vargs f t id (IFI: is_function_ident ge vf id),
---
>   | execinf_Scall:   forall e le m optid a al vf tyargs tyres cconv vargs f t,
==========================================================================================204c196
<       evalinf_funcall (Mem.push_new_stage m) f vargs t (fn_stack_requirements id) ->
---
>       evalinf_funcall m f vargs t ->
==========================================================================================241,245c233,239
< with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Z -> Prop :=
<   | evalinf_funcall_internal: forall m f vargs t e le m2 sz,
<       function_entry ge f vargs m e le m2 sz ->
<       execinf_stmt e le m2 f.(fn_body) t ->
<       evalinf_funcall m (Internal f) vargs t sz.
---
> with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop :=
>   | evalinf_funcall_internal: forall m f vargs t e m1 m2,
>       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
>       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
>       bind_parameters ge e m1 f.(fn_params) vargs m2 ->
>       execinf_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t ->
>       evalinf_funcall m (Internal f) vargs t.
==========================================================================================251,254d244
< Section WHOLE_PROGRAM.
< 
< Variable function_entry: genv -> function -> list val -> mem -> env -> temp_env -> mem -> Z -> Prop.
< 
==========================================================================================256c246
<   | bigstep_program_terminates_intro: forall b f m0 m02 m1 t r,
---
>   | bigstep_program_terminates_intro: forall b f m0 m1 t r,
==========================================================================================262,263c252
<       Mem.record_init_sp m0 = Some m02 ->
<       eval_funcall ge function_entry (Mem.push_new_stage m02) f nil t m1 (Vint r) (fn_stack_requirements (prog_main p))->
---
>       eval_funcall ge m0 f nil t m1 (Vint r) ->
==========================================================================================267c256
<   | bigstep_program_diverges_intro: forall b f m0 t m02,
---
>   | bigstep_program_diverges_intro: forall b f m0 t,
==========================================================================================273,274c262
<       Mem.record_init_sp m0 = Some m02 ->
<       evalinf_funcall ge function_entry (Mem.push_new_stage m02) f nil t (fn_stack_requirements (prog_main p)) ->
---
>       evalinf_funcall ge m0 f nil t ->
==========================================================================================280,281d267
< End WHOLE_PROGRAM.
< 
==========================================================================================313,316d298
< Section WITHFUNCTIONENTRY.
< 
< Variable function_entry: genv -> function -> list val -> mem -> env -> temp_env -> mem -> Z -> Prop.
< 
==========================================================================================319c301
<    exec_stmt ge function_entry e le m s t le' m' out ->
---
>    exec_stmt ge e le m s t le' m' out ->
==========================================================================================321c303
<    star (fun ge' => step fn_stack_requirements ge' function_entry) ge (State f s k e le m) t S
---
>    star step1 ge (State f s k e le m) t S
==========================================================================================324,325c306,307
<   (forall m fd args t m' res sz,
<    eval_funcall ge function_entry m fd args t m' res sz ->
---
>   (forall m fd args t m' res,
>    eval_funcall ge m fd args t m' res ->
==========================================================================================328c310
<    star (fun ge' => step fn_stack_requirements ge' function_entry) ge (Callstate fd args k m sz) t (Returnstate res k m')).
---
>    star step1 ge (Callstate fd args k m) t (Returnstate res k m')).
==========================================================================================344c326
<   eapply star_right. apply H5. constructor. constructor. eauto. reflexivity. traceEq.
---
>   eapply star_right. apply H5. simpl; auto. econstructor. reflexivity. traceEq.
==========================================================================================471,472c453,454
<   destruct (H1 f k) as [S1 [A1 B1]].
<   eapply star_left. eapply step_internal_function; eauto.
---
>   destruct (H3 f k) as [S1 [A1 B1]].
>   eapply star_left. eapply step_internal_function; eauto. econstructor; eauto.
==========================================================================================474c456
<   inv B1; simpl in H4; try contradiction.
---
>    inv B1; simpl in H4; try contradiction.
==========================================================================================476c458
<   assert (fn_return f = Tvoid /\ vres = Vundef) as EQ.
---
>   assert (fn_return f = Tvoid /\ vres = Vundef).
==========================================================================================478c460
<   destruct EQ. subst vres. eapply step_skip_call; eauto.
---
>   destruct H7. subst vres. apply step_skip_call; auto.
==========================================================================================480c462
<   assert (fn_return f = Tvoid /\ vres = Vundef) as EQ.
---
>   assert (fn_return f = Tvoid /\ vres = Vundef).
==========================================================================================482,484c464,466
<   destruct EQ. subst vres.
<   rewrite <- (is_call_cont_call_cont k H4). rewrite <- H5.
<   eapply step_return_0; eauto.
---
>   destruct H8. subst vres.
>   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
>   apply step_return_0; auto.
==========================================================================================486,487c468,469
<   destruct H2.
<   rewrite <- (is_call_cont_call_cont k H4). rewrite <- H5.
---
>   destruct H4.
>   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
==========================================================================================490,491c472
<   eauto.
<   
---
> 
==========================================================================================498c479
<    exec_stmt ge function_entry e le m s t le' m' out ->
---
>    exec_stmt ge e le m s t le' m' out ->
==========================================================================================500c481
<    star (fun ge' => step fn_stack_requirements ge' function_entry) ge (State f s k e le m) t S
---
>    star step1 ge (State f s k e le m) t S
==========================================================================================502,503c483
< Proof. intros; apply (proj1 exec_stmt_eval_funcall_steps); auto. Qed.
< 
---
> Proof (proj1 exec_stmt_eval_funcall_steps).
==========================================================================================506,507c486,487
<    forall m fd args t m' res sz,
<    eval_funcall ge function_entry m fd args t m' res sz ->
---
>    forall m fd args t m' res,
>    eval_funcall ge m fd args t m' res ->
==========================================================================================510,511c490,491
<    star (fun ge' => step fn_stack_requirements ge' function_entry) ge (Callstate fd args k m sz) t (Returnstate res k m').
< Proof. intros; apply (proj2 exec_stmt_eval_funcall_steps); auto. Qed.
---
>    star step1 ge (Callstate fd args k m) t (Returnstate res k m').
> Proof (proj2 exec_stmt_eval_funcall_steps).
==========================================================================================516,518c496,498
<   forall m fd args T k sz,
<   evalinf_funcall ge function_entry m fd args T sz ->
<   forever_N (fun ge' => step fn_stack_requirements ge' function_entry) order ge tt (Callstate fd args k m sz) T.
---
>   forall m fd args T k,
>   evalinf_funcall ge m fd args T ->
>   forever_N step1 order ge tt (Callstate fd args k m) T.
==========================================================================================522,523c502,503
<           execinf_stmt ge function_entry e le m s T ->
<           forever_N (fun ge' => step fn_stack_requirements ge' function_entry) order ge tt (State f s k e le m) T).
---
>           execinf_stmt ge e le m s T ->
>           forever_N step1 order ge tt (State f s k e le m) T).
==========================================================================================546c526
<   apply plus_one. eapply step_ifthenelse with (b0 := b); eauto.
---
>   apply plus_one. eapply step_ifthenelse with (b := b); eauto.
582c562
<   eapply plus_one. econstructor; eauto.
---
>   eapply plus_one. econstructor; eauto. econstructor; eauto.
587,589d566
< End WITHFUNCTIONENTRY.
< 
< 
591c568
<   bigstep_sound (bigstep_semantics function_entry1 prog) (semantics1 fn_stack_requirements prog).
---
>   bigstep_sound (bigstep_semantics prog) (semantics1 prog).
608,609d584
< 
< End WITHEXTCALLS.
