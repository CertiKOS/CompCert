82c82
<   | (id, Some(Gfun fd')) :: rem ->
---
>   | (id, Gfun fd') :: rem ->
84c84
<   | _ :: rem ->
---
>   | (id, Gvar v) :: rem ->
91c91
<   | (id, Some(Gfun(Ctypes.Internal fn'))) :: rem ->
---
>   | (id, Gfun(Ctypes.Internal fn')) :: rem ->
131c131
<   | Callstate(fd, args, k, m, sz) ->
---
>   | Callstate(fd, args, k, m) ->
225c225
<   | Callstate(fd, args, k, m,_) -> m
---
>   | Callstate(fd, args, k, m) -> m
242c242
<   | Callstate(fd1,args1,k1,m1,_), Callstate(fd2,args2,k2,m2,_) ->
---
>   | Callstate(fd1,args1,k1,m1), Callstate(fd2,args2,k2,m2) ->
258c258
<              type t = Cexecimpl.state
---
>              type t = state
261a262,400
> (* Extract a string from a global pointer *)
> 
> let extract_string m blk ofs =
>   let b = Buffer.create 80 in
>   let rec extract blk ofs =
>     match Mem.load Mint8unsigned m blk ofs with
>     | Some(Vint n) ->
>         let c = Char.chr (Z.to_int n) in
>         if c = '\000' then begin
>           Some(Buffer.contents b)
>         end else begin
>           Buffer.add_char b c;
>           extract blk (Z.succ ofs)
>         end
>     | _ ->
>         None in
>   extract blk ofs
> 
> (* Emulation of printf *)
> 
> (* All ISO C 99 formats *)
> 
> let re_conversion = Str.regexp (
>   "\\(%[-+0# ]*[0-9]*\\(\\.[0-9]*\\)?\\)" (* group 1: flags, width, precision *)
> ^ "\\(\\|[lhjztL]\\|hh\\|ll\\)"            (* group 3: length modifier *)
> ^ "\\([aAcdeEfgGinopsuxX%]\\)"            (* group 4: conversion specifier *)
> )
> 
> external format_float: string -> float -> string
>   = "caml_format_float"
> external format_int32: string -> int32 -> string
>   = "caml_int32_format"
> external format_int64: string -> int64 -> string
>   = "caml_int64_format"
> 
> let format_value m flags length conv arg =
>   match conv.[0], length, arg with
>   | ('d'|'i'|'u'|'o'|'x'|'X'|'c'), (""|"h"|"hh"|"l"|"z"|"t"), Vint i ->
>       format_int32 (flags ^ conv) (camlint_of_coqint i)
>   | ('d'|'i'|'u'|'o'|'x'|'X'|'c'), (""|"h"|"hh"|"l"|"z"|"t"), _ ->
>       "<int argument expected>"
>   | ('d'|'i'|'u'|'o'|'x'|'X'), ("ll"|"j"), Vlong i ->
>       format_int64 (flags ^ conv) (camlint64_of_coqint i)
>   | ('d'|'i'|'u'|'o'|'x'|'X'), ("ll"|"j"), _ ->
>       "<long long argument expected"
>   | ('f'|'e'|'E'|'g'|'G'|'a'), (""|"l"), Vfloat f ->
>       format_float (flags ^ conv) (camlfloat_of_coqfloat f)
>   | ('f'|'e'|'E'|'g'|'G'|'a'), "", _ ->
>       "<float argument expected"
>   | 's', "", Vptr(blk, ofs) ->
>       begin match extract_string m blk ofs with
>       | Some s -> s
>       | None -> "<bad string>"
>       end
>   | 's', "", _ ->
>       "<pointer argument expected>"
>   | 'p', "", Vptr(blk, ofs) ->
>       Printf.sprintf "<%ld%+ld>" (P.to_int32 blk) (camlint_of_coqint ofs)
>   | 'p', "", Vint i ->
>       format_int32 (flags ^ "x") (camlint_of_coqint i)
>   | 'p', "", _ ->
>       "<int or pointer argument expected>"
>   | _, _, _ ->
>       "<unrecognized format>"
> 
> let do_printf m fmt args =
> 
>   let b = Buffer.create 80 in
>   let len = String.length fmt in
> 
>   let opt_search_forward pos =
>     try Some(Str.search_forward re_conversion fmt pos)
>     with Not_found -> None in
> 
>   let rec scan pos args =
>     if pos < len then begin
>     match opt_search_forward pos with
>     | None ->
>         Buffer.add_substring b fmt pos (len - pos)
>     | Some pos1 ->
>         Buffer.add_substring b fmt pos (pos1 - pos);
>         let flags = Str.matched_group 1 fmt
>         and length = Str.matched_group 3 fmt
>         and conv = Str.matched_group 4 fmt
>         and pos' = Str.match_end() in
>         if conv = "%" then begin
>           Buffer.add_char b '%';
>           scan pos' args
>         end else begin
>           match args with
>           | [] ->
>               Buffer.add_string b "<missing argument>";
>               scan pos' []
>           | arg :: args' ->
>               Buffer.add_string b (format_value m flags length conv arg);
>               scan pos' args'
>         end
>     end
>   in scan 0 args; Buffer.contents b
> 
> (* Implementation of external functions *)
> 
> let (>>=) opt f = match opt with None -> None | Some arg -> f arg
> 
> (* Like eventval_of_val, but accepts static globals as well *)
> 
> let convert_external_arg ge v t =
>   match v with
>   | Vint i -> Some (EVint i)
>   | Vfloat f -> Some (EVfloat f)
>   | Vsingle f -> Some (EVsingle f)
>   | Vlong n -> Some (EVlong n)
>   | Vptr(b, ofs) ->
>       Senv.invert_symbol ge b >>= fun id -> Some (EVptr_global(id, ofs))
>   | _ -> None
> 
> let rec convert_external_args ge vl tl =
>   match vl, tl with
>   | [], [] -> Some []
>   | v1::vl, t1::tl ->
>       convert_external_arg ge v1 t1 >>= fun e1 ->
>       convert_external_args ge vl tl >>= fun el -> Some (e1 :: el)
>   | _, _ -> None
> 
> let do_external_function id sg ge w args m =
>   match camlstring_of_coqstring id, args with
>   | "printf", Vptr(b, ofs) :: args' ->
>       extract_string m b ofs >>= fun fmt ->
>       let fmt' = do_printf m fmt args' in
>       let len = coqint_of_camlint (Int32.of_int (String.length fmt')) in
>       Format.print_string fmt';
>       flush stdout;
>       convert_external_args ge args sg.sig_args >>= fun eargs ->
>       Some(((w, [Event_syscall(id, eargs, EVint len)]), Vint len), m)
>   | _ ->
>       None
> 
> let do_inline_assembly txt sg ge w args m = None
> 
326c465
<     let l = Cexecimpl.step_expr ge e w k a m in
---
>     let l = Cexec.step_expr ge do_external_function do_inline_assembly e w k a m in
349,350c488,489
< let do_step fsr p prog ge time s w =
<   match Cexecimpl.at_final_state s with
---
> let do_step p prog ge time s w =
>   match Cexec.at_final_state s with
360c499
<       let l = Cexecimpl.do_step ge fsr w s in
---
>       let l = Cexec.do_step ge do_external_function do_inline_assembly w s in
375c514
< let rec explore_one fsr p prog ge time s w =
---
> let rec explore_one p prog ge time s w =
378c517
<   let succs = do_step fsr p prog ge time s w in
---
>   let succs = do_step p prog ge time s w in
387c526
<     explore_one fsr p prog ge (time + 1) s' w'
---
>     explore_one p prog ge (time + 1) s' w'
392c531
< let rec explore_all fsr p prog ge time states =
---
> let rec explore_all p prog ge time states =
404c543
<       add_reducts nextstates seen numseen states n (do_step fsr p prog ge time s w)
---
>       add_reducts nextstates seen numseen states n (do_step p prog ge time s w)
425c564
<     if nextstates <> [] then explore_all fsr p prog ge (time + 1) nextstates
---
>     if nextstates <> [] then explore_all p prog ge (time + 1) nextstates
438c577
<     | Some(Gvar gv) ->
---
>     | Gvar gv ->
444,445c583,584
<         (id, Some(Gvar gv'))
<     | _ ->
---
>         (id, Gvar gv')
>     | Gfun fd ->
462c601
<    Ctypes.prog_defs = (new_main_id, Some (Gfun(Ctypes.Internal new_main_fn))) :: p.Ctypes.prog_defs;
---
>     Ctypes.prog_defs = (new_main_id, Gfun(Ctypes.Internal new_main_fn)) :: p.Ctypes.prog_defs;
469,470c608,609
<   | (id, Some(Gfun fd)) :: gdl -> if id = name then Some fd else find_main_function name gdl
<   | _ :: gdl -> find_main_function name gdl
---
>   | (id, Gfun fd) :: gdl -> if id = name then Some fd else find_main_function name gdl
>   | (id, Gvar v) :: gdl -> find_main_function name gdl
500c639
<       match Cexecimpl.init_mem (program_of_program wprog) with
---
>       match Genv.init_mem (program_of_program wprog) with
504,505c643
<        let fsr = (fun _ -> Camlcoq.Z.of_sint 0) in
<       match Cexecimpl.do_initial_state fsr prog1 with
---
>       match Cexec.do_initial_state prog1 with
511c649
<               explore_one fsr p prog1 ge 0 s (world wge wm)
---
>               explore_one p prog1 ge 0 s (world wge wm)
513c651
<               explore_all fsr p prog1 ge 0 [(1, s, world wge wm)]
---
>               explore_all p prog1 ge 0 [(1, s, world wge wm)]
