35,39d34
< Section WITHEXTERNALCALLS.
< Context `{external_calls_prf: ExternalCalls}.
< 
< Variable fn_stack_requirements: ident -> Z.
< 
==========================================================================================
369c364
<   | step_call: forall f C rf rargs ty k e m targs tres cconv vf vargs fd id (IFI: is_function_ident ge vf id),
---
>   | step_call: forall f C rf rargs ty k e m targs tres cconv vf vargs fd,
==========================================================================================
377c372
<          E0 (Callstate fd vargs (Kcall f e C ty k) (Mem.push_new_stage m) (fn_stack_requirements id))
---
>          E0 (Callstate fd vargs (Kcall f e C ty k) m)
==========================================================================================
379c374
<   | step_builtin: forall f C ef tyargs rargs ty k e m vargs t vres m' m'',
---
>   | step_builtin: forall f C ef tyargs rargs ty k e m vargs t vres m',
==========================================================================================
382,384c377
<       external_call ef ge vargs (Mem.push_new_stage m) t vres m' ->
<       Mem.unrecord_stack_block m' = Some m'' ->
<       forall BUILTIN_ENABLED: builtin_enabled ef,
---
>       external_call ef ge vargs m t vres m' ->
==========================================================================================
386c379
<           t (ExprState f (C (Eval vres ty)) k e m'').
---
>           t (ExprState f (C (Eval vres ty)) k e m').
==========================================================================================
416,417c409,410
<   forall s', star (Csem.step fn_stack_requirements) ge s E0 s' ->
<   (exists r, final_state s' r) \/ (exists t, exists s'', Csem.step fn_stack_requirements ge s' t s'').
---
>   forall s', star Csem.step ge s E0 s' ->
>   (exists r, final_state s' r) \/ (exists t, exists s'', Csem.step ge s' t s'').
==========================================================================================
421c414
<   safe s -> star (Csem.step fn_stack_requirements) ge s E0 s' -> safe s'.
---
>   safe s -> star Csem.step ge s E0 s' -> safe s'.
==========================================================================================
429,431c422,423
<     safe s1 -> star (Csem.step fn_stack_requirements) ge s1 E0 s2 ->
<     (safe s2 -> star (Csem.step fn_stack_requirements) ge s2 t s3) ->
<   star (Csem.step fn_stack_requirements) ge s1 t s3.
---
>   safe s1 -> star Csem.step ge s1 E0 s2 -> (safe s2 -> star Csem.step ge s2 t s3) ->
>   star Csem.step ge s1 t s3.
==========================================================================================
438,439c430,431
<   safe s1 -> star (Csem.step fn_stack_requirements) ge s1 E0 s2 -> (safe s2 -> plus (Csem.step fn_stack_requirements) ge s2 t s3) ->
<   plus (Csem.step fn_stack_requirements) ge s1 t s3.
---
>   safe s1 -> star Csem.step ge s1 E0 s2 -> (safe s2 -> plus Csem.step ge s2 t s3) ->
>   plus Csem.step ge s1 t s3.
==========================================================================================
483c475
<   forall a m fd args ty sz, callred ge a m fd args ty sz -> expr_kind a = RV.
---
>   forall a m fd args ty, callred ge a m fd args ty -> expr_kind a = RV.
==========================================================================================
575,577c567,568
<       exists tyargs tyres cconv fd vl id,
<         is_function_ident ge vf id
<         /\ classify_fun tyf = fun_case_f tyargs tyres cconv
---
>       exists tyargs tyres cconv fd vl,
>          classify_fun tyf = fun_case_f tyargs tyres cconv
==========================================================================================
583,584c574
<       builtin_enabled ef /\
<       exists vargs, exists t, exists vres, exists m' m'',
---
>       exists vargs, exists t, exists vres, exists m',
==========================================================================================
586,587c576
<          /\ external_call ef ge vargs (Mem.push_new_stage m) t vres m'
<          /\ Mem.unrecord_stack_block m' = Some m''
---
>       /\ external_call ef ge vargs m t vres m'
==========================================================================================
617c606
<   intros. split; auto. exists vargs; exists t; exists vres; exists m', m''; auto.
---
>   intros. exists vargs; exists t; exists vres; exists m'; auto.
==========================================================================================
621,622c610,611
<   forall r fd args ty m sz,
<   callred ge r m fd args ty sz ->
---
>   forall r fd args ty m,
>   callred ge r m fd args ty ->
==========================================================================================
626c615
<   intros. exists tyargs, tyres, cconv, fd, args, sz; auto.
---
>   intros. exists tyargs, tyres, cconv, fd, args; auto.
==========================================================================================
721c710
<     star (Csem.step fn_stack_requirements) ge (ExprState f (C a) k e m)
---
>     star Csem.step ge (ExprState f (C a) k e m)
==========================================================================================
725c714
<     star (Csem.step fn_stack_requirements) ge (ExprState f (C a) k e m)
---
>     star Csem.step ge (ExprState f (C a) k e m)
==========================================================================================
769c758
<   star (Csem.step fn_stack_requirements) ge (ExprState f (C a) k e m)
---
>   star Csem.step ge (ExprState f (C a) k e m)
==========================================================================================
776c765
<   star (Csem.step fn_stack_requirements) ge (ExprState f (C a) k e m)
---
>   star Csem.step ge (ExprState f (C a) k e m)
==========================================================================================
995c984
<   star (Csem.step fn_stack_requirements) ge (ExprState f (C rl) k e m)
---
>   star Csem.step ge (ExprState f (C rl) k e m)
==========================================================================================
1157c1146
<   estep S t S' -> plus (Csem.step fn_stack_requirements) ge S t S'.
---
>   estep S t S' -> plus Csem.step ge S t S'.
==========================================================================================
1203c1192
<   left; apply step_rred with (C0 := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto. econstructor; eauto.
---
>   left; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto. econstructor; eauto.
==========================================================================================
1216c1205
<   left; apply step_rred with (C0 := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto. econstructor; eauto.
---
>   left; apply step_rred with (C := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto. econstructor; eauto.
==========================================================================================
1223c1212
<   left; eapply step_stuck with (C0 := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto.
---
>   left; eapply step_stuck with (C := fun x => C(Eassign (Eloc b ofs (typeof l)) x (typeof l))); eauto.
==========================================================================================
1233c1222
<   left; apply step_rred with (C0 := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
---
>   left; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
==========================================================================================
1236c1225
<   left; apply step_rred with (C0 := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.
---
>   left; apply step_rred with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.
==========================================================================================
1252c1241
<   left; apply step_rred with (C0 := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
---
>   left; apply step_rred with (C := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
==========================================================================================
1255c1244
<   left; eapply step_stuck with (C0 := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.
---
>   left; eapply step_stuck with (C := fun x => C (Ecomma x (Eval v1 (typeof l)) (typeof l))); eauto.
==========================================================================================
1260c1249
<   left; eapply step_stuck with (C0 := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
---
>   left; eapply step_stuck with (C := fun x => C (Ecomma (Eassign (Eloc b ofs (typeof l)) x (typeof l)) (Eval v1 (typeof l)) (typeof l))); eauto.
==========================================================================================
1374c1363
<   destruct Q. 
---
>   destruct Q.
==========================================================================================
1385c1374
<   intros [tyargs [tyres [cconv [fd [vargs [id [IFI [P [Q [U V]]]]]]]]]].
---
>   intros [tyargs [tyres [cconv [fd [vargs [P [Q [U V]]]]]]]].
==========================================================================================
1396c1385
<   intros [BUITIN_ENABLED [vargs [t [vres [m' [m'' [U [V W]]]]]]]].
---
>   intros [vargs [t [vres [m' [U V]]]]].
==========================================================================================
1410c1399
<   step S1 t S2 -> plus (Csem.step fn_stack_requirements) ge S1 t S2.
---
>   step S1 t S2 -> plus Csem.step ge S1 t S2.
==========================================================================================
1449c1438
<   Semantics_gen step (initial_state fn_stack_requirements p) final_state ge ge.
---
>   Semantics_gen step (initial_state p) final_state ge ge.
==========================================================================================
1567,1569d1555
<   edestruct Mem.unrecord_stack_block_succeeds as (m2' & USB & LEN).
<   erewrite <- external_call_stack_blocks. 2: eauto.
<   rewrite_stack_blocks. reflexivity.
==========================================================================================
1609c1595
<   forall p, backward_simulation (Csem.semantics fn_stack_requirements p) (semantics p).
---
>   forall p, backward_simulation (Csem.semantics p) (semantics p).
==========================================================================================
1775c1761
<                       targs tres cconv fd t3 m3 vres m4 id (IFI: is_function_ident ge vf id),
---
>                       targs tres cconv fd t3 m3 vres,
==========================================================================================
1782,1784c1768,1769
<       eval_funcall (Mem.push_new_stage m2) fd vargs t3 m3 vres (fn_stack_requirements id) ->
<       Mem.unrecord_stack_block m3 = Some m4 ->
<       eval_expr e m RV (Ecall rf rargs ty) (t1**t2**t3) m4 (Eval vres ty)
---
>       eval_funcall m2 fd vargs t3 m3 vres ->
>       eval_expr e m RV (Ecall rf rargs ty) (t1**t2**t3) m3 (Eval vres ty)
==========================================================================================
1913,1914c1898,1899
< with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Z -> Prop :=
<   | eval_funcall_internal: forall m f vargs t e m1 m1' m2 m3 out vres m4 sz fa,
---
> with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop :=
>   | eval_funcall_internal: forall m f vargs t e m1 m2 m3 out vres m4,
==========================================================================================
1917,1920c1902
<       frame_adt_blocks fa = blocks_with_info ge e ->
<       frame_adt_size fa = Z.max 0 sz ->
<       Mem.record_stack_blocks m1 fa = Some m1' ->
<       bind_parameters ge e m1' f.(fn_params) vargs m2 ->
---
>       bind_parameters ge e m1 f.(fn_params) vargs m2 ->
==========================================================================================
1924c1906
<       eval_funcall m (Internal f) vargs t m4 vres sz
---
>       eval_funcall m (Internal f) vargs t m4 vres
==========================================================================================
1927c1909
<       eval_funcall m (External ef targs tres cconv) vargs t m' vres 0.
---
>       eval_funcall m (External ef targs tres cconv) vargs t m' vres.
==========================================================================================
2023c2005
<                       targs tres cconv fd t3 id (IFI: is_function_ident ge vf id),
---
>                       targs tres cconv fd t3,
==========================================================================================
2030c2012
<       evalinf_funcall (Mem.push_new_stage m2) fd vargs t3 (fn_stack_requirements id) ->
---
>       evalinf_funcall m2 fd vargs t3 ->
==========================================================================================
2138,2139c2120,2121
< with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Z -> Prop :=
<   | evalinf_funcall_internal: forall m f vargs t e m1 m1' m2 sz fa,
---
> with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop :=
>   | evalinf_funcall_internal: forall m f vargs t e m1 m2,
==========================================================================================
2142,2145c2124
<       frame_adt_blocks fa = blocks_with_info ge e ->
<       frame_adt_size fa = Z.max 0 sz ->
<       Mem.record_stack_blocks m1 fa = Some m1' ->
<       bind_parameters ge e m1' f.(fn_params) vargs m2 ->
---
>       bind_parameters ge e m1 f.(fn_params) vargs m2 ->
==========================================================================================
2147c2126
<       evalinf_funcall m (Internal f) vargs t sz.
---
>       evalinf_funcall m (Internal f) vargs t.
==========================================================================================
2225,2226c2204,2205
< /\(forall m fd args t m' res sz,
<    eval_funcall m fd args t m' res sz ->
---
> /\(forall m fd args t m' res,
>    eval_funcall m fd args t m' res ->
==========================================================================================
2229c2208
<    star step ge (Callstate fd args k m sz) t (Returnstate res k m')).
---
>    star step ge (Callstate fd args k m) t (Returnstate res k m')).
==========================================================================================
2373c2352
<   right; constructor. eauto.
---
>   right; constructor.
==========================================================================================
2615c2594
<   destruct (H6 f k) as [S1 [A1 B1]].
---
>   destruct (H3 f k) as [S1 [A1 B1]].
==========================================================================================
2618c2597
<   inv B1; simpl in H5; try contradiction.
---
>   inv B1; simpl in H4; try contradiction.
==========================================================================================
2620c2599
<   assert (fn_return f = Tvoid /\ vres = Vundef) as EQ.
---
>   assert (fn_return f = Tvoid /\ vres = Vundef).
==========================================================================================
2622c2601
<   destruct EQ as [P Q]. subst vres. right; eapply step_skip_call; eauto.
---
>   destruct H7 as [P Q]. subst vres. right; eapply step_skip_call; eauto.
==========================================================================================
2624c2603
<   assert (fn_return f = Tvoid /\ vres = Vundef) as EQ.
---
>   assert (fn_return f = Tvoid /\ vres = Vundef).
==========================================================================================
2626,2628c2605,2607
<   destruct EQ as [P Q]. subst vres.
<   rewrite <- (is_call_cont_call_cont k H9). rewrite <- H10.
<   right; eapply step_return_0; eauto.
---
>   destruct H8 as [P Q]. subst vres.
>   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
>   right; apply step_return_0; auto.
==========================================================================================
2630c2609
<   destruct H7. rewrite <- (is_call_cont_call_cont k H9). rewrite <- H10.
---
>   destruct H4. rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
==========================================================================================
2671,2672c2650,2651
<   forall m fd args t m' res sz,
<   eval_funcall m fd args t m' res sz ->
---
>   forall m fd args t m' res,
>   eval_funcall m fd args t m' res ->
==========================================================================================
2675c2654
<   star step ge (Callstate fd args k m sz) t (Returnstate res k m').
---
>   star step ge (Callstate fd args k m) t (Returnstate res k m').
==========================================================================================
2731,2733c2710,2712
<   forall m fd args t k sz,
<   evalinf_funcall m fd args t sz ->
<   forever_N step lt ge O (Callstate fd args k m sz) t.
---
>   forall m fd args t k,
>   evalinf_funcall m fd args t ->
>   forever_N step lt ge O (Callstate fd args k m) t.
==========================================================================================
2932c2911
<   right. eapply step_ifthenelse_2 with (b0 := b). auto.
---
>   right. eapply step_ifthenelse_2 with (b := b). auto.
==========================================================================================
3047c3026
<   | bigstep_program_terminates_intro: forall b f m0 m1 t r m3 m1',
---
>   | bigstep_program_terminates_intro: forall b f m0 m1 t r,
==========================================================================================
3053,3055c3032
<       Mem.record_init_sp m0 = Some m3 ->
<       eval_funcall ge (Mem.push_new_stage m3) f nil t m1 (Vint r) (fn_stack_requirements (prog_main p)) ->
<       Mem.unrecord_stack_block m1 = Some m1' ->
---
>       eval_funcall ge m0 f nil t m1 (Vint r) ->
==========================================================================================
3059c3036
<   | bigstep_program_diverges_intro: forall b f m0 t m3,
---
>   | bigstep_program_diverges_intro: forall b f m0 t,
==========================================================================================
3065,3066c3042
<       Mem.record_init_sp m0 = Some m3 ->
<       evalinf_funcall ge (Mem.push_new_stage m3) f nil t (fn_stack_requirements (prog_main p)) ->
---
>       evalinf_funcall ge m0 f nil t ->
==========================================================================================
3088,3089d3063
< 
< End WITHEXTERNALCALLS.
