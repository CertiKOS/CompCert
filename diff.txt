21c21
< Require Import AST_old.
---
> Require Import AST.
==========================================================================================
23,31c23,31
< Require Import Values_old.
< Require Import Memory_old.
< Require Import Globalenvs_old.
< Require Import Events_old.
< Require Import Smallstep_old.
< Require Import Op_old.
< Require Import Locations_old.
< Require Import Conventions_old.
< Require Import Stacklayout_old.
---
> Require Import Values.
> Require Import Memory.
> Require Import Globalenvs.
> Require Import Events.
> Require Import Smallstep.
> Require Import Op.
> Require Import Locations.
> Require Import Conventions.
> Require Stacklayout.
==========================================================================================
76,79c76,77
<     (* fn_link_ofs: ptrofs; *)
<     fn_retaddr_ofs: ptrofs;
<     fn_frame_pubrange: Z * Z;
<   }.
---
> (*SACC:comments this*)(*fn_link_ofs: ptrofs;*)
>     fn_retaddr_ofs: ptrofs }.
==========================================================================================
81c79
< Definition fundef := AST_old.fundef function.
---
> Definition fundef := AST.fundef function.
==========================================================================================
83c81
< Definition program := AST_old.program fundef unit.
---
> Definition program := AST.program fundef unit.
==========================================================================================
123,125d120
< Section WITHMEMORYMODELOPS.
< Context `{memory_model_ops: Mem.MemoryModelOps}.
< 
==========================================================================================
132,133d126
< End WITHMEMORYMODELOPS.
< 
==========================================================================================
205a199,208
> Section STACK_WRAPPER.
> 
> Variable invalidate_frame: mem -> option mem.
> 
> Section RELSEM.
> 
> Variable return_address_offset: function -> code -> ptrofs -> Prop.
> 
> Variable ge: genv.
> 
==========================================================================================
220,222d222
< Section WITHMEMORYMODELOPS2.
< Context `{memory_model_ops: Mem.MemoryModelOps}.
< 
==========================================================================================
227c227
<       load_stack m sp ty (Ptrofs.repr (Stacklayout_old.fe_ofs_arg + 4 * ofs)) = Some v ->
---
>       load_stack m sp ty (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs)) = Some v ->
==========================================================================================
243c243
< End WITHMEMORYMODELOPS2.
---
> (** Mach execution states. *)
==========================================================================================
250c250
<              (sp: block)        (**r stack pointer in calling function *)
---
>              (sp: (*SACC: block*)val)        (**r stack pointer in calling function *)
==========================================================================================
255c255
< Inductive state `{memory_model_ops: Mem.MemoryModelOps}: Type :=
---
> Inductive state: Type :=
==========================================================================================
276,280c276,282
< Section WITHEXTERNALCALLSOPS.
< Context `{external_calls: ExternalCalls}.
< 
< Section RELSEM.
< Variables init_ra: val.
---
> (*SACC: Use StackADT one instead*)(*
> Definition parent_sp (s: list stackframe) : val :=
>   match s with
>   | nil => Vnullptr
>   | Stackframe f sp ra c :: s' => sp
>   end.
> *)
==========================================================================================
284c286
<   | nil => init_ra
---
>   | nil => Vnullptr
==========================================================================================
288,298d289
< Variable return_address_offset: function -> code -> ptrofs -> Prop.
< 
< Variable invalidate_frame: mem -> option mem.
< 
< Variable ge: genv.
< 
< Definition check_alloc_frame (f: frame_info) (fn: function) :=
<   0 < (frame_size f).
< 
< 
< 
==========================================================================================
318,319c309,310
<       (* load_stack m sp Tptr f.(fn_link_ofs) = Some (parent_sp s) -> *)
<       load_stack m (parent_sp (Mem.stack m)) ty ofs = Some v ->
---
>       (*SACC: comments this*)(*load_stack m sp Tptr f.(fn_link_ofs) = Some (parent_sp s) ->*)
>       load_stack m (parent_sp ((*SACC:*)Mem.stack m)) ty ofs = Some v ->
==========================================================================================
345,346c336,337
<         find_function_ptr ge ros rs = Some f' ->
<         (exists fd, Genv.find_funct_ptr ge f' = Some fd) ->
---
>       find_function_ptr ge ros rs = Some f' ->
>   (*SACC:*)(exists fd, Genv.find_funct_ptr ge f' = Some fd) ->
==========================================================================================
349c340
<       step (State s fb (Vptr sp Ptrofs.zero) (Mcall sig ros :: c) rs m)
---
>       step (State s fb sp(*SACC:(Vptr sp Ptrofs.zero)*) (Mcall sig ros :: c) rs m)
==========================================================================================
351c342
<                        f' rs (Mem.push_new_stage m))
---
>                        f' rs ((*SACC:*)Mem.push_new_stage m))
==========================================================================================
353,355c344,346
<       forall s fb stk soff sig ros c rs m f f' m' m'',
<         find_function_ptr ge ros rs = Some f' ->
<         (exists fd, Genv.find_funct_ptr ge f' = Some fd) ->
---
>       forall s fb stk soff sig ros c rs m f f' m' (*SACC:*)m'',
>       find_function_ptr ge ros rs = Some f' ->
>   (*SACC:*)(exists fd, Genv.find_funct_ptr ge f' = Some fd) ->
==========================================================================================
357,360c348,353
<       (* load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) -> *)
<       Mem.loadbytesv Mptr m (Val.offset_ptr (Vptr stk soff) f.(fn_retaddr_ofs)) = Some (parent_ra s) ->
<       Mem.free m stk (Ptrofs.unsigned soff) (Ptrofs.unsigned soff + f.(fn_stacksize)) = Some m' ->
<       Mem.tailcall_stage m' = Some m'' ->
---
>   (*SACC:comments this*)(*load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) ->
>       load_stack m (Vptr stk soff) Tptr f.(fn_retaddr_ofs) = Some (parent_ra s) ->
>       Mem.free m stk 0 f.(fn_stacksize) = Some m' ->*)
>   (*SACC:*)Mem.loadbytesv Mptr m (Val.offset_ptr (Vptr stk soff) f.(fn_retaddr_ofs)) = Some (parent_ra s) ->
>   (*SACC:*)Mem.free m stk (Ptrofs.unsigned soff) (Ptrofs.unsigned soff + f.(fn_stacksize)) = Some m' ->
>   (*SACC:*)Mem.tailcall_stage m' = Some m'' ->
==========================================================================================
362c355
<         E0 (Callstate s f' rs m'')
---
>         E0 (Callstate s f' rs (*SACC:*)m'')
==========================================================================================
364c357
<       forall s f sp rs m ef args res b vargs t vres rs' m' m'',
---
>       forall s f sp rs m ef args res b vargs t vres rs' m' (*SACC:*)m'',
==========================================================================================
366,367c359,360
<       external_call ef ge vargs (Mem.push_new_stage m) t vres m' ->
<       Mem.unrecord_stack_block m' = Some m'' ->                                          
---
>       external_call ef ge vargs ((*SACC:*)Mem.push_new_stage m) t vres m' ->
>   (*SACC:*)Mem.unrecord_stack_block m' = Some m'' ->
==========================================================================================
369d361
<       forall BUILTIN_ENABLED : builtin_enabled ef,
==========================================================================================
371c363
<          t (State s f sp b rs' m'')
---
>          t (State s f sp b rs' (*SACC:*)m'')
==========================================================================================
402c394
<       forall s fb stk soff c rs m f m' m'',
---
>       forall s fb stk soff c rs m f m' (*SACC:*)m'',
==========================================================================================
404,406c396,402
<       Mem.loadbytesv Mptr m (Val.offset_ptr (Vptr stk soff) f.(fn_retaddr_ofs)) = Some (parent_ra s) ->
<       Mem.free m stk (Ptrofs.unsigned soff) (Ptrofs.unsigned soff + f.(fn_stacksize)) = Some m' ->
<       invalidate_frame m' = Some m'' ->
---
>       (*SACC:comments this*)(*
>       load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) ->
>       load_stack m (Vptr stk soff) Tptr f.(fn_retaddr_ofs) = Some (parent_ra s) ->
>       Mem.free m stk 0 f.(fn_stacksize) = Some m' ->*)
>   (*SACC:*)Mem.loadbytesv Mptr m (Val.offset_ptr (Vptr stk soff) f.(fn_retaddr_ofs)) = Some (parent_ra s) ->
>   (*SACC:*)Mem.free m stk (Ptrofs.unsigned soff) (Ptrofs.unsigned soff + f.(fn_stacksize)) = Some m' ->
>   (*SACC:*)invalidate_frame m' = Some m'' ->
==========================================================================================
408c404
<         E0 (Returnstate s rs m'')
---
>         E0 (Returnstate s rs (*SACC:*)m'')
==========================================================================================
410c406
<       forall s fb rs m f m1 m1_ m3 stk rs' fi,
---
>       forall s fb rs m f m1 m2 m3 stk rs',
==========================================================================================
412d407
<       frame_info_of_size_and_pubrange (fn_stacksize f) (fn_frame_pubrange f) = Some fi ->
==========================================================================================
415,417c410,413
<       (* store_stack m1 sp Tptr f.(fn_link_ofs) (parent_sp s) = Some m2 -> *)
<       store_stack m1 sp Tptr f.(fn_retaddr_ofs) (parent_ra s) = Some m3 ->
<       Mem.record_stack_blocks m3 (make_singleton_frame_adt' stk fi (fn_stacksize f)) = Some m1_ ->
---
>       (*SACC:comments this*)(*
>       store_stack m1 sp Tptr f.(fn_link_ofs) (parent_sp s) = Some m2 ->*)
>       store_stack m1 sp Tptr f.(fn_retaddr_ofs) (parent_ra s) = Some m2 ->
>   (*SACC:*)Mem.record_stack_blocks m2 (make_singleton_frame_adt stk (fn_stacksize f)  (fn_stacksize f)) = Some m3 ->
==========================================================================================
420c416
<         E0 (State s fb sp f.(fn_code) rs' m1_)
---
>         E0 (State s fb sp f.(fn_code) rs' m3)
==========================================================================================
426c422
<       rs' = set_pair (loc_result (ef_sig ef)) res (undef_regs destroyed_at_call rs) ->
---
>       rs' = set_pair (loc_result (ef_sig ef)) res rs (*SACC:(undef_regs destroyed_at_call rs)*) ->
==========================================================================================
430,431c426,427
<       forall s f sp ra c rs m m',
<         Mem.unrecord_stack_block m = Some m' ->
---
>       forall s f sp ra c rs m (*SACC:*)m',
>   (*SACC:*)Mem.unrecord_stack_block m = Some m' ->
==========================================================================================
433c429
<         E0 (State s f (Vptr sp Ptrofs.zero) c rs m').
---
>         E0 (State s f sp c rs m').
==========================================================================================
435,572c431
< Inductive callstack_function_defined : list stackframe -> Prop :=
< | cfd_empty:
<     callstack_function_defined nil
< | cfd_cons:
<     forall fb sp' ra c' cs' trf
<       (FINDF: Genv.find_funct_ptr ge fb = Some (Internal trf))
<       (CFD: callstack_function_defined cs')
<       (RAU: return_address_offset trf c' ra)
<       (TAIL: exists l sg ros, fn_code trf = l ++ (Mcall sg ros :: c')),
<       callstack_function_defined (Stackframe fb sp' (Vptr fb ra) c' :: cs').
< 
< Variable init_sg: signature.
< Variable init_stk: stack.
< 
< Inductive single_block_prop (P: block -> frame_info -> Prop) : list (block * frame_info) -> Prop :=
< | sbp_intro:
<     forall b fi
<       (PROP: P b fi),
<       single_block_prop P ((b,fi)::nil).
< 
< Inductive init_sp_stackinfo : stack -> Prop :=
< | iss_intro
<     fr tf s
<     (PRIV: single_block_prop
<              (fun b fi =>
<                 forall o, fe_ofs_arg <= o < 4 * size_arguments init_sg ->
<                      frame_private fi o /\ Ptrofs.unsigned (Ptrofs.repr (fe_ofs_arg + o)) = fe_ofs_arg + o)
<              (frame_adt_blocks fr)):
<     init_sp_stackinfo ((Some fr,tf)::s).
< 
< Inductive list_prefix : list (option (block * frame_info)) -> stack -> Prop :=
< | list_prefix_nil s (STKEQ: s = init_stk) (INIT: init_sp_stackinfo s): list_prefix nil s
< | list_prefix_cons lsp s f r sp bi
<                    (REC: list_prefix lsp s)
<                    (FSIZE: frame_adt_size f = frame_size bi)
<                    (BLOCKS: frame_adt_blocks f = (sp,bi)::nil):
<     list_prefix (Some (sp,bi) :: lsp) ( (Some f , r) :: s).
< 
< Definition stack_blocks_of_callstack (l : list stackframe) : list (option (block * frame_info)) :=
<   map (fun x =>
<          match x with
<            Stackframe fb sp _ _ =>
<            match Genv.find_funct_ptr ge fb with
<              Some (Internal f) =>
<              match frame_info_of_size_and_pubrange (fn_stacksize f) (fn_frame_pubrange f) with
<              | Some fi => Some (sp, fi)
<              | None => None
<              end
<            | _ => None
<            end
<          end) l.
< 
< Inductive has_code: state -> Prop :=
< | has_code_intro fb f cs sp c rs m
<                  (FIND: Genv.find_funct_ptr ge fb = Some (Internal f))
<                  (CODE: exists l, fn_code f = l ++ c)
<                  (CFD: callstack_function_defined cs):
<     has_code (State cs fb sp c rs m)
< | has_code_call:
<     forall cs fb rs m
<       (CFD: callstack_function_defined cs),
<       has_code (Callstate cs fb rs m)
< | has_code_ret:
<     forall cs rs m
<       (CFD: callstack_function_defined cs),
<       has_code (Returnstate cs rs m).
< 
< Lemma find_label_ex:
<   forall lbl c c', find_label lbl c = Some c' -> exists l, c = l ++ c'.
< Proof.
<   induction c; simpl; intros. discriminate.
<   destruct (is_label lbl a). inv H.
<   exists (a::nil); simpl. auto.
<   apply IHc in H. destruct H as (l & CODE); rewrite CODE.
<   exists (a::l); simpl. reflexivity.
< Qed.
< 
< 
< Lemma has_code_step:
<   forall s1 t s2,
<     step s1 t s2 ->
<     has_code s1 ->
<     has_code s2.
< Proof.
<   destruct 1; simpl; intros HC; inv HC; try now (econstructor; eauto).
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<     eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE).
<     repeat econstructor; eauto. congruence.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE).
<     rewrite H in FIND; inv FIND.
<     econstructor; eauto. eapply find_label_ex. eauto. 
<   - destruct CODE as (l & CODE).
<     rewrite H0 in FIND; inv FIND.
<     econstructor; eauto. eapply find_label_ex. eauto.
<   - destruct CODE as (l & CODE); econstructor; eauto; rewrite CODE;
<       eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
<   - destruct CODE as (l & CODE).
<     rewrite H1 in FIND; inv FIND.
<     econstructor; eauto. eapply find_label_ex. eauto.
<   - econstructor; eauto. exists nil; simpl; auto.
<   - inv CFD. econstructor; eauto.
<     destruct TAIL as (l & sg & ros & EQ); rewrite EQ.
<     eexists (l ++ _ :: nil); simpl; rewrite app_ass; reflexivity.
< Qed.
< 
< Inductive call_stack_consistency: state -> Prop :=
< | call_stack_consistency_intro:
<     forall c cs' fb sp' rs m' tf fi
<       (FIND: Genv.find_funct_ptr ge fb = Some (Internal tf))
<       (FRAME: frame_info_of_size_and_pubrange (fn_stacksize tf) (fn_frame_pubrange tf) = Some fi)
<       (CallStackConsistency: list_prefix ((Some (sp', fi))::stack_blocks_of_callstack cs') (Mem.stack m'))
<     ,
<       call_stack_consistency (State cs' fb (Vptr sp' Ptrofs.zero) c rs m')
< | call_stack_consistency_call:
<     forall cs' fb rs m'
<       (CallStackConsistency: list_prefix (stack_blocks_of_callstack cs') (tl (Mem.stack m')))
<       (TTNP: top_tframe_tc (Mem.stack m')),
<       call_stack_consistency (Callstate cs' fb rs m')
< | call_stack_consistency_return:
<     forall cs' rs m'
<       (CallStackConsistency: list_prefix (stack_blocks_of_callstack cs') (tl (Mem.stack m')))
<       (TTNP: Mem.top_frame_no_perm m'),
<       call_stack_consistency (Returnstate cs' rs m').
---
> End RELSEM.
575,576c434,436
<   forall sp ty o v,
<     Mem.stack_unchanged (fun m m' => store_stack m sp ty o v = Some m').
---
>   forall sp ty o v m m',
>     store_stack m sp ty o v = Some m' ->
>     Mem.stack m' = Mem.stack m.
579,700d438
<   red; simpl; intros.
<   destruct (Val.offset_ptr sp o); try discriminate.
<   eapply Mem.store_no_abstract; eauto.
< Qed.
< 
< Hypothesis invalidate_frame_tl_stack:
<   forall m1 m2,
<     invalidate_frame m1 = Some m2 ->
<     tl (Mem.stack m2) = tl (Mem.stack m1).
< 
< Hypothesis invalidate_frame_top_no_perm:
<   forall m1 m2,
<     invalidate_frame m1 = Some m2 ->
<     Mem.top_frame_no_perm m1 ->
<     Mem.top_frame_no_perm m2.
< 
< 
< Ltac same_hyps :=
<   repeat match goal with
<            H1: ?a = _, H2: ?a = _ |- _ => rewrite H1 in H2; inv H2
<          end.
< 
< Lemma csc_step:
<   forall s1 t s2,
<     step s1 t s2 ->
<     (forall b f, Genv.find_funct_ptr ge b = Some (Internal f) -> 0 < fn_stacksize f) ->
<     has_code s1 ->
<     call_stack_consistency s1 ->
<     call_stack_consistency s2.
< Proof.
<   destruct 1; simpl; intros SIZE HC CSC; inv HC; inv CSC;
<     same_hyps;
<     try now (econstructor; eauto).
<   - econstructor; eauto. erewrite store_stack_no_abstract; eauto.
<   - econstructor; eauto. destruct a; simpl in *; try discriminate. erewrite Mem.store_no_abstract; eauto.
<   - econstructor. rewrite_stack_blocks. simpl. 
<     rewrite H1. rewrite FRAME. auto.
<     red. rewrite_stack_blocks. constructor. reflexivity.
<   - econstructor. repeat rewrite_stack_blocks. simpl. intro EQ; rewrite EQ in CallStackConsistency.
<     inv CallStackConsistency; simpl; auto.
<     red. rewrite_stack_blocks. intros; constructor. easy.
<   - econstructor; eauto. repeat rewrite_stack_blocks; simpl; eauto.
<   - econstructor; eauto.
<     erewrite invalidate_frame_tl_stack; eauto. repeat rewrite_stack_blocks; simpl; eauto.
<     inv CallStackConsistency. eauto.
<     eapply invalidate_frame_top_no_perm; eauto.
<     inv CallStackConsistency.
<     eapply Mem.free_top_tframe_no_perm; eauto.
<     unfold frame_info_of_size_and_pubrange in FRAME; repeat destr_in FRAME. simpl.
<     rewrite Ptrofs.unsigned_zero.
<     simpl. rewrite Z.max_r. auto. omega.
<   - econstructor; eauto; repeat rewrite_stack_blocks; simpl; eauto.
<     repeat econstructor; eauto.
<     rewrite store_stack_no_abstract in EQ1 by eauto.
<     revert EQ1; rewrite_stack_blocks. intro. rewrite EQ1 in CallStackConsistency. simpl in *.
<     auto.
<     simpl.
<     unfold frame_info_of_size_and_pubrange in H0; repeat destr_in H0. simpl.
<     apply Z.max_r. omega.
<   - econstructor; eauto; repeat rewrite_stack_blocks; simpl; eauto.
<     red; rewrite_stack_blocks.
<     inv TTNP.
<     constructor. unfold in_frames; rewrite H3; easy.
<   - inv CFD. simpl in CallStackConsistency.
<     rewrite FINDF in CallStackConsistency. destr_in CallStackConsistency. eauto.
<     econstructor; eauto; repeat rewrite_stack_blocks; simpl; eauto.
<     unfold frame_info_of_size_and_pubrange in Heqo. repeat destr_in Heqo.
<     exploit SIZE; eauto. omega.
< Qed.
< 
< Definition mem_state (s: state) : mem :=
<   match s with
<     State _ _ _ _ _ m
<   | Callstate _ _ _ m
<   | Returnstate _ _ m => m
<   end.
< 
< Lemma list_prefix_in_init_stk:
<   forall cs s,
<     list_prefix cs s ->
<     forall b,
<       in_stack init_stk b ->
<       in_stack s b.
< Proof.
<   induction 1; intros. subst; auto.
<   rewrite in_stack_cons; right; eauto.
< Qed.
< 
< Lemma list_prefix_stack_top_not_init_stk':
<   forall b b' f fr cs s,
<     nodup (fr::s) ->
<     list_prefix (Some (b',f)::cs) (fr::s) ->
<     in_frames fr b ->
<     get_frame_info init_stk b = None.
< Proof.
<   intros.
<   destruct (get_frame_info init_stk b) eqn:GFI; auto.
<   apply get_frame_info_in_stack in GFI. exfalso.
<   inv H0.
<   inv H.
<   eapply H4. eauto.
<   eapply list_prefix_in_init_stk. eauto. auto.
< Qed.
< 
< Lemma list_prefix_stack_top_not_init_stk:
<   forall b b' f cs s,
<     nodup s ->
<     list_prefix (Some (b',f)::cs) s ->
<     is_stack_top s b ->
<     get_frame_info init_stk b = None.
< Proof.
<   intros.
<   inv H0. red in H1. simpl in H1.
<   eapply list_prefix_stack_top_not_init_stk'. eauto. constructor; eauto. auto.
< Qed.
< 
< Lemma list_prefix_not_in_init_stk:
<   forall b f cs s,
<     nodup s ->
<     list_prefix (Some (b, f)::cs) s ->
<     get_frame_info init_stk b = None.
< Proof.
702,852c440,441
<   destruct (get_frame_info init_stk b) eqn:GFI; auto.
<   apply get_frame_info_in_stack in GFI. exfalso.
<   inv H0.
<   inv H.
<   eapply H3. rewrite in_frames_cons. eexists; split. reflexivity. 
<   eapply in_frame'_in_frame. red. rewrite BLOCKS. left; reflexivity.
<   eapply list_prefix_in_init_stk. eauto. auto.
< Qed.
< 
< Lemma public_stack_access_init_stk:
<   forall cs s b lo hi
<          (LP: list_prefix cs s)
<          (ND: nodup s)
<          (PSA: public_stack_access s b lo hi),
<     public_stack_access init_stk b lo hi.
< Proof.
<   induction 1; simpl; subst; auto.
<   intros.
<   apply IHLP. inv ND; auto.
<   red. red in PSA. destr.
<   edestruct (get_assoc_spec _ _ _ Heqo) as (fr & tf & INblocks & INtf & INs).
<   erewrite get_assoc_stack_lnr in PSA. eauto. eauto. eauto. eauto. eauto. right; auto.
< Qed.
< 
< Lemma public_stack_access_init_stk':
<   forall cs s b lo hi
<          (LP: list_prefix cs s)
<          f
<          (ND: nodup (f::s))
<          (PSA: public_stack_access (f::s) b lo hi),
<     public_stack_access init_stk b lo hi.
< Proof.
<   induction 1; simpl; subst; auto.
<   - unfold public_stack_access. simpl.
<     intros. destr.
<     destr_in PSA. destr_in Heqo0.
<     inv ND.
<     exfalso; eapply H2; eauto. eapply get_frame_info_in_stack; eauto.
<     inv Heqo0; auto.
<     repeat destr_in Heqo0.
<     inv ND.
<     exfalso; eapply H3; eauto. eapply get_frame_info_in_stack; eauto.
<   - intros.
<     eapply IHLP. inv ND; eauto.
<     red. red in PSA. destr.
<     edestruct (get_assoc_spec _ _ _ Heqo) as (fr & tf & INblocks & INtf & INs).
<     erewrite get_assoc_stack_lnr in PSA. eauto. eauto. eauto.
<     eauto. eauto. right; auto.
< Qed.
< 
< 
< Hypothesis invalidate_frame_unchanged_on:
<   forall m1 m2 P,
<     invalidate_frame m1 = Some m2 ->
<     Mem.unchanged_on P m1 m2.
< 
< Lemma csc_unchanged_stack:
<   forall s t s',
<     step s t s' ->
<     call_stack_consistency s ->
<     Mem.unchanged_on
<       (fun b o => ~ stack_access init_stk b o (o+1))
<       (mem_state s) (mem_state s').
< Proof.
<   intros s t s' STEP CSC. inv STEP; inv CSC; simpl; try apply Mem.unchanged_on_refl.
<   - unfold store_stack in H. simpl in H.
<     eapply Mem.store_unchanged_on; eauto.
<     intros i RNG PSA; apply PSA; clear PSA. red.
<     right. red. erewrite list_prefix_not_in_init_stk; eauto. apply Mem.stack_norepet.
<   - unfold Mem.storev in H0. destr_in H0.
<     eapply Mem.store_unchanged_on; eauto.
<     intros i0 RNG PSA; apply PSA; clear PSA.
<     edestruct Mem.store_valid_access_3 as (A & B & C). eauto. trim C. constructor.
<     destruct C as [IST|NPSA].
<     right. red; erewrite list_prefix_stack_top_not_init_stk; eauto. apply Mem.stack_norepet.
<     right. eapply public_stack_access_inside.
<     eapply public_stack_access_init_stk; eauto. apply Mem.stack_norepet.
<     omega. omega.
<   - apply Mem.strong_unchanged_on_weak. apply Mem.push_new_stage_unchanged_on.
<   - eapply Mem.unchanged_on_trans. eapply Mem.free_unchanged_on; eauto.
<     intros i RNG PSA; apply PSA; clear PSA. right; red.
<     erewrite list_prefix_not_in_init_stk; eauto. apply Mem.stack_norepet.
<     eapply Mem.strong_unchanged_on_weak, Mem.tailcall_stage_unchanged_on; eauto.
<   - exploit ec_unchanged_on_private_stack. apply external_call_spec. eauto.
<     intros.
<     eapply Mem.unchanged_on_trans.
<     apply Mem.strong_unchanged_on_weak. eapply Mem.push_new_stage_unchanged_on.
<     eapply Mem.unchanged_on_trans.
<     eapply Mem.unchanged_on_implies. apply H2.
<     simpl.
<     intros b0 ofs NPSA VB PSA.
<     apply NPSA.
<     assert (PSA': stack_access (Mem.stack m) b0 ofs (ofs + 1)).
<     {
<       red in PSA. revert PSA. red. rewrite_stack_blocks. unfold is_stack_top. simpl.  unfold public_stack_access. simpl. auto.
<       intros [[]|P]. right. auto.
<     } clear PSA.
<     destruct PSA'.
<     right; red. erewrite list_prefix_stack_top_not_init_stk; eauto. apply Mem.stack_norepet.
<     right.
<     eapply public_stack_access_init_stk. 4: eauto. eauto. apply Mem.stack_norepet.
<     auto.
<     apply Mem.strong_unchanged_on_weak. eapply Mem.unrecord_stack_block_unchanged_on. eauto.
<   - eapply Mem.unchanged_on_trans. eapply Mem.free_unchanged_on; eauto.
<     intros i RNG PSA; apply PSA; clear PSA. right; red.
<     erewrite list_prefix_not_in_init_stk; eauto. apply Mem.stack_norepet.
<     eapply invalidate_frame_unchanged_on; eauto.
<   - eapply Mem.unchanged_on_trans.
<     eapply Mem.alloc_unchanged_on; eauto.
<     unfold store_stack in H2. subst. simpl in H2.
<     eapply Mem.unchanged_on_trans.
<     eapply Mem.store_unchanged_on. eauto.
<     intros i0 RNG PSA; apply PSA; clear PSA.
<     right; red. destr.
<     apply get_frame_info_in_stack in Heqo. exfalso.
<     eapply list_prefix_in_init_stk in Heqo; eauto.
<     apply in_stack_tl in Heqo. apply Mem.in_frames_valid in Heqo.
<     eapply Mem.fresh_block_alloc; eauto.
<     apply Mem.strong_unchanged_on_weak. eapply Mem.record_stack_block_unchanged_on. eauto.
<   - exploit ec_unchanged_on_private_stack. apply external_call_spec. eauto.
<     intros.
<     eapply Mem.unchanged_on_implies. apply H2.
<     simpl.
<     intros b0 ofs NPSA VB PSA.
<     apply NPSA. inv TTNP. rewrite <- H3 in CallStackConsistency. simpl in CallStackConsistency.
<     destruct PSA.
<     right; red.
<     destr. eapply get_frame_info_in_stack in Heqo.
<     eapply list_prefix_in_init_stk in Heqo; eauto.
<     exploit Mem.stack_norepet. rewrite <- H3. intro ND. inv ND. edestruct H9; eauto.
<     rewrite <- H3 in H5. red in H5. eauto.
<     right.
<     rewrite <- H3 in *.
<     eapply public_stack_access_init_stk' . 3: eauto. eauto.
<     rewrite H3; apply Mem.stack_norepet.
<   - apply Mem.strong_unchanged_on_weak. eapply Mem.unrecord_stack_block_unchanged_on. eauto.
< Qed.
< 
< Definition block_prop P v :=
<   match v with
<     Vptr b o => P b
<   | _ => True
<   end.
< 
< Lemma store_stack_nextblock:
<   forall m v ty p v1 m',
<     store_stack m v ty p v1 = Some m' ->
<     Mem.nextblock m' = Mem.nextblock m.
< Proof.
<   unfold store_stack; intros.
<   destruct (Val.offset_ptr v p); simpl in *; inv H;  eauto with mem.
---
>   destruct (Val.offset_ptr sp o); try discriminate.
>   eapply Mem.store_stack_unchanged; eauto.
855c444
< End RELSEM.
---
> End STACK_WRAPPER.
858c447
<   | initial_state_intro: forall fb m0 m2,
---
>   | initial_state_intro: forall fb m0 (*SACC:*)m2,
862c451
<       Mem.record_init_sp m0 = Some m2 ->
---
>   (*SACC:*)Mem.record_init_sp m0 = Some m2 ->
870a460
> (*==========================SACC: invalidate_frame interface==========================*)
872a463
> (*
896a488
> *)
899a492
> (*
925c518
<   eapply Mem.strong_unchanged_on_weak, Mem.tailcall_stage_unchanged_on; eauto.
---
>   eapply Mem.tailcall_stage_unchanged_on; eauto.
926a520,521
> *)
> (*==========================================================================================*)
929c524
<   Semantics (step Vnullptr rao invalidate_frame1) (initial_state p) final_state (Genv.globalenv p).
---
>   Semantics (step invalidate_frame1 rao) (initial_state p) final_state (Genv.globalenv p).
932,934c527
<   Semantics (step Vnullptr rao invalidate_frame2) (initial_state p) final_state (Genv.globalenv p).
< 
< End WITHEXTERNALCALLSOPS.
---
>   Semantics (step invalidate_frame2 rao) (initial_state p) final_state (Genv.globalenv p).
