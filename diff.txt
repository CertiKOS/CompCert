30a31
> Require Initializers.
==========================================================================================
50d50
< Require Mach2Mach2.
==========================================================================================73d72
< 
==========================================================================================77d75
< 
==========================================================================================122,123d119
< Local Existing Instance ValueAnalysis.romem_for_wp_instance.
< 
==========================================================================================129c125
<   @@@ partial_if Compopts.optim_inlining (time "Inlining" Inlining.transf_program)
---
>   @@@ time "Inlining" Inlining.transf_program
==========================================================================================151c147
<    @@@ time "Asm generation" Asmgen.transf_program.
---
>   @@@ time "Asm generation" Asmgen.transf_program.
==========================================================================================172a169,172
> (** Force [Initializers] and [Cexec] to be extracted as well. *)
> 
> Definition transl_init := Initializers.transl_init.
> Definition cexec_do_step := Cexec.do_step.
==========================================================================================239c239
<   ::: mkpass (match_if Compopts.optim_inlining Inliningproof.match_prog)
---
>   ::: mkpass Inliningproof.match_prog
==========================================================================================262,278d261
< Fixpoint passes_app {A B C} (l1: Passes A B) (l2: Passes B C) : Passes A C :=
<   match l1 in (Passes AA BB) return (Passes BB C -> Passes AA C) with
<   | pass_nil _ => fun l3 => l3
<   | pass_cons _ _ _ P1 l1 => fun l2 => P1 ::: passes_app l1 l2
<   end l2.
< 
< (* Instance transf_check_link: TransfLink PseudoInstructions.match_check_prog. *)
< (* Proof. *)
< (*   red. intros p1 p2 tp1 tp2 p LINK (MP1 & O1) (MP2 & O2). *)
< (*   exploit (fun lv => @TransfPartialLink Asm.function Asm.function unit lv (PseudoInstructions.transf_check_function) p1 p2 tp1 tp2 p); eauto. intros (tp & TLINK & TMP). *)
< (*   exists tp; split; eauto. *)
< (*   split; auto. *)
< 
< (*   eauto. eauto. *)
< (* Defined. *)
< 
< 
==========================================================================================299c282
<   destruct (partial_if optim_inlining Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.
---
>   destruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.
==========================================================================================320c303
<   exists p8; split. eapply partial_if_match; eauto. apply Inliningproof.transf_program_match; auto.
---
>   exists p8; split. apply Inliningproof.transf_program_match; auto.
333c316
<   exists tp; split. apply Asmgenproof.transf_program_match; auto.
---
>   exists tp; split. apply Asmgenproof.transf_program_match; auto. 
337,348d319
< Lemma compose_passes_app:
<   forall {l1 l2} (A: Passes l1 l2) {l3} (B: Passes l2 l3) p tp,
<     compose_passes (passes_app A B) p tp <->
<     exists pi, compose_passes A p pi /\ compose_passes B pi tp.
< Proof.
<   induction A; simpl; intros. split. eexists; split; eauto.
<   intros (pi & EQ & CP); inv EQ; auto.
<   setoid_rewrite IHA. split; intro H; decompose [ex and] H; eauto.
< Qed.
< 
< 
< 
352c323
<   [match_prog] relation) preserves semantics by constructing
---
>   [match_prog] relation) preserves semantics by constructing 
364,365c335
<   forall {RETVAL: Type},
<   forall sem: _ RETVAL, forward_simulation sem sem.
---
>   forall sem, forward_simulation sem sem.
375,376c345
<   forall {RETVAL: Type},
<   forall (A: Type) (sem: A -> semantics RETVAL) (flag: unit -> bool) (transf: A -> A -> Prop) (prog tprog: A),
---
>   forall (A: Type) (sem: A -> semantics) (flag: unit -> bool) (transf: A -> A -> Prop) (prog tprog: A),
384,454d352
< Section WITHEXTERNALCALLS.
<   Local Existing Instance Events.symbols_inject_instance.
<   Local Existing Instance StackADT.inject_perm_all.
<   Context `{external_calls_prf: Events.ExternalCalls
<                                   (symbols_inject_instance := Events.symbols_inject_instance) }.
<   Context {i64_helpers_correct_prf: SplitLongproof.I64HelpersCorrect mem}.
<   Context `{memory_model_x_prf: !Unusedglobproof.Mem.MemoryModelX mem}.
< 
< Definition fn_stack_requirements (tp: Asm.program) (id: ident) : Z :=
<   match Globalenvs.Genv.find_symbol (Globalenvs.Genv.globalenv tp) id with
<   | Some b =>
<     match Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv tp) b with
<     | Some (Internal f) => Asm.fn_stacksize f
<     | _ => 0
<     end
<   | None => 0
<   end.
< 
< 
< Definition printable_oracle (tp: Asm.program) : list (ident * Z) :=
<   fold_left (fun acc gd =>
<                match gd with
<                  (id,Some (Gfun (Internal f))) => (id, fn_stack_requirements tp id)::acc
<                | _ => acc
<                end) (prog_defs tp) nil.
< 
< Lemma match_program_no_more_functions:
<   forall {F1 V1 F2 V2}
<          `{Linker F1} `{Linker V1}
<          Mf Mv
<          (p1: program F1 V1) (p2: program F2 V2),
<     match_program Mf Mv p1 p2 ->
<     forall b,
<     Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv p1) b = None ->
<     Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv p2) b = None.
< Proof.
<   intros.
<   generalize (Globalenvs.Genv.find_def_match_2 H1 b).
<   inversion 1.
<   - destruct (Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv p2) b) eqn:?; auto.
<     apply Globalenvs.Genv.find_funct_ptr_iff in Heqo. congruence.
<   - destruct (Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv p2) b) eqn:?; auto.
<     apply Globalenvs.Genv.find_funct_ptr_iff in Heqo. rewrite Heqo in H5.  inv H5.
<     inv H6.
<     symmetry in H4.
<     apply Globalenvs.Genv.find_funct_ptr_iff in H4. congruence.
< Qed.
< 
< 
< Lemma fn_stack_requirements_pos:
<   forall ps p i,
<     Asmgenproof.match_prog ps p ->
<     0 <= fn_stack_requirements p i.
< Proof.
<   unfold fn_stack_requirements.
<   intros. repeat destr; try omega.
<   destruct (Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv ps) b) eqn:FFPMACH.
<   - edestruct (Asmgenproof.functions_translated _ _ H _ _ FFPMACH) as (if0 & FFPASM & EQ). rewrite Heqo0 in FFPASM. inv FFPASM.
<     unfold Asmgen.transf_fundef, transf_partial_fundef in EQ.
<     destr_in EQ. monadInv EQ.
<     unfold Asmgen.transf_function in EQ0. monadInv EQ0. repeat destr_in EQ1. unfold Asmgen.transl_function in EQ.
<     monadInv EQ. repeat destr_in EQ1. simpl.
<     unfold StackADT.frame_info_of_size_and_pubrange in Heqo1. destr_in Heqo1.
<   - eapply match_program_no_more_functions in FFPMACH; eauto. congruence.
< Qed.
< 
< Definition mk_init_stk {F V} (p: AST.program F V) : StackADT.stack :=
<   (Some (StackADT.make_singleton_frame_adt
<            (Globalenvs.Genv.genv_next (Globalenvs.Genv.globalenv p)) 0 0), nil) :: nil .
< 
< 
457,460c355,357
<     match_prog p tp ->
<     let init_stk := mk_init_stk tp in
<   forward_simulation (Cstrategy.semantics (fn_stack_requirements tp) p) (Asm.semantics tp init_stk)
<   /\ backward_simulation (atomic (Cstrategy.semantics (fn_stack_requirements tp) p)) (Asm.semantics tp init_stk).
---
>   match_prog p tp ->
>   forward_simulation (Cstrategy.semantics p) (Asm.semantics tp)
>   /\ backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).
469,471c366,367
<   repeat DestructM.
<   intros init_stk.
<   assert (F: forward_simulation (Cstrategy.semantics (fn_stack_requirements tp) p) (Asm.semantics tp init_stk)).
---
>   repeat DestructM. subst tp.
>   assert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)).
474c370
<     eapply SimplExprproof.transl_program_correct; try eassumption. intros; eapply fn_stack_requirements_pos. subst; eauto.
---
>     eapply SimplExprproof.transl_program_correct; eassumption.
486c382
<     eapply match_if_simulation. eassumption. intros; eapply Tailcallproof.transf_program_correct; eauto.
---
>     eapply match_if_simulation. eassumption. exact Tailcallproof.transf_program_correct.
488c384
<     eapply match_if_simulation. eassumption. eapply Inliningproof.transf_program_correct; eassumption.
---
>     eapply Inliningproof.transf_program_correct; eassumption.
491c387
<     eapply match_if_simulation. eassumption. apply Constpropproof.transf_program_correct.
---
>     eapply match_if_simulation. eassumption. exact Constpropproof.transf_program_correct.
493c389
<     eapply match_if_simulation. eassumption. apply Renumberproof.transf_program_correct.
---
>     eapply match_if_simulation. eassumption. exact Renumberproof.transf_program_correct.
495c391
<     eapply match_if_simulation. eassumption. intros; eapply CSEproof.transf_program_correct; assumption.
---
>     eapply match_if_simulation. eassumption. exact CSEproof.transf_program_correct.
497c393
<     eapply match_if_simulation. eassumption. intros; eapply Deadcodeproof.transf_program_correct; eassumption.
---
>     eapply match_if_simulation. eassumption. exact Deadcodeproof.transf_program_correct; eassumption.
509c405
<     eapply match_if_simulation. eassumption. apply Debugvarproof.transf_program_correct.
---
>     eapply match_if_simulation. eassumption. exact Debugvarproof.transf_program_correct.
511,542c407,410
<     replace (fn_stack_requirements tp) with (Stackingproof.fn_stack_requirements p20).
<   eapply Stackingproof.transf_program_correct with
<       (return_address_offset := Asmgenproof0.return_address_offset);
<     try assumption.
<     exact (Asmgenproof.return_address_exists).
<     {
<       clear - M19 MM.
<       subst.
<       unfold Stackingproof.fn_stack_requirements, fn_stack_requirements.
<       apply Axioms.extensionality.
<       intros i.
<       erewrite Asmgenproof.symbols_preserved; eauto.
<       destruct (Globalenvs.Genv.find_symbol (Globalenvs.Genv.globalenv p20) i) eqn:?; auto.
<       destruct (Globalenvs.Genv.find_funct_ptr (Globalenvs.Genv.globalenv p20) b) eqn:?; auto.
<       eapply Asmgenproof.functions_translated in Heqo0. 2: eauto.
<       destruct Heqo0 as (tf & FFP & TF); rewrite FFP.
<       destruct f; simpl in *; monadInv TF; auto.
<       unfold Asmgen.transf_function in EQ. monadInv EQ. destr_in EQ1. inv EQ1.
<       unfold Asmgen.transl_function in EQ0. monadInv EQ0. repeat destr_in EQ1. simpl. auto.
<       eapply match_program_no_more_functions in Heqo0; eauto. rewrite Heqo0. auto.
<     }
<   eapply compose_forward_simulations.
<     instantiate (1 := Mach.semantics2 Asmgenproof0.return_address_offset p20).
<     apply Mach2Mach2.mach2_simulation.
<     eapply Stackingproof.stacking_frame_correct; eauto.
<     subst. unfold init_stk, mk_init_stk.
<     replace (Globalenvs.Genv.genv_next (Globalenvs.Genv.globalenv tp))
<       with (Globalenvs.Genv.genv_next (Globalenvs.Genv.globalenv p20)).
<     eapply Asmgenproof.transf_program_correct. eassumption.
<     eapply Stackingproof.stacking_frame_correct; eauto.
<     eapply Globalenvs.Genv.senv_transf_partial in M19.
<     destruct M19 as (NB & _). simpl in NB. auto.
---
>     eapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).
>     exact Asmgenproof.return_address_exists.
>     eassumption.
>   eapply Asmgenproof.transf_program_correct; eassumption.
553,555c421,422
<     match_prog p tp ->
<     let init_stk := mk_init_stk tp in
<   backward_simulation (Csem.semantics (fn_stack_requirements tp) p) (Asm.semantics tp init_stk).
---
>   match_prog p tp ->
>   backward_simulation (Csem.semantics p) (Asm.semantics tp).
558c425
<   apply compose_backward_simulation with (atomic (Cstrategy.semantics (fn_stack_requirements tp) p)).
---
>   apply compose_backward_simulation with (atomic (Cstrategy.semantics p)).
567,568d433
< 
< 
583,585c448,449
<     transf_c_program p = OK tp ->
<     let init_stk := mk_init_stk tp in
<   backward_simulation (Csem.semantics (fn_stack_requirements tp) p) (Asm.semantics tp init_stk).
---
>   transf_c_program p = OK tp ->
>   backward_simulation (Csem.semantics p) (Asm.semantics tp).
590,591d453
< 
< 
610,612c472
<       /\
<       let init_stk := mk_init_stk asm_program in
<       backward_simulation (Csem.semantics (fn_stack_requirements asm_program) c_program) (Asm.semantics asm_program init_stk).
---
>    /\ backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).
622,626d481
< 
< 
< 
< End WITHEXTERNALCALLS.
< 
