154,159c154,159
<       forall (res: reg)            (**r where to store the result, if [None] *)
<         (f: function)         (**r calling function *)
<         (sp: val)             (**r stack pointer in calling function *)
<         (pc: node)            (**r program point in calling function *)
<         (rs: regset),         (**r register state in calling function *)
<         stackframe.
---
>       forall (res: reg)            (**r where to store the result *)
>              (f: function)         (**r calling function *)
>              (sp: val)             (**r stack pointer in calling function *)
>              (pc: node)            (**r program point in calling function *)
>              (rs: regset),         (**r register state in calling function *)
>       stackframe.
=====================================================================================================
161c161
< Inductive state `{memory_model_ops: Mem.MemoryModelOps} : Type :=
---
> Inductive state : Type :=
=====================================================================================================164,168c164,168
<         (f: function)            (**r current function *)
<         (sp: val)           (**r stack pointer *)
<         (pc: node)          (**r current program point in [c] *)
<         (rs: regset)        (**r register state *)
<         (m: mem),           (**r memory state *)
---
>              (f: function)            (**r current function *)
>              (sp: val)                (**r stack pointer *)
>              (pc: node)               (**r current program point in [c] *)
>              (rs: regset)             (**r register state *)
>              (m: mem),                (**r memory state *)
=====================================================================================================174,175c174
<              (m: mem)                (**r memory state *)
<              (sz: Z),
---
>              (m: mem),                (**r memory state *)
=====================================================================================================183,187d181
< Section WITHEXTCALLS.
< Context `{external_calls_prf: ExternalCalls}.
< 
< Variable fn_stack_requirements: ident -> Z.
< 
=====================================================================================================208,214c202
< Definition ros_is_function (ros: reg + ident) (rs: regset) (i: ident) : Prop :=
<   match ros with
<   | inl r => exists b o, rs # r = Vptr b o /\ Genv.find_symbol ge i = Some b
<   | inr symb => i = symb
<   end.
< 
< Inductive step : state -> trace -> state -> Prop :=
---
> Inductive step: state -> trace -> state -> Prop :=
=====================================================================================================241,249c229,234
<       forall s f sp pc rs m sig ros args res pc' fd id
<         (RIF: ros_is_function ros rs id),
<         (fn_code f)!pc = Some(Icall sig ros args res pc') ->
<         find_function ros rs = Some fd ->
<         funsig fd = sig ->
<         step (State s f sp pc rs m)
<              E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs##args
<                            (Mem.push_new_stage m)
<                            (fn_stack_requirements id))
---
>       forall s f sp pc rs m sig ros args res pc' fd,
>       (fn_code f)!pc = Some(Icall sig ros args res pc') ->
>       find_function ros rs = Some fd ->
>       funsig fd = sig ->
>       step (State s f sp pc rs m)
>         E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs##args m)
=====================================================================================================251,252c236
<       forall s f stk pc rs m sig ros args fd m' m'' id
<         (RIF: ros_is_function ros rs id),
---
>       forall s f stk pc rs m sig ros args fd m',
=====================================================================================================257d240
<       Mem.tailcall_stage m' = Some m'' ->
=====================================================================================================259c242
<         E0 (Callstate s fd rs##args m'' (fn_stack_requirements id))
---
>         E0 (Callstate s fd rs##args m')
=====================================================================================================261c244
<       forall s f sp pc rs m ef args res pc' vargs t vres m' m'',
---
>       forall s f sp pc rs m ef args res pc' vargs t vres m',
=====================================================================================================264,268c247,249
<       external_call ef ge vargs (Mem.push_new_stage m) t vres m' ->
<       Mem.unrecord_stack_block m' = Some m'' ->
<       forall (BUILTIN_ENABLED : builtin_enabled ef),
<         step (State s f sp pc rs m)
<              t (State s f sp pc' (regmap_setres res vres rs) m'')
---
>       external_call ef ge vargs m t vres m' ->
>       step (State s f sp pc rs m)
>          t (State s f sp pc' (regmap_setres res vres rs) m')
=====================================================================================================290,293c271,273
<       forall s f args m m' stk m'' sz,
<         Mem.alloc m 0 f.(fn_stacksize) = (m', stk) ->
<         Mem.record_stack_blocks m' (make_singleton_frame_adt stk (fn_stacksize f) sz) = Some m'' ->
<       step (Callstate s (Internal f) args m sz)
---
>       forall s f args m m' stk,
>       Mem.alloc m 0 f.(fn_stacksize) = (m', stk) ->
>       step (Callstate s (Internal f) args m)
=====================================================================================================299c279
<                   m'')
---
>                   m')
=====================================================================================================301,303c281,283
<       forall s ef args res t m m' sz,
<         external_call ef ge args m t res m' ->
<       step (Callstate s (External ef) args m sz)
---
>       forall s ef args res t m m',
>       external_call ef ge args m t res m' ->
>       step (Callstate s (External ef) args m)
=====================================================================================================306,309c286,288
<       forall res f sp pc rs s vres m m',
<         Mem.unrecord_stack_block m = Some m' ->
<         step (Returnstate (Stackframe res f sp pc rs :: s) vres m)
<              E0 (State s f sp pc (rs#res <- vres) m').
---
>       forall res f sp pc rs s vres m,
>       step (Returnstate (Stackframe res f sp pc rs :: s) vres m)
>         E0 (State s f sp pc (rs#res <- vres) m).
=====================================================================================================342c321
<   | initial_state_intro: forall b f m0 m2,
---
>   | initial_state_intro: forall b f m0,
=====================================================================================================348,349c327
<       Mem.record_init_sp m0 = Some m2 ->
<       initial_state p (Callstate nil f nil (Mem.push_new_stage m2) (fn_stack_requirements (prog_main p))).
---
>       initial_state p (Callstate nil f nil m0).
=====================================================================================================368,386c346,357
<   - (* receptiveness *)
<     assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
<     {
<       intros. subst. inv H0. exists s1; auto.
<     }
<     inversion H; subst; auto.
<     + exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
<       destruct (Mem.unrecord_stack _ _ H5) as (b & EQ).
<       edestruct (Mem.unrecord_stack_block_succeeds m2) as (m2' & USB & STK).
<       apply external_call_stack_blocks in EC2.
<       repeat rewrite_stack_blocks.
<       eauto.
<       eexists. eapply exec_Ibuiltin; eauto.
<     + exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
<       exists (Returnstate s0 vres2 m2). econstructor; eauto.
<   - (* trace length *)
<     red; intros; inv H; simpl; try omega.
<     eapply external_call_trace_length; eauto.
<     eapply external_call_trace_length; eauto.
---
> (* receptiveness *)
>   assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
>     intros. subst. inv H0. exists s1; auto.
>   inversion H; subst; auto.
>   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
>   exists (State s0 f sp pc' (regmap_setres res vres2 rs) m2). eapply exec_Ibuiltin; eauto.
>   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
>   exists (Returnstate s0 vres2 m2). econstructor; eauto.
> (* trace length *)
>   red; intros; inv H; simpl; try omega.
>   eapply external_call_trace_length; eauto.
>   eapply external_call_trace_length; eauto.
=====================================================================================================389,390d359
< End WITHEXTCALLS.
< 
=====================================================================================================606,692d574
< 
< (** Invariant of RTL programs  *)
< 
< 
< 
< Definition block_of_stackframe s: option (block * Z) :=
<   match s with
<     Stackframe _ f (Vptr sp _) _ _ => Some (sp, fn_stacksize f)
<   | _ => None
<   end.
< 
< 
< Section STACKINV.
<   Context `{extcallops: ExternalCalls}.
< 
<   Definition mem_state (s: state) : mem :=
<     match s with
<       State _ _ _ _ _ m
<     | Callstate _ _ _ m _
<     | Returnstate _ _ m => m
<     end.
< 
<   Definition stack_equiv_inv s1 s2 :=
<     stack_equiv (Mem.stack (mem_state s1)) (Mem.stack (mem_state s2)).
< 
< 
<   Inductive match_stack : list (option (block * Z)) -> stack -> Prop :=
<   | match_stack_nil s: match_stack nil s
<   | match_stack_cons lsp s f r sp bi z
<                          (REC: match_stack lsp s)
<                          (BLOCKS: frame_adt_blocks f = (sp,bi)::nil)
<                          (PUB: forall o, frame_perm bi o = Public)
<                          (SIZE: frame_size bi = Z.max 0 z):
<       match_stack (Some (sp,z) :: lsp) ( (Some f , r) :: s).
< 
<   Inductive stack_inv : state -> Prop :=
<   | stack_inv_regular: forall s f sp pc rs m o
<                          (MSA1: match_stack (Some (sp, fn_stacksize f)::map block_of_stackframe s) (Mem.stack m)),
<       stack_inv (State s f (Vptr sp o) pc rs m)
<   | stack_inv_call: forall s fd args m sz
<                       (TOPNOPERM: top_tframe_tc (Mem.stack m))
<                       (MSA1: match_stack (map block_of_stackframe s)
<                                              (tl (Mem.stack m))),
<       stack_inv (Callstate s fd args m sz)
<   | stack_inv_return: forall s res m
<                         (TOPNOPERM: top_tframe_prop (fun tf => forall b, in_frames tf b -> forall o k p, ~ Mem.perm m b o k p) (Mem.stack m))
<                         (MSA1: match_stack (map block_of_stackframe s) (tl (Mem.stack m))),
<       stack_inv (Returnstate s res m).
< 
<   Variable fn_stack_requirements: ident -> Z.
<   Variable p: program.
<   Let ge := Genv.globalenv p.
< 
< 
< 
<   Lemma stack_inv_inv:
<     forall S1 t S2,
<       step fn_stack_requirements ge S1 t S2 ->
<       stack_inv S1 -> stack_inv S2.
<   Proof.
<     destruct 1; simpl; intros SI;
<       inv SI; try econstructor; repeat rewrite_stack_blocks; eauto;
<         try solve [inv MSA1; eauto].
<     - constructor. reflexivity.
<     - intros; constructor; reflexivity.
<     - simpl; inv MSA1. inversion 1; subst; eauto.
<     - erewrite <- Mem.free_stack_blocks by eauto.
<       inv MSA1.
<       eapply Mem.free_top_tframe_no_perm; eauto.
<     - intro EQ1; rewrite EQ1 in MSA1; simpl in MSA1. econstructor; eauto; reflexivity.
<     - inv TOPNOPERM; constructor. unfold in_frames. rewrite H1. simpl. easy.
<     - inv MSA1. repeat destr_in H1. econstructor.
<       rewrite_stack_blocks. rewrite <- H3. econstructor; eauto.
<   Qed.
< 
<   Lemma stack_inv_initial:
<     forall S
<       (INIT: initial_state fn_stack_requirements p S),
<       stack_inv S.
<   Proof.
<     intros; inv INIT; econstructor.
<     intros; repeat rewrite_stack_blocks. 
<     constructor. reflexivity.
<     simpl; constructor.
<   Qed.
< 
< End STACKINV.
\ No newline at end of file
