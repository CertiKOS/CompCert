        OCaml version 4.02.3

# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_code : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
val fac_bytes : int list list -> unit = <fun>
# let fac_bytes = write_ecd_instrs fac_dump_file true;;
val fac_bytes : int list list -> unit = <fun>
# let () = write_ecd_instrs fac_dump_file true;;
Characters 9-44:
  let () = write_ecd_instrs fac_dump_file true;;
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type int list list -> unit
       but an expression was expected of type unit
# let () = write_ecd_instrs fac_dump_file true;;
Characters 9-44:
  let () = write_ecd_instrs fac_dump_file true;;
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type int list list -> unit
       but an expression was expected of type unit
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
28 236 131 32 36 68 141 4 36 68 137 8 36 92 137 24 139 219 133 16 116 255 67 141 36 4 137 255 255 255 224 232 216 175 15 5 235 0 0 0 1 187 195 139 8 36 92 139 28 196 131 195 12 236 131 16 36 68 141 4 36 68 137 0 0 0 4 184 36 4 137 255 255 255 180 232 0 0 0 0 163 12 196 131 195 # 
;;
  # let () = write_ecd_instrs fac_dump_file true fac_bytes;;
131 236 28 141 68 36 32 137 68 36 4 137 92 36 8 139 24 133 219 116 16 141 67 255 137 4 36 232 224 255 255 255 15 175 216 235 5 187 1 0 0 0 139 195 139 92 36 8 131 196 28 195 131 236 12 141 68 36 16 137 68 36 4 184 4 0 0 0 137 4 36 232 180 255 255 255 163 0 0 0 0 131 196 12 195 # #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# #use "fac.ml";;
val null_prefix : X86Syntax.prefix =
  {lock_rep = None; seg_override = None; op_override = false;
   addr_override = false}
val ( <| ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val byte_dec_to_hex : int -> string = <fun>
val encode : X86Syntax.instr -> int list = <fun>
val eax : X86Syntax.operand = Reg_op EAX
val ebx : X86Syntax.operand = Reg_op EBX
val ecx : X86Syntax.operand = Reg_op ECX
val edx : X86Syntax.operand = Reg_op EDX
val edi : X86Syntax.operand = Reg_op EDI
val ebp : X86Syntax.operand = Reg_op EBP
val esp : X86Syntax.operand = Reg_op ESP
val imm : int -> X86Syntax.operand = <fun>
val offset : int -> X86Syntax.operand = <fun>
val addr_reg_ofs : X86Syntax.operand -> int -> X86Syntax.operand = <fun>
val addr_glob : int -> X86Syntax.operand = <fun>
val je : int -> X86Syntax.instr = <fun>
val encode_accum :
  int list list * int -> X86Syntax.instr -> int list list * int = <fun>
val encode_instrs : X86Syntax.instr list -> int list list = <fun>
val write_ecd_instrs : string -> bool -> int list list -> unit = <fun>
val fac_code : X86Syntax.instr list =
  [SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some EAX; addrIndex = None});
   TEST (true, Reg_op EBX, Reg_op EBX); Jcc (E_ct, <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some EBX; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   IMUL (false, Reg_op EBX, Some (Reg_op EAX), None);
   JMP (true, false, Imm_op <abstr>, None);
   MOV (true, Reg_op EBX, Imm_op <abstr>);
   MOV (true, Reg_op EAX, Reg_op EBX);
   MOV (true, Reg_op EBX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None);
   SUB (true, Reg_op ESP, Imm_op <abstr>);
   LEA (Reg_op EAX,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None});
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   MOV (true, Reg_op EAX, Imm_op <abstr>);
   MOV (true,
    Address_op {addrDisp = <abstr>; addrBase = Some ESP; addrIndex = None},
    Reg_op EAX);
   CALL (true, false, Imm_op <abstr>, None);
   MOV (true, Offset_op <abstr>, Reg_op EAX);
   ADD (true, Reg_op ESP, Imm_op <abstr>); RET (true, None)]
val fac_bytes : int list list =
  [[131; 236; 28]; [141; 68; 36; 32]; [137; 68; 36; 4]; [137; 92; 36; 8];
   [139; 24]; [133; 219]; [116; 16]; [141; 67; 255]; [137; 4; 36];
   [232; 224; 255; 255; 255]; [15; 175; 216]; [235; 5]; [187; 1; 0; 0; 0];
   [139; 195]; [139; 92; 36; 8]; [131; 196; 28]; [195]; [131; 236; 12];
   [141; 68; 36; 16]; [137; 68; 36; 4]; [184; 4; 0; 0; 0]; [137; 4; 36];
   [232; 180; 255; 255; 255]; [163; 0; 0; 0; 0]; [131; 196; 12]; [195]]
val fac_dump_file : string = "fac_rs"
# let () = write_ecd_instrs fac_dump_file false fac_bytes