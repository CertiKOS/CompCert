19d18
< Require Import StackInj.
==========================================================================================
31d29
< Context `{external_calls_prf: ExternalCalls}.
==========================================================================================
33,35d30
< Existing Instance inject_perm_all.
< 
< Variable fn_stack_requirements: ident -> Z.
==========================================================================================
50,55d44
< Lemma genv_next_preserved:
<   Genv.genv_next tge = Genv.genv_next ge.
< Proof.
<   apply senv_preserved.
< Qed.
< 
==========================================================================================
238c227
<     star (step fn_stack_requirements) tge (State stk f sp pc1 rs1 m)
---
>     star step tge (State stk f sp pc1 rs1 m)
==========================================================================================
317c306
<   forall F g m m' sp base sz hi b m1,
---
>   forall F m m' sp base sz hi b m1,
==========================================================================================
321c310
<   Mem.inject F g m m' ->
---
>   Mem.inject F m m' ->
==========================================================================================
331d319
<   simpl; auto.
==========================================================================================
347c335
<   forall F F' g m1 m2 m1' m2' sp base hi,
---
>   forall F F' m1 m2 m1' m2' sp base hi,
==========================================================================================
352c340
<   Mem.inject F g m1 m1' ->
---
>   Mem.inject F m1 m1' ->
==========================================================================================
365c353
<   clear H0. eapply Mem.valid_block_inject_1; eauto.
---
>   exploit Mem.mi_freeblocks; eauto. congruence.
==========================================================================================
371,380d358
< (** [CompCertX:test-compcert-protect-stack-arg] We have to prove that
< the memory injection introduced by the compilation pass is independent
< of the initial memory i.e. it does not inject new blocks into blocks
< already existing in the initial memory. This is stronger than
< [meminj_preserves_globals], which only preserves blocks associated to
< the global environment. *)
< 
< Section WITHMEMINIT.
< Variable m_init: mem.
< 
==========================================================================================
383d360
<       (NEXT: Ple (Mem.nextblock m_init) bound)
==========================================================================================
390,418d366
< Lemma match_globalenvs_inject_incr:
<   forall j bound,
<     match_globalenvs j bound ->
<     inject_incr (Mem.flat_inj (Mem.nextblock m_init)) j.
< Proof.
<   inversion 1; subst.
<   unfold inject_incr, Mem.flat_inj.
<   intros.
<   destruct (plt b (Mem.nextblock m_init)); try discriminate.
<   inv H0.
<   eapply DOMAIN.
<   xomega.
< Qed.
< 
< Lemma match_globalenvs_inject_separated:
<   forall j bound,
<     match_globalenvs j bound ->
<     inject_separated (Mem.flat_inj (Mem.nextblock m_init)) j m_init m_init.
< Proof.
<   inversion 1; subst.
<   unfold inject_separated, Mem.flat_inj, Mem.valid_block.
<   intros.
<   destruct (plt b1 (Mem.nextblock m_init)); try discriminate.
<   split; auto.
<   destruct (plt b2 bound).
<    exploit IMAGE; eauto. congruence.
<   xomega.
< Qed.
< 
==========================================================================================
460c408
<   forall F g bound ctx rs rs' sp sp' m m',
---
>   forall F bound ctx rs rs' sp sp' m m',
==========================================================================================
464c412
<   Mem.inject F g m m' ->
---
>   Mem.inject F m m' ->
==========================================================================================
497c445
<   forall F g bound ctx rs rs' sp sp' m m',
---
>   forall F bound ctx rs rs' sp sp' m m',
==========================================================================================
501c449
<   Mem.inject F g m m' ->
---
>   Mem.inject F m m' ->
==========================================================================================
516,517d463
< (* The intended meaning of the list of nats is to represent the number of source
< frames that correspond to a given target frame *)
==========================================================================================
519c465
<   list nat -> list stackframe -> list stackframe -> block -> Prop :=
---
>              list stackframe -> list stackframe -> block -> Prop :=
==========================================================================================
523,525c469,471
<       match_stacks F m m' nil nil nil bound
<   | match_stacks_cons: forall res f sp pc rs stk f' sp' rs' stk' bound fenv ctx n l
<         (MS: match_stacks_inside F m m' n l stk stk' f' ctx sp' rs')
---
>       match_stacks F m m' nil nil bound
>   | match_stacks_cons: forall res f sp pc rs stk f' sp' rs' stk' bound fenv ctx
>         (MS: match_stacks_inside F m m' stk stk' f' ctx sp' rs')
==========================================================================================
532,533c478
<         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs < f'.(fn_stacksize))
<         (SSZ3: forall ofs, Mem.perm m sp ofs Max Nonempty -> 0 <= ofs < f.(fn_stacksize))
---
>         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= f'.(fn_stacksize))
==========================================================================================
535,536c480
<         (BELOW: Plt sp' bound)
<         (BELOW': Plt sp (Mem.nextblock m)),
---
>         (BELOW: Plt sp' bound),
==========================================================================================
538d481
<                    (S n :: l)
==========================================================================================
542,543c485,486
<   | match_stacks_untailcall: forall stk res f' sp' rpc rs' stk' bound ctx n l
<         (MS: match_stacks_inside F m m' n l stk stk' f' ctx sp' rs')
---
>   | match_stacks_untailcall: forall stk res f' sp' rpc rs' stk' bound ctx
>         (MS: match_stacks_inside F m m' stk stk' f' ctx sp' rs')
==========================================================================================
546c489
<         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs < f'.(fn_stacksize))
---
>         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= f'.(fn_stacksize))
==========================================================================================
550d492
<                    (n :: l)
==========================================================================================
554,555c496
< (* The list of nats serve the same purpose as above, the nat gives information
< about the current target frame. *)
---
> 
==========================================================================================
557,559c498,500
<        nat -> list nat -> list stackframe -> list stackframe -> function -> context -> block -> regset -> Prop :=
<   | match_stacks_inside_base: forall stk stk' f' ctx sp' rs' l
<         (MS: match_stacks F m m' l stk stk' sp')
---
>         list stackframe -> list stackframe -> function -> context -> block -> regset -> Prop :=
>   | match_stacks_inside_base: forall stk stk' f' ctx sp' rs'
>         (MS: match_stacks F m m' stk stk' sp')
==========================================================================================
562,564c503,505
<       match_stacks_inside F m m' O l stk stk' f' ctx sp' rs'
<   | match_stacks_inside_inlined: forall res f sp pc rs stk stk' f' fenv ctx sp' rs' ctx' n l
<         (MS: match_stacks_inside F m m' n l stk stk' f' ctx' sp' rs')
---
>       match_stacks_inside F m m' stk stk' f' ctx sp' rs'
>   | match_stacks_inside_inlined: forall res f sp pc rs stk stk' f' fenv ctx sp' rs' ctx'
>         (MS: match_stacks_inside F m m' stk stk' f' ctx' sp' rs')
==========================================================================================
573,576c514,515
<         (SBELOW: context_stack_call ctx' ctx)
<         (SSZ3: forall ofs, Mem.perm m sp ofs Max Nonempty -> 0 <= ofs < f.(fn_stacksize))
<         (BELOW': Plt sp (Mem.nextblock m)),
<       match_stacks_inside F m m' (S n) l (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk)
---
>         (SBELOW: context_stack_call ctx' ctx),
>       match_stacks_inside F m m' (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: stk)
==========================================================================================
579d517
< 
==========================================================================================
587,614d524
< Lemma match_stacks_length:
<   forall l stk stk' bound,
<     match_stacks F m m' l stk stk' bound -> length stk' = length l
< with match_stacks_inside_length:
<        forall n l stk stk' f ctx sp rs',
<          match_stacks_inside F m m' n l stk stk' f ctx sp rs' -> length stk' = length l.
< Proof.
<   induction 1; simpl; eauto.
<   induction 1; simpl; eauto.
< Qed.
< 
< Fixpoint sum_list (l: list nat) : nat :=
<   match l with
<     nil => O
<   | a::r => (a + sum_list r)%nat
<   end.
< 
< Lemma match_stacks_length':
<   forall l stk stk' bound,
<     match_stacks F m m' l stk stk' bound -> length stk = sum_list l
< with match_stacks_inside_length':
<        forall n l stk stk' f ctx sp rs',
<          match_stacks_inside F m m' n l stk stk' f ctx sp rs' -> length stk = (n + sum_list l)%nat.
< Proof.
<   induction 1; simpl; eauto.
<   induction 1; simpl; eauto.
< Qed.
< 
==========================================================================================
616,617c526,527
<   forall l stk stk' bound,
<   match_stacks F m m' l stk stk' bound -> exists b, match_globalenvs F b
---
>   forall stk stk' bound,
>   match_stacks F m m' stk stk' bound -> exists b, match_globalenvs F b
==========================================================================================
619,620c529,530
<   forall n l stk stk' f ctx sp rs',
<   match_stacks_inside F m m' n l stk stk' f ctx sp rs' -> exists b, match_globalenvs F b.
---
>   forall stk stk' f ctx sp rs',
>   match_stacks_inside F m m' stk stk' f ctx sp rs' -> exists b, match_globalenvs F b.
==========================================================================================
626,669d535
< Lemma match_stacks_inject_incr:
<   forall l stk stk' bound,
<     match_stacks F m m' l stk stk' bound ->
<     inject_incr (Mem.flat_inj (Mem.nextblock m_init)) F.
< Proof.
<   intros.
<   exploit match_stacks_globalenvs; eauto.
<   destruct 1.
<   eapply match_globalenvs_inject_incr; eauto.
< Qed.
< 
< Lemma match_stacks_inject_separated:
<   forall l stk stk' bound,
<     match_stacks F m m' l stk stk' bound ->
<     inject_separated (Mem.flat_inj (Mem.nextblock m_init)) F m_init m_init.
< Proof.
<   intros.
<   exploit match_stacks_globalenvs; eauto.
<   destruct 1.
<   eapply match_globalenvs_inject_separated; eauto.
< Qed.
< 
< Lemma match_stacks_inside_inject_incr:
<   forall n l stk stk' f ctx sp rs', 
<     match_stacks_inside F m m' n l stk stk' f ctx sp rs' ->
<     inject_incr (Mem.flat_inj (Mem.nextblock m_init)) F.
< Proof.
<   intros.
<   exploit match_stacks_inside_globalenvs; eauto.
<   destruct 1.
<   eapply match_globalenvs_inject_incr; eauto.
< Qed.
< 
< Lemma match_stacks_inside_inject_separated:
<   forall n l stk stk' f ctx sp rs', 
<     match_stacks_inside F m m' n l stk stk' f ctx sp rs' ->
<     inject_separated (Mem.flat_inj (Mem.nextblock m_init)) F m_init m_init.
< Proof.
<   intros.
<   exploit match_stacks_inside_globalenvs; eauto.
<   destruct 1.
<   eapply match_globalenvs_inject_separated; eauto.
< Qed.
< 
==========================================================================================
678,679c544,545
<   forall n l stk stk' f ctx sp rs',
<   match_stacks_inside F m m' n l stk stk' f ctx sp rs' -> meminj_preserves_globals ge F.
---
>   forall stk stk' f ctx sp rs',
>   match_stacks_inside F m m' stk stk' f ctx sp rs' -> meminj_preserves_globals ge F.
==========================================================================================
686,687c552,553
<   forall l stk stk' bound bound1,
<   match_stacks F m m' l stk stk' bound ->
---
>   forall stk stk' bound bound1,
>   match_stacks F m m' stk stk' bound ->
==========================================================================================
689c555
<   match_stacks F m m' l stk stk' bound1.
---
>   match_stacks F m m' stk stk' bound1.
==========================================================================================
702c568
<   forall l stk stk' bound, match_stacks F m m' l stk stk' bound ->
---
>   forall stk stk' bound, match_stacks F m m' stk stk' bound ->
==========================================================================================
711,713c577,578
<                               Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p)
<          (NB1: Ple (Mem.nextblock m) (Mem.nextblock m1)),
<   match_stacks F1 m1 m1' l stk stk' bound
---
>                Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p),
>   match_stacks F1 m1 m1' stk stk' bound
==========================================================================================
716,717c581,582
<   forall n l stk stk' f' ctx sp' rs1,
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs1 ->
---
>   forall stk stk' f' ctx sp' rs1,
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs1 ->
==========================================================================================
728,730c593,594
<                               Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p)
<          (NB1: Ple (Mem.nextblock m) (Mem.nextblock m1)),
<   match_stacks_inside F1 m1 m1' n l stk stk' f' ctx sp' rs2.
---
>                Mem.perm m1' b ofs k p -> Mem.perm m' b ofs k p),
>   match_stacks_inside F1 m1 m1' stk stk' f' ctx sp' rs2.
==========================================================================================
748,750d611
<   intros; eapply SSZ3; eauto.
<   xomega.
< 
778,779d638
<   intros; eapply SSZ3; eauto. eapply PERM1; eauto. xomega.
<   xomega.
==========================================================================================
783,784c642,643
<   forall l stk stk' bound,
<   match_stacks F m m' l stk stk' bound -> stk = nil -> stk' = nil
---
>   forall stk stk' bound,
>   match_stacks F m m' stk stk' bound -> stk = nil -> stk' = nil
==========================================================================================
786,787c645,646
<   forall n l stk stk' f ctx sp rs,
<   match_stacks_inside F m m' n l stk stk' f ctx sp rs -> stk = nil -> stk' = nil /\ ctx.(retinfo) = None.
---
>   forall stk stk' f ctx sp rs,
>   match_stacks_inside F m m' stk stk' f ctx sp rs -> stk = nil -> stk' = nil /\ ctx.(retinfo) = None.
==========================================================================================
803,805c662,664
<   forall F m m' n l stk stk' f' ctx sp' rs' r v,
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' (rs'#(sreg ctx r) <- v).
---
>   forall F m m' stk stk' f' ctx sp' rs' r v,
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs' ->
>   match_stacks_inside F m m' stk stk' f' ctx sp' (rs'#(sreg ctx r) <- v).
==========================================================================================
809d667
<   apply Ple_refl.
==========================================================================================
813,815c671,673
<   forall F m m' n l stk stk' f' ctx sp' rs' res v,
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' (regmap_setres (sbuiltinres ctx res) v rs').
---
>   forall F m m' stk stk' f' ctx sp' rs' res v,
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs' ->
>   match_stacks_inside F m m' stk stk' f' ctx sp' (regmap_setres (sbuiltinres ctx res) v rs').
==========================================================================================
824,825c682,683
<   forall F m m' n l stk stk' f' ctx sp' rs' chunk b ofs v m1 chunk' b' ofs' v' m1',
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
---
>   forall F m m' stk stk' f' ctx sp' rs' chunk b ofs v m1 chunk' b' ofs' v' m1',
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs' ->
==========================================================================================
828c686
<   match_stacks_inside F m1 m1' n l stk stk' f' ctx sp' rs'.
---
>   match_stacks_inside F m1 m1' stk stk' f' ctx sp' rs'.
==========================================================================================
832d689
<   rewrite (Mem.nextblock_store _ _ _ _ _ _ H0); apply Ple_refl.
==========================================================================================
838,841c695,697
<   forall F m m' n l stk stk' f' ctx sp' rs',
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
<   forall sz m1 b F1 delta
<     (* (VBINJ: forall b b' delta, F b = Some (b', delta) -> Mem.valid_block m b) *),
---
>   forall F m m' stk stk' f' ctx sp' rs',
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs' ->
>   forall sz m1 b F1 delta,
==========================================================================================
847c703
<   match_stacks_inside F1 m1 m' n l stk stk' f' ctx sp' rs'.
---
>   match_stacks_inside F1 m1 m' stk stk' f' ctx sp' rs'.
==========================================================================================
858d713
<   rewrite (Mem.nextblock_alloc _ _ _ _ _ H); xomega.
==========================================================================================
867,872d721
<   intros.
<   eapply SSZ3; eauto. eapply Mem.perm_alloc_inv in H5; eauto.
<   destr_in H5.
<   subst.
<   eapply Mem.fresh_block_alloc in BELOW'. easy. eauto.
<   erewrite Mem.nextblock_alloc; eauto. xomega.
==========================================================================================
875,901d723
< Lemma match_stacks_record_left:
<   forall F m m' l stk stk' sp',
<   match_stacks F m m' l stk stk' sp' ->
<   forall f m1,
<     Mem.record_stack_blocks m f = Some m1 ->
<     match_stacks F m1 m' l stk stk' sp'.
< Proof.
<   intros.
<   eapply match_stacks_invariant; eauto.
<   intros. eapply Mem.record_stack_block_perm; eauto.
<   apply Mem.record_stack_block_nextblock in H0. rewrite H0; xomega.
< Qed.
< 
< Lemma match_stacks_inside_record_left:
<   forall F m m' n l stk stk' f' ctx sp' rs',
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
<   forall f m1,
<     Mem.record_stack_blocks m f = Some m1 ->
<     match_stacks_inside F m1 m' n l stk stk' f' ctx sp' rs'.
< Proof.
<   intros.
<   eapply match_stacks_inside_invariant; eauto.
<   intros. eapply Mem.record_stack_block_perm; eauto.
<   apply Mem.record_stack_block_nextblock in H0. rewrite H0; xomega.
< Qed.
< 
< 
==========================================================================================
905,906c727,728
<   forall F m m' l stk stk' sp b lo hi m1,
<   match_stacks F m m' l stk stk' sp ->
---
>   forall F m m' stk stk' sp b lo hi m1,
>   match_stacks F m m' stk stk' sp ->
==========================================================================================
908c730
<   match_stacks F m1 m' l stk stk' sp.
---
>   match_stacks F m1 m' stk stk' sp.
==========================================================================================
912d733
<   rewrite (Mem.nextblock_free _ _ _ _ _ H0); xomega.
==========================================================================================
916,917c737,738
<   forall F m m' l stk stk' sp lo hi m1',
<   match_stacks F m m' l stk stk' sp ->
---
>   forall F m m' stk stk' sp lo hi m1',
>   match_stacks F m m' stk stk' sp ->
==========================================================================================
919c740
<   match_stacks F m m1' l stk stk' sp.
---
>   match_stacks F m m1' stk stk' sp.
==========================================================================================
924d744
<   xomega.
==========================================================================================
958d777
< Variable g: frameinj.
==========================================================================================
963c782
< Hypothesis INJ: Mem.inject F1 g m1 m1'.
---
> Hypothesis INJ: Mem.inject F1 m1 m1'.
==========================================================================================
966d784
< Hypothesis NB_LE: Ple (Mem.nextblock m1) (Mem.nextblock m2).
==========================================================================================
969,970c787,788
<   forall l stk stk' bound,
<   match_stacks F1 m1 m1' l stk stk' bound ->
---
>   forall stk stk' bound,
>   match_stacks F1 m1 m1' stk stk' bound ->
==========================================================================================
972c790
<   match_stacks F2 m2 m2' l stk stk' bound
---
>   match_stacks F2 m2 m2' stk stk' bound
==========================================================================================
974,975c792,793
<   forall n l stk stk' f' ctx sp' rs',
<   match_stacks_inside F1 m1 m1' n l stk stk' f' ctx sp' rs' ->
---
>   forall stk stk' f' ctx sp' rs',
>   match_stacks_inside F1 m1 m1' stk stk' f' ctx sp' rs' ->
==========================================================================================
977c795
<   match_stacks_inside F2 m2 m2' n l stk stk' f' ctx sp' rs'.
---
>   match_stacks_inside F2 m2 m2' stk stk' f' ctx sp' rs'.
==========================================================================================
989c807
<     intros. apply SSZ2; auto. apply MAXPERM'; auto. red; xomega. xomega.
---
>     intros. apply SSZ2; auto. apply MAXPERM'; auto. red; xomega.
==========================================================================================
1000d817
<     xomega.
==========================================================================================
1015,1016c832,833
<   forall fenv F m m' n l stk stk' f' ctx sp' rs' ctx' f,
<   match_stacks_inside F m m' n l stk stk' f' ctx sp' rs' ->
---
>   forall fenv F m m' stk stk' f' ctx sp' rs' ctx' f,
>   match_stacks_inside F m m' stk stk' f' ctx sp' rs' ->
==========================================================================================
1022c839
<   match_stacks_inside F m m' n l stk stk' f' ctx' sp' rs'.
---
>   match_stacks_inside F m m' stk stk' f' ctx' sp' rs'.
==========================================================================================
1039,1223d855
< Definition blocks_of_stackframe stk :=
<   match stk with
<     Stackframe _ f (Vptr sp _) _ _ => Some (sp, fn_stacksize f)
<   | _ => None
<   end.
< 
< Definition stack_injects j m :=
<   forall b : block, in_stack (Mem.stack m) b -> exists (b' : block) (delta : Z), j b = Some (b', delta).
< 
< Section INLINE_SIZES.
< 
<   Inductive inline_sizes : frameinj -> stack -> stack -> Prop :=
<   | inline_sizes_nil: inline_sizes nil nil nil
<   | inline_sizes_cons g s1 s2 t1 n t2:
<       inline_sizes g (drop (S n) s1) s2 ->
<       nth_error s1 n = Some t1 ->
<       size_frames t2 <= size_frames t1 ->
<       inline_sizes (S n::g) s1 (t2 :: s2).
< 
<   Lemma inline_sizes_up:
<     forall g s1 s2,
<       inline_sizes g s1 s2 ->
<       inline_sizes (1%nat :: g) ((None,nil)::s1) ((None,nil)::s2).
<   Proof.
<     intros. econstructor; simpl; eauto. omega.
<   Qed.
< 
<   Lemma inline_sizes_upstar:
<     forall n g s1 s2 l,
<       inline_sizes (n :: g) s1 s2 ->
<       inline_sizes (S n :: g) ((None,l) :: s1) s2.
<   Proof.
<     intros n g s1 s2 l SZ.
<     inv SZ.
<     econstructor; simpl; eauto.
<   Qed.
< 
<   Lemma inline_sizes_upright:
<     forall g n f1 s1 s2,
<       inline_sizes (S (S n) :: g) (f1::s1) s2 ->
<       inline_sizes (1%nat :: S n :: g) ((None, opt_cons (fst f1) (snd f1)) :: s1)  ((None,nil)::s2).
<   Proof.
<     intros g n f1 s1 s2 IS. inv IS.
<     simpl in *. repeat destr_in H2. 
<     simpl in *.
<     repeat econstructor; eauto.
<     change (size_frames (None,nil)) with 0. apply size_frames_pos.
<   Qed.
< 
<   Lemma inline_sizes_record:
<     forall g tf1 r1 tf2 r2 fr1 fr2 
<       (SZ: inline_sizes (1%nat::g) (tf1 :: r1) (tf2 :: r2))
<       (EQ: opt_size_frame fr1 = opt_size_frame fr2),
<       inline_sizes (1%nat::g) ((fr1, opt_cons (fst tf1) (snd tf1)) :: r1) ((fr2 , opt_cons (fst tf2) (snd tf2)) :: r2).
<   Proof.
<     intros. inv SZ.
<     simpl in *. inv H5.
<     econstructor; simpl; eauto.
<     rewrite ! size_frames_cons. simpl. unfold size_frame. rewrite EQ. apply Z.max_le_compat_l; auto.
<     fold size_frame. unfold size_frames in H6.
<     rewrite ! map_opt_cons.
<     rewrite <- ! max_opt_size_frame_tailcall. auto.
<   Qed.
< 
<   Lemma inline_sizes_record':
<     forall g tf1 r1 tf2 r2 fr1 fr2 
<       (SZ: inline_sizes (1%nat::g) ((None, tf1) :: r1) ((None,tf2) :: r2))
<       (EQ: opt_size_frame fr1 = opt_size_frame fr2),
<       inline_sizes (1%nat::g) ((fr1, tf1) :: r1) ((fr2 , tf2) :: r2).
<   Proof.
<     intros. inv SZ.
<     simpl in *. inv H5.
<     econstructor; simpl; eauto.
<     rewrite ! size_frames_cons. rewrite EQ. apply Z.max_le_compat_l; auto.
<     unfold size_frames in H6.
<     revert H6.
<     rewrite ! max_opt_size_frame_tailcall. simpl. auto.
<   Qed.
< 
<   
<   Lemma inline_sizes_record_left:
<     forall g f1 r1 s2 fr1
<       (SIZES: inline_sizes g ((None, f1) :: r1) s2),
<       inline_sizes g ((fr1,  f1) :: r1) s2.
<   Proof.
<     intros. inv SIZES.
<     destruct n; simpl in *. inv H0.
<     econstructor; simpl; auto. etransitivity. apply H1.
<     rewrite <- size_frames_tc. rewrite ! size_frames_cons. simpl.
<     apply Z.max_le_compat. apply opt_size_frame_pos. omega.
<     econstructor; simpl; eauto.
<   Qed.
< 
<   Lemma inline_sizes_down:
<     forall g s1 s2,
<       inline_sizes (1%nat::g) s1 s2 ->
<       inline_sizes g (tl s1) (tl s2).
<   Proof.
<     intros. inv H. simpl in *; auto.
<   Qed.
< 
<   Lemma inline_sizes_downstar:
<     forall g n s1 s2,
<       inline_sizes (S (S n) :: g) s1 s2 ->
<       inline_sizes (S n :: g) (tl s1) s2.
<   Proof.
<     intros. inv H. simpl in *. repeat destr_in H3.
<     econstructor; simpl; eauto.
<   Qed.
< 
<   Fixpoint maxl (l: list nat) : option nat :=
<     match l with
<     | nil => None
<     | a::r => match maxl r with
<                Some b => Some (Nat.max a b)
<              | None => Some a
<              end
<     end.
< 
<   Lemma max_exists:
<     forall l i, In i l -> exists mi, maxl l = Some mi.
<   Proof.
<     destruct l; simpl. easy. intros. destr; eauto.
<   Qed.
< 
<   Lemma max_in:
<     forall l m,
<       maxl l = Some m ->
<       In m l /\ forall x, In x l -> (x <= m)%nat.
<   Proof.
<     induction l; simpl; intros; eauto. easy.
<     repeat destr_in H.
<     - specialize (IHl _ eq_refl). destruct IHl as (IN & MAX).
<       split. destruct (le_dec n a). rewrite Nat.max_l; auto.
<       rewrite Nat.max_r by omega. auto.
<       intros. destruct H. subst. apply Nat.le_max_l.
<       apply Nat.max_le_iff. apply MAX in H. auto.
<     - destruct l. simpl. split; auto. intros x [|[]]; subst; omega.
<       simpl in Heqo. destr_in Heqo.
<   Qed.
< 
<   Lemma nth_error_take:
<     forall {A} n n' (s s': list A) t,
<       lt n n' ->
<       take n' s = Some s' ->
<       nth_error s n = Some t ->
<       nth_error s' n = Some t.
<   Proof.
<     induction n; simpl; intros; eauto.
<     repeat destr_in H1.
<     destruct n'; simpl in *. omega. repeat destr_in H0. auto.
<     destruct n'. omega. simpl in *. repeat destr_in H0.
<     eapply IHn. 2: eauto. omega. auto.
<   Qed.
< 
<   Lemma inline_sizes_size_stack:
<     forall g s1 s2
<       (SIZES: inline_sizes g s1 s2),
<       size_stack s2 <= size_stack s1.
<   Proof.
<     induction 1; simpl; intros; eauto. omega.
<     destruct (take_succeeds (S n) s1) as (t & TAKE).
<     eapply nth_error_Some; eauto. congruence.
<     rewrite (take_drop _ _ _ TAKE).
<     rewrite size_stack_app.
<     cut (size_frames t2 <= size_stack t). intros; omega.
<     etransitivity. apply H0.
<     eapply size_frames_le_size_stack; eauto.
<     eapply nth_error_take in H; eauto.
<     eapply nth_error_In; eauto.
<   Qed.
<   
<   Lemma inline_sizes_le:
<     forall g s1 s2,
<       inline_sizes (1%nat::g) s1 s2 ->
<       size_stack (tl s2) <= size_stack (tl s1).
<   Proof.
<     intros g s1 s2 SZ.
<     eapply inline_sizes_size_stack.
<     apply inline_sizes_down. eauto.
<   Qed.
< 
< End INLINE_SIZES.
< 
< 
==========================================================================================
1225,1226c857,858
< | match_regular_states: forall stk f sp pc rs m stk' f' sp' rs' m' F g fenv ctx n l
<         (MS: match_stacks_inside F m m' n g stk stk' f' ctx sp' rs')
---
>   | match_regular_states: forall stk f sp pc rs m stk' f' sp' rs' m' F fenv ctx
>         (MS: match_stacks_inside F m m' stk stk' f' ctx sp' rs')
==========================================================================================
1231,1232c863
<         (MINJ: Mem.inject F (S n :: g ++ l) m m')
<         (SI: stack_injects F m)
---
>         (MINJ: Mem.inject F m m')
==========================================================================================
1236,1238c867
<         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs < f'.(fn_stacksize))
<         (SSZ3: forall ofs, Mem.perm m sp ofs Max Nonempty -> 0 <= ofs < f.(fn_stacksize))
<         (SIZES: inline_sizes (S n :: g ++ l) (Mem.stack m) (Mem.stack m')),
---
>         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= f'.(fn_stacksize)),
==========================================================================================
1241,1242c870,871
< | match_call_states: forall stk fd args m stk' fd' args' m' cunit F g l sz
<         (MS: match_stacks F m m' g stk stk' (Mem.nextblock m'))
---
>   | match_call_states: forall stk fd args m stk' fd' args' m' cunit F
>         (MS: match_stacks F m m' stk stk' (Mem.nextblock m'))
==========================================================================================
1246,1252c875,879
<         (MINJ: Mem.inject F (1%nat :: g ++ l) m m')
<         (SI: stack_injects F m)
<         (SIZES: inline_sizes (1%nat :: g ++ l) (Mem.stack m) (Mem.stack m')),
<       match_states (Callstate stk fd args m sz)
<                    (Callstate stk' fd' args' m' sz)
< | match_call_regular_states: forall stk f vargs m stk' f' sp' rs' m' F g fenv ctx ctx' pc' pc1' rargs n l sz
<         (MS: match_stacks_inside F m m' n g stk stk' f' ctx sp' rs')
---
>         (MINJ: Mem.inject F m m'),
>       match_states (Callstate stk fd args m)
>                    (Callstate stk' fd' args' m')
>   | match_call_regular_states: forall stk f vargs m stk' f' sp' rs' m' F fenv ctx ctx' pc' pc1' rargs
>         (MS: match_stacks_inside F m m' stk stk' f' ctx sp' rs')
==========================================================================================
1259,1260c886
<         (MINJ: Mem.inject F (S n :: g ++ l) m m')
<         (SI: stack_injects F m)
---
>         (MINJ: Mem.inject F m m')
==========================================================================================
1264,1266c890,891
<         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs < f'.(fn_stacksize))
<         (SIZES: inline_sizes (S n :: g ++ l) (Mem.stack m) (Mem.stack m')),
<       match_states (Callstate stk (Internal f) vargs m sz)
---
>         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= f'.(fn_stacksize)),
>       match_states (Callstate stk (Internal f) vargs m)
==========================================================================================
1268,1269c893,894
< | match_return_states: forall stk v m stk' v' m' F g l
<         (MS: match_stacks F m m' g stk stk' (Mem.nextblock m'))
---
>   | match_return_states: forall stk v m stk' v' m' F
>         (MS: match_stacks F m m' stk stk' (Mem.nextblock m'))
==========================================================================================
1271,1273c896
<         (MINJ: Mem.inject F (1%nat :: g ++ l) m m')
<         (SI: stack_injects F m)
<         (SIZES: inline_sizes (1%nat :: g ++ l) (Mem.stack m) (Mem.stack m')),
---
>         (MINJ: Mem.inject F m m'),
==========================================================================================
1276,1277c899,900
< | match_return_regular_states: forall stk v m stk' f' sp' rs' m' F g ctx pc' or rinfo n l
<         (MS: match_stacks_inside F m m' n g stk stk' f' ctx sp' rs')
---
>   | match_return_regular_states: forall stk v m stk' f' sp' rs' m' F ctx pc' or rinfo
>         (MS: match_stacks_inside F m m' stk stk' f' ctx sp' rs')
==========================================================================================
1281,1282c904
<         (MINJ: Mem.inject F (S n :: g ++ l) m m')
<         (SI: stack_injects F m)
---
>         (MINJ: Mem.inject F m m')
==========================================================================================
1286,1287c908
<         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs < f'.(fn_stacksize))
<         (SIZES: inline_sizes (S n :: g ++ l) (Mem.stack m) (Mem.stack m')),
---
>         (SSZ2: forall ofs, Mem.perm m' sp' ofs Max Nonempty -> 0 <= ofs <= f'.(fn_stacksize)),
==========================================================================================
1296c917
<   | Callstate _ _ _ _ _ => 0%nat
---
>   | Callstate _ _ _ _ => 0%nat
==========================================================================================
1307,1495d927
< Lemma ros_is_function_transf:
<   forall ros rs rs' id F ctx bound,
<     match_globalenvs F bound ->
<     ros_is_function ge ros rs id ->
<     agree_regs F ctx rs rs' ->
<     ros_is_function tge (sros ctx ros) rs' id.
< Proof.
<   unfold ros_is_function. intros.
<   destr_in H0. simpl.
<   destruct H0 as (b & o & RS & FS).
<   generalize (proj1 H1 r) (proj2 H1 r). intros.
<   destruct (plt (mreg ctx) r). rewrite H2 in RS; congruence.
<   trim H0. xomega.
<   rewrite RS in H0. inv H0. do 2 eexists; split; eauto.
<   rewrite symbols_preserved. rewrite FS.
<   f_equal.
<   destruct H. apply SYMBOLS in FS. rewrite DOMAIN in H6; auto. congruence.
< Qed.
< 
< (* Lemma match_stack_noframe: *)
< (*   forall x y, *)
< (*     match_stack x y -> *)
< (*     nodup y -> *)
< (*     forall f, *)
< (*       In f y -> *)
< (*       forall b fi sz, *)
< (*         In (b,fi) (frame_adt_blocks f) -> *)
< (*         In (Some (b, sz)) x -> *)
< (*         forall o, frame_perm fi o = Public. *)
< (* Proof. *)
< (*   induction 1; simpl; intros ND f INF b fi' sz' INFR INL; eauto. easy. *)
< (*   destruct INF. *)
< (*   - subst. rewrite MSAblocks in INFR.  simpl in INFR. *)
< (*     destruct INFR; try easy. inv H0. *)
< (*     rewrite MSApub. auto. *)
< (*   - inv ND. *)
< (*     specialize (IHmatch_stack H3 _ H0 _ _ sz' INFR). *)
< (*     destruct INL; eauto. inv H1. *)
< (*     exfalso; eapply H4. eapply in_frame_blocks_in_frame. rewrite MSAblocks. left; reflexivity. *)
< (*     eapply in_frames_in_frame; eauto. *)
< (*     eapply in_frame_blocks_in_frame; eauto. *)
< (* Qed. *)
< 
< (* Lemma match_stack_free: *)
< (*   forall m b lo hi m' m'', *)
< (*   forall x y, *)
< (*     match_stack (x::y) (Mem.stack m) -> *)
< (*     Mem.free m b lo hi = Some m' -> *)
< (*     Mem.unrecord_stack_block m' = Some m'' -> *)
< (*     match_stack (y) (Mem.stack m''). *)
< (* Proof. *)
< (*   intros m b lo hi m' m''  x y MSA FREE USB. *)
< (*   inv MSA. *)
< (*   edestruct Mem.unrecord_stack; eauto. *)
< (*   erewrite <- (Mem.free_stack_blocks) in H; eauto. *)
< (*   rewrite H0 in H. inv H. auto. *)
< (* Qed. *)
< 
< 
==========================================================================================
< Lemma match_stacks_push_l:
<   forall f m m' l s s' nb,
<     match_stacks f m m' l s s' nb ->
<     match_stacks f (Mem.push_new_stage m) m' l s s' nb.
< Proof.
<   intros.
<   eapply match_stacks_invariant; eauto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   rewrite Mem.push_new_stage_nextblock; auto. xomega.
< Qed.
< 
< Lemma match_stacks_push_r:
<   forall f m m' l s s' nb,
<     match_stacks f m m' l s s' nb ->
<     match_stacks f m (Mem.push_new_stage m') l s s' nb.
< Proof.
<   intros.
<   eapply match_stacks_invariant; eauto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   xomega.
< Qed.
< 
< Lemma match_stacks_push:
<   forall f m m' l s s' nb,
<     match_stacks f m m' l s s' nb ->
<     match_stacks f (Mem.push_new_stage m) (Mem.push_new_stage m') l s s' nb.
< Proof.
<   intros.
<   eapply match_stacks_push_l; eauto.
<   eapply match_stacks_push_r; eauto.
< Qed.
< 
< Lemma match_stacks_inside_push_l:
<   forall j m m' n l s s' f ctx nb rs,
<     match_stacks_inside j m m' n l s s' f ctx nb rs ->
<     match_stacks_inside j (Mem.push_new_stage m) m' n l s s' f ctx nb rs.
< Proof.
<   intros.
<   eapply match_stacks_inside_invariant; eauto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   rewrite Mem.push_new_stage_nextblock; auto. xomega.
< Qed.
< 
< Lemma match_stacks_inside_push_r:
<   forall j m m' n l s s' f ctx nb rs,
<     match_stacks_inside j m m' n l s s' f ctx nb rs ->
<     match_stacks_inside j m (Mem.push_new_stage m') n l s s' f ctx nb rs.
< Proof.
<   intros.
<   eapply match_stacks_inside_invariant; eauto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   setoid_rewrite Mem.push_new_stage_perm; auto.
<   xomega.
< Qed.
< 
< Lemma match_stacks_inside_push:
<   forall j m m' n l s s' f ctx nb rs,
<     match_stacks_inside j m m' n l s s' f ctx nb rs ->
<     match_stacks_inside j (Mem.push_new_stage m) (Mem.push_new_stage m') n l s s' f ctx nb rs.
< Proof.
<   intros.
<   eapply match_stacks_inside_push_l; eauto.
<   eapply match_stacks_inside_push_r; eauto.
< Qed.
< 
< Lemma loc_private_push_l:
<   forall j m m' b o,
<     loc_private j m m' b o ->
<     loc_private j (Mem.push_new_stage m) m' b o.
< Proof.
<   red; intros. setoid_rewrite Mem.push_new_stage_perm. auto.
< Qed.
< 
< Lemma loc_private_push_r:
<   forall j m m' b o,
<     loc_private j m m' b o ->
<     loc_private j m (Mem.push_new_stage m') b o.
< Proof.
<   red; intros. setoid_rewrite Mem.push_new_stage_perm. auto.
< Qed.
< 
< 
< Lemma frame_adt_eq:
<   forall f1 f2,
<     frame_adt_blocks f1 = frame_adt_blocks f2 ->
<     frame_adt_size f1 = frame_adt_size f2 ->
<     f1 = f2.
< Proof.
<   destruct f1, f2; intros; simpl in *; subst. f_equal.
<   apply Axioms.proof_irr.
<   apply Axioms.proof_irr.
< Qed.
< 
< 
==========================================================================================
< Lemma in_stack'_norepet:
<   forall m b bi1 bi2,
<     in_stack' (Mem.stack m) (b, bi1) ->
<     in_stack' (Mem.stack m) (b, bi2) ->
<     bi1 = bi2.
< Proof.
<   intros.
<   rewrite in_stack'_rew in H, H0.
<   destruct H as (tf1 & IFR1 & ITF1).
<   destruct H0 as (tf2 & IFR2 & ITF2).
<   rewrite in_frames'_rew in IFR1, IFR2.
<   destruct IFR1 as (fr1 & IF1 & IFR1).
<   destruct IFR2 as (fr2 & IF2 & IFR2).
<   assert (tf1 = tf2).
<   {
<     exploit nodup_nodup'. apply Mem.stack_norepet. apply ITF1. apply ITF2.
<     eapply in_frame_in_frames; eauto. eapply in_frame'_in_frame; eauto.
<     eapply in_frame_in_frames; eauto. eapply in_frame'_in_frame; eauto. auto.
<   }
<   subst.
<   assert (fr1 = fr2). congruence. subst.
<   eapply in_frame'_norepet; eauto.
< Qed.
< 
< Lemma inline_sizes_same_top:
<   forall g f1 f2 s1 s2,
<     inline_sizes g (f1::s1) s2 ->
<     size_frames f1 = size_frames f2 ->
<     inline_sizes g (f2::s1) s2.
< Proof.
<   intros g f1 f2 s1 s2 SZ EQ; inv SZ; simpl in *. destruct n; simpl in *. inv H0.
<   econstructor; simpl; eauto. omega.
<   econstructor; simpl; eauto.
< Qed.
< 
1498,1500c930,932
<   step fn_stack_requirements ge S1 t S2 ->
<   forall S1' (MS: match_states S1 S1') (SI: stack_inv S1) (SI': stack_inv S1'),
<   (exists S2', plus (step fn_stack_requirements) tge S1' t S2' /\ match_states S2 S2')
---
>   step ge S1 t S2 ->
>   forall S1' (MS: match_states S1 S1'),
>   (exists S2', plus step tge S1' t S2' /\ match_states S2 S2')
1523c955
<   apply match_stacks_inside_set_reg; eauto.
---
>   apply match_stacks_inside_set_reg; auto.
1540c972
<   apply match_stacks_inside_set_reg; eauto.
---
>   apply match_stacks_inside_set_reg; auto.
1561,1563d992
<   {
<     red; intros. erewrite Mem.store_stack_blocks in H3; eauto.
<   }
1569,1571c998
<   intros; eapply SSZ3; eauto. eapply Mem.perm_store_2; eauto.
<   repeat rewrite_stack_blocks; eauto.
<   
---
> 
1579d1005
<   eapply ros_is_function_transf; eauto.
1581,1585c1007,1008
<   econstructor.
<   apply match_stacks_push. rewrite Mem.push_new_stage_nextblock.
<   eapply match_stacks_cons; eauto. eapply Mem.valid_block_inject_1; eauto.
<   4: eapply Mem.push_new_stage_inject; eauto.
<   all: eauto.
---
>   econstructor; eauto.
>   eapply match_stacks_cons; eauto.
1587,1590d1009
<   red. rewrite_stack_blocks. setoid_rewrite in_stack_cons. intros b [[]|]; eauto.
<   repeat rewrite_stack_blocks.
<   apply inline_sizes_up. auto.
<   
1595,1596c1014
<   econstructor.
<   eapply match_stacks_inside_push_l.
---
>   econstructor; eauto.
1598,1599d1015
<   9: eapply Mem.inject_push_new_stage_left; eauto.
<   all: eauto.
1601d1016
<   eapply Mem.valid_block_inject_1; eauto.
1603,1607c1018
<   (* inv SI'. inv MSA1. congruence. *)
<   red. rewrite_stack_blocks. setoid_rewrite in_stack_cons. intros b [[]|]; eauto.
<   red; intros. apply loc_private_push_l. apply PRIV. destruct H16. omega.
<   repeat rewrite_stack_blocks.
<   eapply inline_sizes_upstar; eauto.
---
>   red; intros; apply PRIV. destruct H16. omega.
1613c1024
<   { eapply range_private_free_left; eauto. inv FB. rewrite <- H5. auto. }
---
>   { eapply range_private_free_left; eauto. inv FB. rewrite <- H4. auto. }
1622d1032
<     simpl; auto.
1625,1635d1034
<   assert (Mem.inject F (1%nat :: g ++ l) m' m1') as INJfree.
<   {
<     eapply Mem.free_right_inject; eauto. eapply Mem.free_left_inject; eauto.
<     (* show that no valid location points into the stack block being freed *)
<     intros. rewrite DSTK in PRIV'. exploit (PRIV' (ofs + delta)). omega. intros [P Q].
<     eelim Q; eauto. replace (ofs + delta - delta) with ofs by omega.
<     apply Mem.perm_max with k. apply Mem.perm_implies with p; auto with mem.
<   }
<   edestruct (Mem.tailcall_stage_inject) as (m2' & TC & EXT). apply INJfree. eauto.
<   inv SI'. inv MSA1.
<   eapply Mem.free_top_tframe_no_perm; eauto.
1638d1036
<   eapply ros_is_function_transf; eauto.
1643,1649c1041,1044
<   intros. revert H5; repeat rewrite_perms. destr.
<   intros. revert H4; repeat rewrite_perms. destr.
<   rewrite <- andb_assoc in Heqb0. apply andb_true_iff in Heqb0.
<   destruct Heqb0. destruct peq; simpl in *; try congruence. subst. xomega.
<   intros. revert H4; repeat rewrite_perms. destr.
<   rewnb. xomega.
<   rewnb. red in VB; xomega.
---
>     intros. eapply Mem.perm_free_3; eauto.
>     intros. eapply Mem.perm_free_1; eauto.
>     intros. eapply Mem.perm_free_3; eauto.
>   erewrite Mem.nextblock_free; eauto. red in VB; xomega.
1651,1662c1046,1050
<   {
<     red; intros b.
<     repeat rewrite_stack_blocks. rewrite in_stack_cons.
<     unfold in_frames; simpl.
<     intros AA [[]|INS]; eauto.
<     eapply SI0. rewrite AA.
<     rewrite in_stack_cons; auto.
<   }
<   repeat rewrite_stack_blocks; eauto.
<   intros AA BB; rewrite AA, BB in SIZES.
<   eapply inline_sizes_record; eauto.
< 
---
>   eapply Mem.free_right_inject; eauto. eapply Mem.free_left_inject; eauto.
>   (* show that no valid location points into the stack block being freed *)
>   intros. rewrite DSTK in PRIV'. exploit (PRIV' (ofs + delta)). omega. intros [P Q].
>   eelim Q; eauto. replace (ofs + delta - delta) with ofs by omega.
>   apply Mem.perm_max with k. apply Mem.perm_implies with p; auto with mem.
1664,1668d1051
<   exploit Mem.free_left_inject. eauto. eauto. intro INJFREE.
<   assert (O < n)%nat. {
<     inv MS0. congruence. omega.
<   }
<   exploit Mem.inject_tailcall_left_new_stage_right. apply INJFREE. auto. eauto. intro INJTC.
1671d1053
<   eapply ros_is_function_transf; eauto.
1673,1674c1055
<   econstructor.
<   eapply match_stacks_push_r. rewrite Mem.push_new_stage_nextblock.  
---
>   econstructor; eauto.
1677,1684c1058
<   intros b1 b2 delta ofs. repeat rewrite_perms. destr.
<   rewnb. xomega.
<   {
<     eapply range_private_invariant. apply PRIV'.
<     intros b delta ofs. repeat rewrite_perms; destr.
<     tauto.
<   }
<   eauto. eauto.
---
>     intros. eapply Mem.perm_free_3; eauto.
1686,1697c1060
<   simpl; eauto.
<   {
<     red; intros b.
<     repeat rewrite_stack_blocks.
<     intros INS IFR.
<     eapply SI0; eauto.
<     rewrite INS. rewrite in_stack_cons in IFR |- *.
<     destruct IFR as [IFR| INS']. easy. auto.
<   }
<   repeat rewrite_stack_blocks. intro EQ1; rewrite EQ1 in SIZES.
<   simpl. destruct n. omega. apply inline_sizes_upright. auto.
< 
---
>   eapply Mem.free_left_inject; eauto.
1702,1704d1064
<   exploit Mem.free_left_inject; eauto. intro FREEINJ.
< 
<   eapply Mem.tailcall_stage_inject_left in FREEINJ; eauto.
1708,1712c1068
<   intros b1 b2 delta ofs; repeat rewrite_perms; destr.
<   rewnb; xomega.
<   eapply range_private_invariant. apply PRIV'.
<   intros b delta ofs; repeat rewrite_perms; destr.
<   auto.
---
>     intros. eapply Mem.perm_free_3; eauto.
1714,1720c1070
<   {
<     red; intros b.
<     repeat rewrite_stack_blocks.
<     intros STK. rewrite in_stack_cons. intros [[]|INS];
<     eapply SI0; eauto. rewrite STK, in_stack_cons; auto.
<   }
<   eapply range_private_invariant in PRIV'.
---
>   eapply Mem.free_left_inject; eauto.
1722,1732c1072,1073
<   assert (dstk ctx <= dstk ctx').
<   {
<     red in H15; rewrite H15. apply align_le. apply min_alignment_pos.
<   }
<   omega.
<   intros b delta ofs; repeat rewrite_perms. auto.
<   tauto.
<   repeat rewrite_stack_blocks.
<   intro EQ1; rewrite EQ1 in SIZES.
<   eapply inline_sizes_same_top. eauto.
<   rewrite size_frames_tc. auto.
---
>     assert (dstk ctx <= dstk ctx'). red in H14; rewrite H14. apply align_le. apply min_alignment_pos.
>     omega.
1740d1080
<     apply Mem.push_new_stage_inject. eauto.
1742d1081
<   edestruct Mem.unrecord_stack_block_inject_parallel as (m2' & USB & INJ'). apply C. eauto.
1744,1746c1083,1084
<   eapply plus_one. eapply exec_Ibuiltin. eauto. eauto.
<     eapply external_call_symbols_preserved; eauto. apply senv_preserved. eauto.
<     eauto.
---
>   eapply plus_one. eapply exec_Ibuiltin; eauto.
>     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
1750,1765c1088,1090
<     intros. eapply Mem.unrecord_stack_block_perm in H4. 2: eauto.
<     eapply external_call_max_perm in H4. 2: eauto. apply Mem.push_new_stage_perm; auto.
<     red; rewrite Mem.push_new_stage_nextblock; auto.
<     intros. eapply Mem.unrecord_stack_block_perm in H4. 2: eauto.
<     eapply external_call_max_perm in H4. 2: eauto. apply Mem.push_new_stage_perm; auto.
<     red; rewrite Mem.push_new_stage_nextblock; auto.
<     eapply Mem.unchanged_on_trans. apply Mem.strong_unchanged_on_weak, Mem.push_new_stage_unchanged_on.
<     eapply Mem.unchanged_on_trans. eapply Mem.unchanged_on_implies. apply E.
<     intros. red. setoid_rewrite Mem.push_new_stage_perm. auto.
<     eapply Mem.strong_unchanged_on_weak, Mem.unrecord_stack_block_unchanged_on. auto.
<     red; intros.
<     generalize (K _ _ _ H3 H4).
<     unfold Mem.valid_block.
<     rewrite ! Mem.push_new_stage_nextblock. auto.
<     rewnb. xomega.
<     eauto. auto.
---
>     intros; eapply external_call_max_perm; eauto.
>     intros; eapply external_call_max_perm; eauto.
>   auto. eauto. auto.
1767,1773c1092,1093
<   auto. eauto.
<   red; intro b.
<   repeat rewrite_stack_blocks. simpl.
<   intro INFR.
<   eapply SI0 in INFR.
<   destruct INFR as (b' & delta & FF); exists b', delta; eauto.
<   red; repeat rewnb. eauto.
---
>   auto. auto.
>   eapply external_call_valid_block; eauto.
1775,1785c1095
<   intros b ofs p VB' PP.
<   eapply Mem.push_new_stage_perm. eapply external_call_max_perm. eauto. red; rewnb; auto.
<   revert PP. rewrite_perms. auto.
<   eapply Mem.unchanged_on_trans. apply Mem.strong_unchanged_on_weak, Mem.push_new_stage_unchanged_on.
<   eapply Mem.unchanged_on_trans. eapply Mem.unchanged_on_implies. apply E.
<   intros. red. setoid_rewrite Mem.push_new_stage_perm. auto.
<   eapply Mem.strong_unchanged_on_weak, Mem.unrecord_stack_block_unchanged_on. auto.
<   red; intros.
<   generalize (K _ _ _ H3 H4).
<   unfold Mem.valid_block.
<   rewrite ! Mem.push_new_stage_nextblock. auto.
---
>     intros; eapply external_call_max_perm; eauto.
1787,1794c1097,1098
<   intros. apply SSZ2. revert H3; repeat rewrite_perms. eauto.
<   repeat rewrite_stack_blocks. simpl. inv SI'. inv MSA1. rewrite ! in_stack_cons. right; left.
<   rewrite in_frames_cons. unfold in_frame, get_frame_blocks. eexists; rewrite BLOCKS. simpl. auto.
<   intros. apply SSZ3. revert H3; repeat rewrite_perms. eauto.
<   repeat rewrite_stack_blocks. simpl. inv SI. inv MSA1. rewrite ! in_stack_cons. right; left.
<   rewrite in_frames_cons. unfold in_frame, get_frame_blocks. eexists; rewrite BLOCKS. simpl. auto.
<   repeat rewrite_stack_blocks. simpl. auto.
<   
---
>   intros. apply SSZ2. eapply external_call_max_perm; eauto.
> 
1821d1124
<     simpl; auto.
1825,1835d1127
<   assert (Mem.inject F (1%nat::g++l) m' m1') as INJfree.
<   {
<     eapply Mem.free_right_inject; eauto. eapply Mem.free_left_inject; eauto.
<     (* show that no valid location points into the stack block being freed *)
<     intros. inversion FB; subst.
<     assert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).
<     rewrite H8 in PRIV. eapply range_private_free_left; eauto.
<     rewrite DSTK in PRIV'. exploit (PRIV' (ofs + delta)). omega. intros [A B].
<     eelim B; eauto. replace (ofs + delta - delta) with ofs by omega.
<     apply Mem.perm_max with k. apply Mem.perm_implies with p; auto with mem.
<   }
1838c1130
<   econstructor; eauto. 
---
>   econstructor; eauto.
1844,1845c1136
<     rewnb. xomega.
<     rewnb. red in VB. xomega.
---
>   erewrite Mem.nextblock_free; eauto. red in VB; xomega.
1847,1854c1138,1146
<   {
<     red; intros b.
<     repeat rewrite_stack_blocks.
<     intro IFR.
<     eapply SI0; eauto.
<   }
<   repeat rewrite_stack_blocks; auto.
<   
---
>   eapply Mem.free_right_inject; eauto. eapply Mem.free_left_inject; eauto.
>   (* show that no valid location points into the stack block being freed *)
>   intros. inversion FB; subst.
>   assert (PRIV': range_private F m' m'0 sp' (dstk ctx) f'.(fn_stacksize)).
>     rewrite H8 in PRIV. eapply range_private_free_left; eauto.
>   rewrite DSTK in PRIV'. exploit (PRIV' (ofs + delta)). omega. intros [A B].
>   eelim B; eauto. replace (ofs + delta - delta) with ofs by omega.
>   apply Mem.perm_max with k. apply Mem.perm_implies with p; auto with mem.
> 
1857,1861c1149
<   exploit Mem.free_left_inject; eauto. intros FRINJ.
<   assert (O < n)%nat. {
<     inv MS0. congruence. omega.
<   } 
<   econstructor; eauto. 
---
>   econstructor; eauto.
1863,1864c1151
<   intros. eapply Mem.perm_free_3; eauto.
<   rewnb. xomega.
---
>     intros. eapply Mem.perm_free_3; eauto.
1866,1874c1153,1154
<   * red; intros b.
<     repeat rewrite_stack_blocks.
<     intro IFR.
<     eapply SI0; eauto.
<   * eapply range_private_invariant.
<     eapply range_private_free_left; eauto.
<     inv FB. rewrite <- H6; eauto.
<     intros; split; auto. tauto.
<   * repeat rewrite_stack_blocks; auto.
---
>   eapply Mem.free_left_inject; eauto.
>   inv FB. rewrite H4 in PRIV. eapply range_private_free_left; eauto.
1884c1164
<     instantiate (1 := fn_stacksize f'). inv H2. xomega.
---
>     instantiate (1 := fn_stacksize f'). inv H1. xomega.
1886,1982c1166,1193
<   exploit Mem.record_stack_blocks_inject_parallel.
<   apply B. 7: eauto.
<   + instantiate (1 := make_singleton_frame_adt sp' (fn_stacksize f') sz).
<     red; simpl; intros; auto.
<     constructor; auto.
<     simpl. rewrite D. inversion 1; subst.
<     eexists; split. eauto.
<     split.
<     simpl. auto.
<     simpl.
<     intros.
<     inv H2.
<     rewrite Z.max_r by omega.
<     split. omega. eapply Z.lt_le_trans. 2: apply H16.
<     rewrite Zmax_spec in H10, H13. destr_in H10. omega. destr_in H13. omega. omega.
<   + repeat rewrite_stack_blocks. unfold in_frame; simpl; intros. intros [?|[]]; subst.
<     eapply Mem.in_frames_valid in H9. eapply Mem.fresh_block_alloc in H9; eauto.
<   + red; unfold in_frame; simpl. intros ? [?|[]]; subst. eapply Mem.valid_new_block; eauto.
<   + simpl. intros b fi o k p [AA|[]]; inv AA.
<     rewrite_perms. rewrite peq_true. simpl. intros; rewrite Z.max_r; omega.
<   + unfold in_frame; simpl.
<     intros b1 b2 delta FB. split; intros [?|[]]; subst; left.
<     congruence.
<     destruct (peq stk b1); auto.
<     rewrite E in FB; auto. eapply Mem.valid_block_inject_2 in FB; eauto. eapply Mem.fresh_block_alloc in FB; eauto. easy.
<   + reflexivity.
<   + inv SI'. rewrite_stack_blocks. inv TOPNOPERM. constructor. auto.
<   + repeat rewrite_stack_blocks.
<     eapply inline_sizes_le; eauto.
< 
<   + intros (m2' & P & Q).
<     left; econstructor; split.
<     * eapply plus_one. eapply exec_function_internal; eauto.
<     * rewrite H6, H7. econstructor. 
<       -- instantiate (3 := F'). apply match_stacks_inside_base.
<          assert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).
<          rewrite <- SP in MS0.
<          eapply match_stacks_invariant; eauto.
<          ++ intros. destruct (eq_block b1 stk).
<             subst b1. rewrite D in H9; inv H9. eelim Plt_strict; eauto.
<             rewrite E in H9; auto.
<          ++ intros. exploit Mem.perm_alloc_inv. eexact H. eauto.
<             destruct (eq_block b1 stk); intros; auto.
<             subst b1. rewrite D in H9; inv H9. eelim Plt_strict; eauto.
<             intros. eapply Mem.perm_alloc_1; eauto.
<             intros. exploit Mem.perm_alloc_inv. eexact A.
<             eapply Mem.record_stack_block_perm; eauto.
<             eapply Mem.record_stack_block_perm'; eauto.
<             eapply Mem.perm_inject; eauto.
<             eapply Mem.record_stack_block_perm; eauto.
<             constructor.
<             rewrite dec_eq_false; auto.
<             intros.
<             eapply Mem.perm_alloc_4. eauto. eapply Mem.record_stack_block_perm; eauto. auto.
<             destr. subst.
<             rewrite D in H9; inv H9; xomega.
<          ++ intros. eapply Mem.record_stack_block_perm'. eauto.
<             eapply Mem.perm_alloc_1; eauto.
<          ++ intros. eapply Mem.perm_alloc_4. eauto.
<             eapply Mem.record_stack_block_perm. eauto.
<             eauto. intro; subst; xomega.
<          ++ rewrite (Mem.record_stack_block_nextblock _ _ _ H0), (Mem.nextblock_alloc _ _ _ _ _ H). xomega.
<          ++ auto.
<          ++ auto.
<       -- eauto.
<       -- auto. 
<       -- apply agree_regs_init_regs. eauto.
<          inv H2. auto.
<       -- congruence.
<       -- eauto.
<       -- intro b.
<          repeat rewrite_stack_blocks. rewrite in_stack_cons, in_frames_cons.
<          intro EQ1.
<          generalize (SI0 b). rewrite EQ1. rewrite in_stack_cons.
<          intros HYP [(f1 & EQ & IFR)|INS]. inv EQ.
<          destruct IFR as [EQ|[]]. simpl in EQ. subst. eauto. edestruct HYP as (b' & delta & FB); eauto.
<       -- red. erewrite Mem.record_stack_block_nextblock. eapply Mem.valid_new_block; eauto. eauto.
<       -- red; intros. split.
<          ++ eapply Mem.record_stack_block_perm'; eauto.
<             eapply Mem.perm_alloc_2; eauto. inv H2; xomega.
<          ++ intros; red; intros. eapply Mem.record_stack_block_perm in H11; eauto.
<             exploit Mem.perm_alloc_inv. eexact H. eauto.
<             destruct (eq_block b stk); intros.
<             subst. rewrite D in H10; inv H10. inv H2; xomega.
<             rewrite E in H10; auto. eelim Mem.fresh_block_alloc.
<             eexact A. eapply Mem.valid_block_inject_2; eauto.
<       -- auto.
<       -- intros.
<          eapply Mem.record_stack_block_perm in H9; eauto.
<          exploit Mem.perm_alloc_inv; eauto. rewrite dec_eq_true. omega.
<       -- intros.
<          eapply Mem.record_stack_block_perm in H9; eauto.
<          exploit Mem.perm_alloc_inv. 2: eauto. eauto. rewrite dec_eq_true. omega.
<       -- repeat rewrite_stack_blocks. intros S1 S2.
<          revert SIZES. rewrite S1, S2.
<          intros; eapply inline_sizes_record'; eauto.
<          
---
>   left; econstructor; split.
>   eapply plus_one. eapply exec_function_internal; eauto.
>   rewrite H6. econstructor.
>   instantiate (1 := F'). apply match_stacks_inside_base.
>   assert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).
>   rewrite <- SP in MS0.
>   eapply match_stacks_invariant; eauto.
>     intros. destruct (eq_block b1 stk).
>     subst b1. rewrite D in H8; inv H8. eelim Plt_strict; eauto.
>     rewrite E in H8; auto.
>     intros. exploit Mem.perm_alloc_inv. eexact H. eauto.
>     destruct (eq_block b1 stk); intros; auto.
>     subst b1. rewrite D in H8; inv H8. eelim Plt_strict; eauto.
>     intros. eapply Mem.perm_alloc_1; eauto.
>     intros. exploit Mem.perm_alloc_inv. eexact A. eauto.
>     rewrite dec_eq_false; auto.
>   auto. auto. auto. eauto. auto.
>   rewrite H5. apply agree_regs_init_regs. eauto. auto. inv H1; auto. congruence. auto.
>   eapply Mem.valid_new_block; eauto.
>   red; intros. split.
>   eapply Mem.perm_alloc_2; eauto. inv H1; xomega.
>   intros; red; intros. exploit Mem.perm_alloc_inv. eexact H. eauto.
>   destruct (eq_block b stk); intros.
>   subst. rewrite D in H9; inv H9. inv H1; xomega.
>   rewrite E in H9; auto. eelim Mem.fresh_block_alloc. eexact A. eapply Mem.mi_mappedblocks; eauto.
>   auto.
>   intros. exploit Mem.perm_alloc_inv; eauto. rewrite dec_eq_true. omega.
> 
1993c1204
<     intros. right. destruct external_calls_prf; exploit SSZ2; eauto with mem. inv FB; omega.
---
>     intros. right. exploit SSZ2; eauto with mem. inv FB; omega.
2005,2036c1216
<     intros. red.
<     inv SI'. inv MSA1.
< 
<     assert (bi = fi). eapply in_stack'_norepet; eauto. rewrite <- H14. left.
<     red. simpl.
<     red. rewrite BLOCKS. left; auto. subst. eauto. 
<     intros [F' [A [B [C D]]]].
<   destruct (stack_top_frame_at_position (Mem.stack m'0) sp') as (f0 & FAP & INF).
<   inv SI'. red; inv MSA1. simpl. unfold get_frames_blocks. simpl.
<   unfold get_frame_blocks. rewrite BLOCKS. simpl. auto.
<   exploit Mem.record_stack_blocks_inject_left'. apply A.
<   eauto.   
<   2: eauto.
<   {
<     red. simpl. intros f1 eq. inv eq. intro HP.
<     inv SI'. inv MSA1. rewrite <- H11 in FAP. apply frame_at_pos_last in FAP. subst.
<     eexists; split. reflexivity.
<     red. simpl.
<     constructor; auto. simpl. intros. rewrite BLOCKS.
<     rewrite C in H7. inv H7. eexists; split. left; reflexivity.
<     split.
<     - simpl.
<       intros. rewrite PUB. auto.
<     - simpl.
<       intros.
<       rewrite Zmax_spec in H7. destr_in H7. omega.
<       split. omega.
<       rewrite SIZE. cut (o < mstk ctx). rewrite Z.max_r by omega. omega.
<       rewrite H3.
<       rewrite Z.max_l; omega.
<   }
<   intros MINJ'.
---
>   intros [F' [A [B [C D]]]].
2041,2072c1221,1229
<   + eapply match_stacks_inside_record_left.
<     eapply match_stacks_inside_alloc_left; eauto.
<     eapply match_stacks_inside_invariant; eauto.
<     xomega.
<     omega. eauto.
<   + eauto.
<   + auto.
<   + apply agree_regs_incr with F; auto.
<   + auto.
<   + eauto.
<   + intro b.
<     repeat rewrite_stack_blocks. rewrite in_stack_cons, in_frames_cons.
<     intro EQ1. generalize (SI0 b).
<     rewrite EQ1. rewrite in_stack_cons.
<     intros HYP [(ff1 & eq & IFR)|INS].
<     ++ inv eq. destruct IFR as [eq|[]]. simpl in eq; subst; simpl; eauto.
<     ++ edestruct HYP as (b' & delta & FB'); eauto; do 2 eexists; eapply C; eauto.
<   + auto.
<   + rewrite H3.
<     eapply range_private_invariant.
<     eapply range_private_alloc_left; eauto.
<     2: tauto.
<     split; auto. eapply Mem.record_stack_block_perm; eauto.
<   + auto.
<   + auto.
<   + intros.
<     eapply Mem.record_stack_block_perm in H7. 2: eauto.
<     eapply Mem.perm_alloc_inv in H7. 2: eauto. rewrite pred_dec_true in H7. auto. auto.
<   + repeat rewrite_stack_blocks.
<     intro EQ1. rewrite EQ1 in SIZES.
<     eapply inline_sizes_record_left; eauto.
<     
---
>   eapply match_stacks_inside_alloc_left; eauto.
>   eapply match_stacks_inside_invariant; eauto.
>   omega.
>   eauto. auto.
>   apply agree_regs_incr with F; auto.
>   auto. auto. auto.
>   rewrite H2. eapply range_private_alloc_left; eauto.
>   auto. auto.
> 
2081,2082c1238,1239
<   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
<   econstructor. 
---
>     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
>   econstructor.
2087d1243
<     eapply external_call_nextblock; eauto.
2090,2096c1246
<     auto. eauto.
<     red; intro b.
<     erewrite <- external_call_stack_blocks; eauto.
<     intro INFR.
<     eapply SI0 in INFR.
<     destruct INFR as (b' & delta & FF); exists b', delta; eauto.
<     repeat rewrite_stack_blocks; eauto.
---
>     auto. auto.
2101d1250
<   edestruct Mem.unrecord_stack_block_inject_parallel as (m2' & USB & INJ); eauto.
2103c1252
<   eapply plus_one. eapply exec_return; eauto.
---
>   eapply plus_one. eapply exec_return.
2105,2119c1254,1255
<   * apply match_stacks_inside_set_reg. eapply match_stacks_inside_invariant. 2: apply MS. all: eauto.
<     -- simpl; intros b1 b2 delta ofs Fb1 PLE. rewrite_perms. auto.
<     -- simpl; intros b ofs PLE. rewrite_perms. auto.
<     -- simpl; intros b ofs k p PLE. rewrite_perms. auto.
<     -- rewnb. xomega.
<   * apply agree_set_reg; auto.
<   * intro b. rewrite_stack_blocks. eauto. intros. apply in_stack_tl in H0. eauto.
<   * red; rewnb. auto.
<   * eapply range_private_invariant. eauto. intros b delta ofs. rewrite_perms. eauto.
<     intro ofs; rewrite_perms. auto.
<   * intro; rewrite_perms; auto.
<   * intro; rewrite_perms; auto.
<   * repeat rewrite_stack_blocks.
<     eapply inline_sizes_down; eauto.
<     
---
>   apply match_stacks_inside_set_reg; auto.
>   apply agree_set_reg; auto.
2123d1258
<   edestruct Mem.unrecord_stack_block_inject_parallel as (m2' & USB & INJ); eauto.
2125,2126c1260,1261
<   eapply plus_one. eapply exec_return. eauto.
<   eapply match_regular_states. 
---
>   eapply plus_one. eapply exec_return.
>   eapply match_regular_states.
2128,2146c1263,1268
<   eapply match_stacks_inside_invariant.
<   2: apply MS0. all: eauto.
<   simpl; intros b1 b2 delta ofs Fb1 PLE. rewrite_perms. auto.
<   simpl; intros b ofs PLE. rewrite_perms. auto.
<   simpl; intros b ofs k p PLE. rewrite_perms. auto.
<   rewnb. xomega.
<   * apply agree_set_reg; auto.
<   * intro b; rewrite_stack_blocks. intro IStl; apply in_stack_tl in IStl; eauto.
<   * red; rewnb; auto.
<   * eapply range_private_invariant.
<     red; intros. destruct (zlt ofs (dstk ctx)).
<     red. apply PAD. omega. apply PRIV. omega.
<     intros b delta ofs. repeat rewrite_perms. intuition.
<     intro; rewrite_perms. auto.
<   * intro; rewrite_perms; auto.
<   * intro; rewrite_perms; auto.
<   * repeat rewrite_stack_blocks.
<     eapply inline_sizes_down; eauto.
<     
---
>   eauto. auto.
>   apply agree_set_reg; auto.
>   auto. auto. auto.
>   red; intros. destruct (zlt ofs (dstk ctx)). apply PAD; omega. apply PRIV; omega.
>   auto. auto.
> 
2150c1272
<   assert (PRIV': range_private F m m'0 sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).
---
>   assert (PRIV': range_private F m m' sp' (dstk ctx' + mstk ctx') f'.(fn_stacksize)).
2152,2153d1273
<   exploit Mem.unrecord_stack_block_inject_left; eauto. omega.
<   inv SI. auto. intro INJ'.
2158,2170c1278
<   econstructor; eauto. apply match_stacks_inside_set_reg; auto.
<   eapply match_stacks_inside_invariant.
<   2: apply MS. all: eauto.
<   simpl; intros b1 b2 delta ofs Fb1 PLE. rewrite_perms. auto.
<   rewnb. xomega.
<   * apply agree_set_reg; auto.
<   * intro b; rewrite_stack_blocks. intro IStl; apply in_stack_tl in IStl; eauto.
<   * eapply range_private_invariant. apply PRIV'.
<     intros b delta ofs. repeat rewrite_perms. intuition. auto.
<   * intro; rewrite_perms; auto.
<   * repeat rewrite_stack_blocks.
<     eapply inline_sizes_downstar; eauto.
<     
---
>   econstructor; eauto. apply match_stacks_inside_set_reg; auto. apply agree_set_reg; auto.
2174,2202c1282,1283
<   econstructor; eauto.
<   eapply match_stacks_inside_invariant.
<   2: apply MS. all: eauto.
<   simpl; intros b1 b2 delta ofs Fb1 PLE. rewrite_perms. auto.
<   rewnb. xomega.
<   * subst vres. apply agree_set_reg_undef'; auto.
<   * intro b; rewrite_stack_blocks. intro IStl; apply in_stack_tl in IStl; eauto.
<   * eapply range_private_invariant. apply PRIV'.
<     intros b delta ofs. repeat rewrite_perms. intuition. auto.
<   * intro; rewrite_perms; auto.
<   * repeat rewrite_stack_blocks. eapply inline_sizes_downstar; eauto.
< Qed.
< 
< End WITHMEMINIT.
< 
< (** [CompCertX:test-compcert-protect-stack-arg] For the whole-program
< setting, we have to embed the initial memory into a new
< [match_states'] predicate, which will be the new simulation
< relation. *)
< 
< Inductive match_states'
<           (s: RTL.state) (s': RTL.state): Prop :=
< | match_states'_intro
<     m_init m1
<     (M_INIT: Genv.init_mem prog = Some m_init)
<     (genv_next_le_m_init_next: Ple (Genv.genv_next ge) (Mem.nextblock m_init))
<     (ALLOC: Mem.record_init_sp m_init = Some m1)
<     (MATCH: match_states m1 s s')
< .
---
>   econstructor; eauto. subst vres. apply agree_set_reg_undef'; auto.
> Qed.
2205c1286
<   forall st1, initial_state fn_stack_requirements prog st1 -> exists st2, initial_state fn_stack_requirements tprog st2 /\ match_states' st1 st2.
---
>   forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\ match_states st1 st2.
2209,2211c1290,1291
<   exists (Callstate nil tf nil (Mem.push_new_stage m2) (fn_stack_requirements (prog_main prog))); split.
<   - erewrite <- match_program_main; eauto.
<     econstructor; eauto.
---
>   exists (Callstate nil tf nil m0); split.
>   econstructor; eauto.
2216,2238c1296,1306
<   - edestruct (Mem.record_init_sp_flat_inject) as (m2' & RIS & INJ).
<     eapply Genv.initmem_inject; eauto. omega. eauto. auto.
<     rewrite RIS in H4; inv H4. econstructor; eauto.
<     * unfold ge. rewnb. xomega.
<     * eapply match_call_states.
<       5: apply Mem.push_new_stage_inject; eauto. all: eauto.
<       2: instantiate (2 := nil); simpl; eauto.
<       -- apply match_stacks_nil with (Mem.nextblock m2).
<          ++ constructor; intros.
<             ** apply Ple_refl.
<             ** unfold Mem.flat_inj. apply pred_dec_true; auto.
<             ** unfold Mem.flat_inj in H. destr_in H.
<             ** cut (Plt b0 (Mem.nextblock m0)). rewnb. xomega. eapply Genv.find_symbol_not_fresh; eauto.
<             ** cut (Plt b0 (Mem.nextblock m0)). rewnb. xomega. eapply Genv.find_funct_ptr_not_fresh; eauto.
<             ** cut (Plt b0 (Mem.nextblock m0)). rewnb. xomega. eapply Genv.find_var_info_not_fresh; eauto.
<          ++ rewnb. apply Ple_refl.
<       -- intro b0.
<          repeat rewrite_stack_blocks.
<          rewrite ! in_stack_cons.
<          intros [[]|[[|[]]|[]]]. simpl in H; subst. rewnb. unfold Mem.flat_inj.
<          destr. eauto. xomega.
<       -- repeat rewrite_stack_blocks. simpl.
<          repeat econstructor; omega.
---
>   econstructor; eauto.
>   instantiate (1 := Mem.flat_inj (Mem.nextblock m0)).
>   apply match_stacks_nil with (Mem.nextblock m0).
>   constructor; intros.
>     unfold Mem.flat_inj. apply pred_dec_true; auto.
>     unfold Mem.flat_inj in H. destruct (plt b1 (Mem.nextblock m0)); congruence.
>     eapply Genv.find_symbol_not_fresh; eauto.
>     eapply Genv.find_funct_ptr_not_fresh; eauto.
>     eapply Genv.find_var_info_not_fresh; eauto.
>     apply Ple_refl.
>   eapply Genv.initmem_inject; eauto.
2243c1311
<   match_states' st1 st2 -> final_state st1 r -> final_state st2 r.
---
>   match_states st1 st2 -> final_state st1 r -> final_state st2 r.
2245c1313
<   intros. inv H. inv H0. inv MATCH.
---
>   intros. inv H0. inv H.
2251c1319
<   forward_simulation (semantics fn_stack_requirements prog) (semantics fn_stack_requirements tprog).
---
>   forward_simulation (semantics prog) (semantics tprog).
2253,2269c1321,1325
<   eapply forward_simulation_star with (match_states := fun s1 s2 => match_states' s1 s2 /\ stack_inv s1 /\ stack_inv s2).
<   - apply senv_preserved.
<   - simpl; intros s1 IS1. edestruct transf_initial_states as (s2 & IS2 & MS); eauto.
<     eexists; split; eauto. split; auto. split; eapply stack_inv_initial; eauto.
<   - simpl; intros s1 s2 m (MS & SI1 & SI2) FS. eapply transf_final_states; eauto.
<   - instantiate (1 := measure).
<     simpl; intros s1 t s1' STEP s2 (MS & SI1 & SI2).
<     inv MS.
<     exploit step_simulation; eauto.
<     intros [(s2' & PLUS & MS')|(MES & TE0 & MS')].
<     + left; eexists; split; eauto. split.
<       econstructor; eauto. split.
<       eapply stack_inv_inv; eauto.
<       eapply inv_plus. apply stack_inv_inv; eauto. eauto. eauto.
<     + right; split; auto. split; auto. split; auto.
<       econstructor; eauto. split; auto.
<       eapply stack_inv_inv; eauto.
---
>   eapply forward_simulation_star.
>   apply senv_preserved.
>   eexact transf_initial_states.
>   eexact transf_final_states.
>   eexact step_simulation.
